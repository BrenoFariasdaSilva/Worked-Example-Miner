diff --git a/zookeeper/test/com/yahoo/zookeeper/test/AsyncTest.java b/zookeeper/test/com/yahoo/zookeeper/test/AsyncTest.java
new file mode 100644
index 000000000..c6d85eae5
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/AsyncTest.java
@@ -0,0 +1,195 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import junit.framework.TestCase;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StringCallback;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.KeeperException.Code;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
+
+public class AsyncTest extends TestCase implements Watcher, StringCallback, VoidCallback, DataCallback {
+    protected static String hostPort = "127.0.0.1:33221";
+    LinkedBlockingQueue<WatcherEvent> events = new LinkedBlockingQueue<WatcherEvent>();
+    static File baseTest = new File(System.getProperty("build.test.dir", "build"));
+    NIOServerCnxn.Factory f = null;
+    QuorumTest qt = new QuorumTest();
+    @Before
+    protected void setUp() throws Exception {
+        qt.setUp();
+        hostPort = ClientTest.hostPort;
+    }
+
+    protected void restart() throws Exception {
+        qt.startServers();
+    }
+    
+    @After
+    protected void tearDown() throws Exception {
+        qt.tearDown();
+    	ZooLog.logError("Clent test shutdown");
+        if (f != null) {
+            f.shutdown();
+        }
+        ZooLog.logError("Client test shutdown finished");
+    }
+    
+    boolean bang;
+    
+    class HammerThread extends Thread implements Watcher, StringCallback, VoidCallback {
+        ZooKeeper zk;
+        public void run() {
+        try {
+            zk = new ZooKeeper(hostPort, 30000, this);
+            while(bang) {
+                zk.create("/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateFlags.SEQUENCE, this, null);
+                incOut();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        }
+        int outstanding;
+        synchronized void incOut() throws InterruptedException {
+            outstanding++;
+            while(outstanding > 30) {
+                wait();
+            }
+        }
+        synchronized void decOut() {
+            outstanding--;
+            notifyAll();
+        }
+
+        @Override
+        public void process(WatcherEvent event) {
+        }
+
+        @Override
+        public void processResult(int rc, String path, Object ctx, String name) {
+            try {
+                decOut();
+                zk.delete(path, -1, this, null);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        @Override
+        public void processResult(int rc, String path, Object ctx) {
+        }
+    }
+    
+    @Test
+    public void testHammer() throws Exception {
+        Thread.sleep(1000);
+        bang = true;
+        for(int i = 0; i < 100; i++) {
+            new HammerThread().start();
+        }
+        Thread.sleep(5000);
+        tearDown();
+        bang = false;
+        restart();
+        Thread.sleep(5000);
+        String parts[] = hostPort.split(",");
+        String prevList[] = null;
+        for(String hp: parts) {
+            ZooKeeper zk = new ZooKeeper(hp, 30000, this);
+            String list[] = zk.getChildren("/", false).toArray(new String[0]);
+            if (prevList != null) {
+                assertEquals(prevList.length, list.length);
+                for(int i = 0; i < list.length; i++) {
+                    assertEquals(prevList[i], list[i]);
+                }
+            }
+            prevList = list;
+        }
+    }
+    
+    LinkedList<Integer> results = new LinkedList<Integer>();
+    @Test
+    public void testAsync() throws KeeperException, IOException,
+            InterruptedException {
+        ZooKeeper zk = null;
+            zk = new ZooKeeper(hostPort, 30000, this);
+            zk.addAuthInfo("digest", "ben:passwd".getBytes());
+            zk.create("/ben", new byte[0], Ids.READ_ACL_UNSAFE, 0, this, results);
+            zk.create("/ben/2", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
+            zk.delete("/ben", -1, this, results);
+            zk.create("/ben2", new byte[0], Ids.CREATOR_ALL_ACL, 0, this, results);
+            zk.getData("/ben2", false, this, results);
+            synchronized(results) {
+                while(results.size() < 5) {
+                    results.wait();
+                }
+            }
+            assertEquals(0, (int)results.get(0));
+            assertEquals(Code.NoAuth, (int)results.get(1));
+            assertEquals(0, (int)results.get(2));
+            assertEquals(0, (int)results.get(3));
+            assertEquals(0, (int)results.get(4));
+            zk.close();
+
+            zk = new ZooKeeper(hostPort, 30000, this);
+            zk.addAuthInfo("digest", "ben:passwd2".getBytes());
+            try {
+                zk.getData("/ben2", false, new Stat());
+                fail("Should have received a permission error");
+            } catch(KeeperException e) {
+                assertEquals(Code.NoAuth, e.getCode());
+            }
+            zk.close();
+
+            zk = new ZooKeeper(hostPort, 30000, this);
+            zk.addAuthInfo("digest", "ben:passwd".getBytes());
+            zk.getData("/ben2", false, new Stat());
+            zk.close();
+
+    }
+
+    public void process(WatcherEvent event) {
+        // TODO Auto-generated method stub
+        
+    }
+
+    public void processResult(int rc, String path, Object ctx, String name) {
+        ((LinkedList<Integer>)ctx).add(rc);
+        synchronized(ctx) {
+            ctx.notifyAll();
+        }
+    }
+
+    public void processResult(int rc, String path, Object ctx) {
+        ((LinkedList<Integer>)ctx).add(rc);
+        synchronized(ctx) {
+            ctx.notifyAll();
+        }
+    }
+
+    public void processResult(int rc, String path, Object ctx, byte[] data,
+            Stat stat) {
+        ((LinkedList<Integer>)ctx).add(rc);
+        synchronized(ctx) {
+            ctx.notifyAll();
+        }
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java b/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java
new file mode 100755
index 000000000..64d44e040
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/ClientTest.java
@@ -0,0 +1,295 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import junit.framework.TestCase;
+import org.junit.Test;
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.KeeperException.Code;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
+
+public class ClientTest extends TestCase implements Watcher {
+    protected static String hostPort = "127.0.0.1:33221";
+    LinkedBlockingQueue<WatcherEvent> events = new LinkedBlockingQueue<WatcherEvent>();
+    static File baseTest = new File(System.getProperty("build.test.dir", "build"));
+    NIOServerCnxn.Factory f = null;
+    File tmpDir = null;
+    
+    protected void setUp() throws Exception {
+    	ZooLog.logError("Client test setup");
+        tmpDir = File.createTempFile("test", ".junit", baseTest);
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+        hostPort = "127.0.0.1:33221";
+        f = new NIOServerCnxn.Factory(33221);
+        f.startup(zks);
+        Thread.sleep(5000);
+        ZooLog.logError("Client test setup finished");
+    }
+
+    protected void tearDown() throws Exception {
+    	ZooLog.logError("Clent test shutdown");
+        if (tmpDir != null) {
+            recursiveDelete(tmpDir);
+        }
+        if (f != null) {
+            f.shutdown();
+        }
+        ZooLog.logError("Client test shutdown finished");
+    }
+    
+    static void recursiveDelete(File d) {
+        if (d.isDirectory()) {
+            File children[] = d.listFiles();
+            for (File f : children) {
+                recursiveDelete(f);
+            }
+        }
+        d.delete();
+    }
+
+    @Test
+    public void testClient() throws KeeperException, IOException,
+            InterruptedException {
+        ZooKeeper zk = null;
+        try {
+            zk = new ZooKeeper(hostPort, 30000, this);
+            //System.out.println("Created client: " + zk.describeCNXN());
+            System.out.println("Before create /benwashere");
+            zk.create("/benwashere", "".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+            System.out.println("After create /benwashere");
+            try {
+            	zk.setData("/benwashere", "hi".getBytes(), 57);
+        		fail("Should have gotten BadVersion exception");
+            } catch(KeeperException e) {
+            	if (e.getCode() != Code.BadVersion) {
+            		fail("Should have gotten BadVersion exception");
+            	}
+            }
+            System.out.println("Before delete /benwashere");
+            zk.delete("/benwashere", 0);
+            System.out.println("Before delete /benwashere");
+            zk.close();
+            //System.out.println("Closed client: " + zk.describeCNXN());
+            Thread.sleep(2000);
+            zk = new ZooKeeper(hostPort, 30000, this);
+            //System.out.println("Created a new client: " + zk.describeCNXN());
+            System.out.println("Before delete /");
+            
+            try {
+                zk.delete("/", -1);
+                fail("deleted root!");
+            } catch(KeeperException e) {
+                assertEquals(KeeperException.Code.BadArguments, e.getCode());
+            }
+            Stat stat = new Stat();
+            // Test basic create, ls, and getData
+            System.out.println("Before create /ben");
+            zk.create("/ben", "Ben was here".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+            System.out.println("Before getChildren /");
+            ArrayList<String> children = zk.getChildren("/", false);
+            assertEquals(1, children.size());
+            assertEquals("ben", children.get(0));
+            String value = new String(zk.getData("/ben", false, stat));
+            assertEquals("Ben was here", value);
+            // Test stat and watch of non existent node
+            try {
+                assertEquals(null, zk.exists("/frog", true));
+                System.out.println("Comment: asseting passed for frog setting /");
+            } catch (KeeperException e) {
+                assertEquals(Code.NoNode, e.getCode());
+            }
+            zk.create("/frog", "hi".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+            // the first poll is just a sesssion delivery
+            System.out.println("Comment: checking for events length " + events.size());
+            WatcherEvent event = events.poll(10, TimeUnit.SECONDS);
+            assertEquals("/frog", event.getPath());
+            assertEquals(Event.EventNodeCreated, event.getType());
+            assertEquals(Event.KeeperStateSyncConnected, event.getState());
+            // Test child watch and create with sequence
+            zk.getChildren("/ben", true);
+            for (int i = 0; i < 10; i++) {
+                zk.create("/ben/" + i + "-", Integer.toString(i).getBytes(),
+                        Ids.OPEN_ACL_UNSAFE, CreateFlags.SEQUENCE);
+            }
+            children = zk.getChildren("/ben", false);
+            Collections.sort(children);
+            assertEquals(10, children.size());
+            for (int i = 0; i < 10; i++) {
+                final String name = children.get(i);
+                assertTrue(name.startsWith(i + "-"));
+                byte b[] = zk.getData("/ben/" + name, true, stat);
+                assertEquals(Integer.toString(i), new String(b));
+                zk.setData("/ben/" + name, "new".getBytes(), stat.getVersion());
+                stat = zk.exists("/ben/" + name, true);
+                zk.delete("/ben/" + name, stat.getVersion());
+            }
+            event = events.poll(10, TimeUnit.SECONDS);
+            assertEquals("/ben", event.getPath());
+            assertEquals(Event.EventNodeChildrenChanged, event.getType());
+            assertEquals(Event.KeeperStateSyncConnected, event.getState());
+            for (int i = 0; i < 10; i++) {
+                event = events.poll(10, TimeUnit.SECONDS);
+                final String name = children.get(i);
+                assertEquals("/ben/" + name, event.getPath());
+                assertEquals(Event.EventNodeDataChanged, event.getType());
+                assertEquals(Event.KeeperStateSyncConnected, event.getState());
+                event = events.poll(10, TimeUnit.SECONDS);
+                assertEquals("/ben/" + name, event.getPath());
+                assertEquals(Event.EventNodeDeleted, event.getType());
+                assertEquals(Event.KeeperStateSyncConnected, event.getState());
+            }
+            zk.create("/good\u0001path", "".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+            //try {
+            //    zk.create("/bad\u0000path", "".getBytes(), null, 0);
+            //    fail("created an invalid path");
+            //} catch(KeeperException e) {
+            //    assertEquals(KeeperException.Code.BadArguments, e.getCode());
+            //}
+            
+            zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+            try {
+                zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, 0);
+                fail("duplicate create allowed");
+            } catch(KeeperException e) {
+                assertEquals(Code.NodeExists, e.getCode());
+            }
+        } finally {
+            if (zk != null) {
+                zk.close();
+            }
+        }
+    }
+
+    private void notestConnections() throws KeeperException, IOException, InterruptedException {
+        ZooKeeper zk;
+        for(int i = 0; i < 2000; i++) {
+            if (i % 100 == 0) {
+                System.out.println("Testing " + i + " connections");
+            }
+            // We want to make sure socket descriptors are going away
+            zk = new ZooKeeper(hostPort, 30000, this);
+            zk.getData("/", false, new Stat());
+            zk.close();
+        }
+    }
+
+    static class HammerThread extends Thread {
+        ZooKeeper zk;
+        String prefix;
+        int count;
+
+        HammerThread(ZooKeeper zk, String prefix, int count) {
+            this.zk = zk;
+            this.prefix = prefix;
+            this.count = count;
+            start();
+        }
+
+        public void run() {
+            byte b[] = new byte[256];
+            try {
+                for (int i = 0; i < count; i++) {
+                    // Simulate a bit of network latency...
+                    Thread.sleep(5);
+                    zk.create(prefix + i, b, Ids.OPEN_ACL_UNSAFE, 0);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        public void close() throws IOException, InterruptedException,
+                KeeperException {
+            zk.close();
+        }
+    }
+
+    @Test
+    public void testDeleteWithChildren() throws Exception {
+        File tmpDir = File.createTempFile("test", ".junit", baseTest);
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        ZooKeeper zk = new ZooKeeper(hostPort, 30000, this);
+        zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, 0);
+        zk.create("/parent/child", new byte[0], Ids.OPEN_ACL_UNSAFE, 0);
+        try {
+            zk.delete("/parent", -1);
+            fail("Should have received a not equals message");
+        } catch (KeeperException e) {
+            assertEquals(KeeperException.Code.NotEmpty, e.getCode());
+        }
+        zk.delete("/parent/child", -1);
+        zk.delete("/parent", -1);
+        zk.close();
+    }
+
+    @Test
+    public void testHammer() throws KeeperException, IOException,
+            InterruptedException {
+        File tmpDir = File.createTempFile("test", ".junit", baseTest);
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        try {
+            final int threadCount = 10;
+            final int childCount = 1000;
+            ArrayList<HammerThread> threads = new ArrayList<HammerThread>(
+                    threadCount);
+            long start = System.currentTimeMillis();
+            for (int i = 0; i < threadCount; i++) {
+                Thread.sleep(10);
+                ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+                String prefix = "/test-" + i;
+                zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, 0);
+                prefix += "/";
+                threads.add(new HammerThread(zk, prefix, childCount));
+            }
+            for (HammerThread h : threads) {
+                h.join();
+                h.close();
+            }
+            System.err.println(new Date() + " Total time "
+                    + (System.currentTimeMillis() - start));
+            ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+            ZooLog.logWarn("******************* Connected to ZooKeeper" + new Date());
+            for (int i = 0; i < threadCount; i++) {
+                System.err.println("Doing thread: " + i + " " + new Date());
+                ArrayList<String> children = zk
+                        .getChildren("/test-" + i, false);
+                assertEquals(childCount, children.size());
+            }
+            for (int i = 0; i < threadCount; i++) {
+                ArrayList<String> children = zk
+                        .getChildren("/test-" + i, false);
+                assertEquals(childCount, children.size());
+            }
+        } finally {
+            //  recursiveDelete(tmpDir);
+        }
+    }
+
+    public void process(WatcherEvent event) {
+       if (event.getType() != Event.EventNone){ 
+         try {
+              events.put(event);
+          } catch (InterruptedException e) {
+              e.printStackTrace();
+          }
+       }
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/CreateHammerTest.java b/zookeeper/test/com/yahoo/zookeeper/test/CreateHammerTest.java
new file mode 100644
index 000000000..0ec65e84b
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/CreateHammerTest.java
@@ -0,0 +1,47 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.IOException;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.AsyncCallback.VoidCallback;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+
+public class CreateHammerTest implements VoidCallback {
+
+    /**
+     * @param args
+     */
+    static int REPS = 50000;
+    public static void main(String[] args) {
+            long startTime = System.currentTimeMillis();
+            ZooKeeper zk = null;
+            try {
+                zk = new ZooKeeper(args[0], 10000, null);
+            } catch (KeeperException e1) {
+                // TODO Auto-generated catch block
+                e1.printStackTrace();
+            } catch (IOException e1) {
+                // TODO Auto-generated catch block
+                e1.printStackTrace();
+            }
+            for(int i = 0; i < REPS; i++) {
+                try {
+                    String name = zk.create("/testFile-", new byte[16], Ids.OPEN_ACL_UNSAFE,
+                        CreateFlags.EPHEMERAL|CreateFlags.SEQUENCE);
+                    zk.delete(name, -1, new CreateHammerTest(), null);
+                } catch(Exception e) {
+                    i--;
+                    e.printStackTrace();
+                }
+            }
+            System.out.println("creates/sec=" + (REPS*1000/(System.currentTimeMillis()-startTime)));
+    }
+    @Override
+    public void processResult(int rc, String path, Object ctx) {
+        // TODO Auto-generated method stub
+        
+    }
+
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/GenerateLoad.java b/zookeeper/test/com/yahoo/zookeeper/test/GenerateLoad.java
new file mode 100644
index 000000000..08de705c0
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/GenerateLoad.java
@@ -0,0 +1,490 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooDefs;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.AsyncCallback.DataCallback;
+import com.yahoo.zookeeper.AsyncCallback.StatCallback;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+
+public class GenerateLoad {
+    static ServerSocket ss;
+    
+    static Set<SlaveThread> slaves = Collections
+            .synchronizedSet(new HashSet<SlaveThread>());
+
+    static HashMap<Long, Long> totalByTime = new HashMap<Long, Long>();
+
+    static long currentInterval;
+
+    static long lastChange;
+
+    static PrintStream sf;
+    static PrintStream tf;
+    static {
+        try {
+            tf = new PrintStream(new FileOutputStream("trace"));
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    static final int INTERVAL = 6000;
+    
+    synchronized static void add(long time, int count, Socket s) {
+        long interval = time / INTERVAL;
+        if (currentInterval == 0 || currentInterval > interval) {
+            System.out.println("Dropping " + count + " for " + new Date(time) + " " + currentInterval + ">" + interval);
+            return;
+        }
+        // We track totals by seconds
+        Long total = totalByTime.get(interval);
+        if (total == null) {
+            totalByTime.put(interval, (long) count);
+        } else {
+            totalByTime.put(interval, total.longValue() + count);
+        }
+        tf.println(interval + " " + count + " " + s);
+    }
+
+    synchronized static long remove(long interval) {
+        Long total = totalByTime.remove(interval);
+        return total == null ? -1 : total;
+    }
+
+    static class SlaveThread extends Thread {
+        Socket s;
+
+        SlaveThread(Socket s) {
+            setDaemon(true);
+            this.s = s;
+            start();
+        }
+
+        @SuppressWarnings("deprecation")
+        public void run() {
+            try {
+                System.out.println("Connected to " + s);
+                DataInputStream is = new DataInputStream(
+                        new BufferedInputStream(s.getInputStream()));
+                String result;
+                while ((result = is.readLine()) != null) {
+                    String timePercentCount[] = result.split(" ");
+                    if (timePercentCount.length != 5) {
+                        System.err.println("Got " + result + " from " + s + " exitng.");
+                        throw new IOException(result);
+                    }
+                    long time = Long.parseLong(timePercentCount[0]);
+                    int percent = Integer.parseInt(timePercentCount[1]);
+                    int count = Integer.parseInt(timePercentCount[2]);
+                    int errs = Integer.parseInt(timePercentCount[3]);
+                    if (errs > 0) {
+                        System.out.println(s+" Got an error! " + errs);
+                    }
+                    add(time, count, s);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                close();
+            }
+        }
+
+        void send(int percentage) {
+            try {
+                s.getOutputStream().write((percentage + "\n").getBytes());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        void close() {
+            try {
+                System.err.println("Closing " + s);
+                slaves.remove(this);
+                s.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    static class AcceptorThread extends Thread {
+        AcceptorThread() {
+            setDaemon(true);
+            start();
+        }
+
+        public void run() {
+            try {
+                while (true) {
+                    Socket s = ss.accept();
+                    slaves.add(new SlaveThread(s));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext();) {
+                    SlaveThread st = it.next();
+                    it.remove();
+                    st.close();
+                }
+            }
+        }
+    }
+
+    static class ReporterThread extends Thread {
+        ReporterThread() {
+            setDaemon(true);
+            start();
+        }
+
+        public void run() {
+            try {
+                currentInterval = System.currentTimeMillis() / INTERVAL;
+                // Give things time to report;
+                Thread.sleep(INTERVAL*2);
+                long min = 99999;
+                long max = 0;
+                long total = 0;
+                int number = 0;
+                while (true) {
+                    long now = System.currentTimeMillis();
+                    long lastInterval = currentInterval;
+                    currentInterval += 1;
+                    long count = remove(lastInterval);
+                    count=count*1000/INTERVAL; // Multiply by 1000 to get reqs/sec
+                    if (lastChange != 0 && (lastChange + INTERVAL*4 + 5000)< now) {
+                        // We only want to print anything if things have had a
+                        // chance to change
+
+                        if (count < min) {
+                            min = count;
+                        }
+                        if (count > max) {
+                            max = count;
+                        }
+                        total += count;
+                        number++;
+                        Date date = new Date(lastInterval * INTERVAL);
+                        String report = lastInterval + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds()
+                                + " "
+                                + percentage
+                                + "% "
+                                + count
+                                + " "
+                                + min
+                                + " "
+                                + ((double)total / (double)number) + " " + max;
+                        System.err.println(report);
+                        if (sf != null) {
+                            sf.println(report);
+                        }
+                    } else {
+                        max = total = 0;
+                        min = 999999999;
+                        number = 0;
+                    }
+                    Thread.sleep(INTERVAL);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+
+        }
+    }
+
+    synchronized static void sendChange(int percentage) {
+        long now = System.currentTimeMillis();
+        long start = now;
+        GenerateLoad.percentage = percentage;
+        for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {
+            st.send(percentage);
+        }
+        long delay = now - start;
+        if (delay > 1000) {
+            System.out.println("Delay of " + delay + " to send new percentage");
+        }
+        lastChange = now;
+    }
+
+    static int percentage = -1;
+
+    static String host;
+
+        static Socket s;
+    
+        static int errors;
+      
+        static Object statSync = new Object();
+        
+        static int finished;
+        
+        static int reads;
+        
+        static int writes;
+        
+        static int rlatency;
+        
+        static int wlatency;
+
+        static int outstanding;
+        
+    static class ZooKeeperThread extends Thread implements Watcher, DataCallback,
+            StatCallback {
+        ZooKeeperThread() {
+            setDaemon(true);
+            start();
+            alive = true;
+        }
+
+        static final int outstandingLimit = 100;
+
+        synchronized void incOutstanding() throws InterruptedException {
+            outstanding++;
+            while (outstanding > outstandingLimit) {
+                wait();
+            }
+        }
+
+        synchronized void decOutstanding() {
+            outstanding--;
+            notifyAll();
+        }
+
+        boolean alive;
+
+        Random r = new Random();
+
+        String path;
+
+        ZooKeeper zk;
+        public void run() {
+            try {
+                byte bytes[] = new byte[1024];
+                zk = new ZooKeeper(host, 60000, this);
+                for(int i = 0; i < 300; i++) {
+                    try {
+                        Thread.sleep(100);
+                        path = zk.create("/client", new byte[16], Ids.OPEN_ACL_UNSAFE,
+                                CreateFlags.EPHEMERAL|CreateFlags.SEQUENCE);
+                        break;
+                    } catch(KeeperException e) {
+                    }
+                }
+                if (path == null) {
+                    System.err.println("Couldn't create a node in /!");
+                    System.exit(44);
+                }
+                System.err.println("Created: " + s);
+                while (alive) {
+                    if (r.nextInt(100) < percentage) {
+                        zk.setData(path, bytes, -1, this, System.currentTimeMillis());
+                    } else {
+                        zk.getData(path, false, this, System.currentTimeMillis());
+                    }
+                    incOutstanding();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                System.exit(3);
+            } finally {
+                alive = false;
+            }
+        }
+
+        @Override
+        public void process(WatcherEvent event) {
+            System.err.println(event);
+            synchronized(this) {
+                try {
+                    wait(200);
+                } catch (InterruptedException e) {
+                    // TODO Auto-generated catch block
+                    e.printStackTrace();
+                }
+            }
+            if (event.getType() == Watcher.Event.EventNone && event.getState() == Watcher.Event.KeeperStateExpired) {
+                try {
+                    zk = new ZooKeeper(host, 10000, this);
+                } catch (KeeperException e) {
+                    e.printStackTrace();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+                
+            }
+        }
+
+        @Override
+        public void processResult(int rc, String path, Object ctx, byte[] data,
+                Stat stat) {
+            decOutstanding();
+            synchronized(statSync) {
+            if (rc != 0) {
+                System.err.println("Got rc = " + rc);
+                errors++;
+            } else {
+                finished++;
+                rlatency += System.currentTimeMillis() - (Long)ctx;
+                reads++;
+            }
+            }
+
+        }
+
+        @Override
+        public void processResult(int rc, String path, Object ctx, Stat stat) {
+            decOutstanding();
+            synchronized(statSync) {
+            if (rc != 0) {
+                System.err.println("Got rc = " + rc);
+                errors++;
+            } else {
+                finished++;
+                wlatency += System.currentTimeMillis() - (Long)ctx;
+                writes++;
+            }
+            }
+        }
+    }
+
+    static class SenderThread extends Thread {
+        SenderThread() {
+            setDaemon(true);
+            start();
+        }
+        public void run() {
+            try {
+                OutputStream os = s.getOutputStream();
+                finished = 0;
+                errors = 0;
+                while(true) {
+                    Thread.sleep(300);
+                    if (percentage == -1 || (finished == 0 && errors == 0)) {
+                        continue;
+                    }
+                    String report = System.currentTimeMillis() + " " + percentage + " " + finished + " " + errors + " " + outstanding + "\n";
+                    String subreport = reads + " " + (((double)rlatency)/reads) + " " + writes + " " + (((double)wlatency/writes));
+                    synchronized(statSync) {
+                    finished = 0;
+                    errors = 0;
+                    reads = 0;
+                    writes = 0;
+                    rlatency = 0;
+                    wlatency = 0;
+                    }
+                    os.write(report.getBytes());
+                    System.out.println("Reporting " + report + "+" + subreport);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            
+        }
+    }
+    
+    /**
+     * @param args
+     * @throws InterruptedException 
+     */
+    public static void main(String[] args) throws InterruptedException {
+        if (args.length == 1) {
+            try {
+                int port = Integer.parseInt(args[0]);
+                ss = new ServerSocket(port);
+                new AcceptorThread();
+                new ReporterThread();
+                DataInputStream is = new DataInputStream(System.in);
+                String line;
+                while ((line = is.readLine()) != null) {
+                    try {
+                        String cmdNumber[] = line.split(" ");
+                        if (cmdNumber[0].equals("percentage") && cmdNumber.length > 1) {
+                            int number = Integer.parseInt(cmdNumber[1]);
+                            if (number < 0 || number > 100) {
+                                throw new NumberFormatException("must be between 0 and 100");
+                            }
+                            sendChange(number);
+                        } else if (cmdNumber[0].equals("sleep") && cmdNumber.length > 1) {
+                            int number = Integer.parseInt(cmdNumber[1]);
+                            Thread.sleep(number*1000);
+                        } else if (cmdNumber[0].equals("save") && cmdNumber.length > 1) {
+                            sf = new PrintStream(cmdNumber[1]);
+                        } else {
+                            System.err.println("Commands must be:");
+                            System.err.println("\tpercentage new_write_percentage");
+                            System.err.println("\tsleep seconds_to_sleep");
+                            System.err.println("\tsave file_to_save_output");
+                        }
+                    } catch (NumberFormatException e) {
+                        System.out
+                                .println("Not a valid number: " + e.getMessage());
+                    }
+                }
+            } catch (NumberFormatException e) {
+                doUsage();
+            } catch (IOException e) {
+                e.printStackTrace();
+                System.exit(2);
+            }
+        } else if (args.length == 2) {
+            host = args[1];
+            String hostPort[] = args[0].split(":");
+            try {
+                s = new Socket(hostPort[0], Integer
+                        .parseInt(hostPort[1]));
+                new ZooKeeperThread();
+                new SenderThread();
+                DataInputStream is = new DataInputStream(s.getInputStream());
+                String line;
+                while((line = is.readLine()) != null) {
+                    percentage = Integer.parseInt(line);
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        } else {
+            doUsage();
+        }
+
+    }
+
+    private static void doUsage() {
+        System.err
+                .println("USAGE: "
+                        + GenerateLoad.class.getName()
+                        + " controller_host:port zookeeper_host:port-> connects to a controller");
+        System.err.println("USAGE: " + GenerateLoad.class.getName()
+                + " controller_port -> starts a controller");
+        System.exit(2);
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/OOMTest.java b/zookeeper/test/com/yahoo/zookeeper/test/OOMTest.java
new file mode 100644
index 000000000..03ea27bc9
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/OOMTest.java
@@ -0,0 +1,128 @@
+/**
+ * 
+ */
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import junit.framework.TestCase;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+
+/**
+ * @author breed
+ * 
+ */
+public class OOMTest extends TestCase implements Watcher {
+    public void testOOM() throws IOException, InterruptedException,
+            KeeperException {
+        // This test takes too long to run!
+        if (true)
+            return;
+        File tmpDir = File.createTempFile("test", ".junit");
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        // Grab some memory so that it is easier to cause an
+        // OOM condition;
+        ArrayList<byte[]> hog = new ArrayList<byte[]>();
+        while (true) {
+            try {
+                hog.add(new byte[1024 * 1024 * 2]);
+            } catch (OutOfMemoryError e) {
+                hog.remove(0);
+                break;
+            }
+        }
+        ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+        NIOServerCnxn.Factory f = new NIOServerCnxn.Factory(33221);
+        f.startup(zks);
+        Thread.sleep(2000);
+        System.err.println("OOM Stage 0");
+        utestPrep();
+        System.out.println("Free = " + Runtime.getRuntime().freeMemory()
+                + " total = " + Runtime.getRuntime().totalMemory() + " max = "
+                + Runtime.getRuntime().maxMemory());
+        System.err.println("OOM Stage 1");
+        for (int i = 0; i < 1000; i++) {
+            System.out.println(i);
+            utestExists();
+        }
+        System.out.println("Free = " + Runtime.getRuntime().freeMemory()
+                + " total = " + Runtime.getRuntime().totalMemory() + " max = "
+                + Runtime.getRuntime().maxMemory());
+        System.err.println("OOM Stage 2");
+        for (int i = 0; i < 1000; i++) {
+            System.out.println(i);
+            utestGet();
+        }
+        System.out.println("Free = " + Runtime.getRuntime().freeMemory()
+                + " total = " + Runtime.getRuntime().totalMemory() + " max = "
+                + Runtime.getRuntime().maxMemory());
+        System.err.println("OOM Stage 3");
+        for (int i = 0; i < 1000; i++) {
+            System.out.println(i);
+            utestChildren();
+        }
+        System.out.println("Free = " + Runtime.getRuntime().freeMemory()
+                + " total = " + Runtime.getRuntime().totalMemory() + " max = "
+                + Runtime.getRuntime().maxMemory());
+        hog.get(0)[0] = (byte) 1;
+        f.shutdown();
+    }
+
+    private void utestExists() throws IOException, InterruptedException,
+            KeeperException {
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:33221", 30000, this);
+        for (int i = 0; i < 10000; i++) {
+            zk.exists("/this/path/doesnt_exist!", true);
+        }
+        zk.close();
+    }
+
+    private void utestPrep() throws KeeperException, IOException,
+            InterruptedException {
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:33221", 30000, this);
+        for (int i = 0; i < 10000; i++) {
+            zk.create("/" + i, null, Ids.OPEN_ACL_UNSAFE, 0);
+        }
+        zk.close();
+    }
+
+    private void utestGet() throws IOException, InterruptedException,
+            KeeperException {
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:33221", 30000, this);
+        for (int i = 0; i < 10000; i++) {
+            Stat stat = new Stat();
+            zk.getData("/" + i, true, stat);
+        }
+        zk.close();
+    }
+
+    private void utestChildren() throws IOException, InterruptedException,
+            KeeperException {
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:33221", 30000, this);
+        for (int i = 0; i < 10000; i++) {
+            zk.getChildren("/" + i, true);
+        }
+        zk.close();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.yahoo.zookeeper.Watcher#process(com.yahoo.zookeeper.proto.WatcherEvent)
+     */
+    public void process(WatcherEvent event) {
+        System.err.println("Got event " + event.getType() + " "
+                + event.getState() + " " + event.getPath());
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/QuorumTest.java b/zookeeper/test/com/yahoo/zookeeper/test/QuorumTest.java
new file mode 100644
index 000000000..1e0b6b2f2
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/QuorumTest.java
@@ -0,0 +1,85 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+
+import org.junit.After;
+import org.junit.Before;
+
+import com.yahoo.zookeeper.server.ZooLog;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer;
+import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+
+import junit.framework.TestCase;
+
+public class QuorumTest extends ClientTest {
+    static File baseTest = new File(System.getProperty("build.test.dir", "build"));
+    File s1dir, s2dir, s3dir, s4dir, s5dir;
+    QuorumPeer s1, s2, s3, s4, s5;
+    @Before
+    protected void setUp() throws Exception {
+        s1dir = File.createTempFile("test", ".junit", baseTest);
+        s1dir = new File(s1dir + ".dir");
+        s1dir.mkdirs();
+        s2dir = File.createTempFile("test", ".junit", baseTest);
+        s2dir = new File(s2dir + ".dir");
+        s2dir.mkdirs();
+        s3dir = File.createTempFile("test", ".junit", baseTest);
+        s3dir = new File(s3dir + ".dir");
+        s3dir.mkdirs();
+        s4dir = File.createTempFile("test", ".junit", baseTest);
+        s4dir = new File(s3dir + ".dir");
+        s4dir.mkdirs();
+        s5dir = File.createTempFile("test", ".junit", baseTest);
+        s5dir = new File(s3dir + ".dir");
+        s5dir.mkdirs();
+        startServers();
+        ZooLog.logWarn("Setup finished");
+    }
+    void startServers() throws IOException, InterruptedException {
+        int tickTime = 2000;
+        int initLimit = 3;
+        int syncLimit = 3;
+        ArrayList<QuorumServer> peers = new ArrayList<QuorumServer>();
+        hostPort = "127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183,127.0.0.1:2184,127.0.0.1:2185";
+        peers.add(new QuorumServer(1, new InetSocketAddress("127.0.0.1", 3181)));
+        peers.add(new QuorumServer(2, new InetSocketAddress("127.0.0.1", 3182)));
+        peers.add(new QuorumServer(3, new InetSocketAddress("127.0.0.1", 3183)));
+        peers.add(new QuorumServer(4, new InetSocketAddress("127.0.0.1", 3184)));
+        peers.add(new QuorumServer(5, new InetSocketAddress("127.0.0.1", 3185)));
+        ZooLog.logWarn("creating QuorumPeer 1");
+        s1 = new QuorumPeer(peers, s1dir, s1dir, 2181, 0,  1, tickTime, initLimit, syncLimit);
+        ZooLog.logWarn("creating QuorumPeer 2");
+        s2 = new QuorumPeer(peers, s2dir, s2dir, 2182, 0,  2, tickTime, initLimit, syncLimit);
+        ZooLog.logWarn("creating QuorumPeer 3");
+        s3 = new QuorumPeer(peers, s3dir, s3dir, 2183, 0, 3, tickTime, initLimit, syncLimit);
+        ZooLog.logWarn("creating QuorumPeer 4");
+        s4 = new QuorumPeer(peers, s4dir, s4dir, 2184, 0, 4, tickTime, initLimit, syncLimit);
+        ZooLog.logWarn("creating QuorumPeer 5");
+        s5 = new QuorumPeer(peers, s5dir, s5dir, 2185, 0, 5, tickTime, initLimit, syncLimit);
+        ZooLog.logWarn("start QuorumPeer 1");
+        s1.start();
+        ZooLog.logWarn("start QuorumPeer 2");
+        s2.start();
+        ZooLog.logWarn("start QuorumPeer 3");
+        s3.start();
+        ZooLog.logWarn("start QuorumPeer 4");
+        s4.start();
+        ZooLog.logWarn("start QuorumPeer 5");
+        s5.start();
+        ZooLog.logWarn("started QuorumPeer 5");
+        Thread.sleep(5000);
+    }
+    @After
+    protected void tearDown() throws Exception {
+        ZooLog.logWarn("TearDown started");
+        s1.shutdown();
+        s2.shutdown();
+        s3.shutdown();
+        s4.shutdown();
+        s5.shutdown();
+        Thread.sleep(5000);
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/RecoveryTest.java b/zookeeper/test/com/yahoo/zookeeper/test/RecoveryTest.java
new file mode 100644
index 000000000..891e7d115
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/RecoveryTest.java
@@ -0,0 +1,122 @@
+/**
+ * 
+ */
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+
+import junit.framework.TestCase;
+
+import org.junit.Test;
+
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.SyncRequestProcessor;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+
+/**
+ * @author breed
+ * 
+ */
+public class RecoveryTest extends TestCase implements Watcher {
+    static File baseTest = new File(System.getProperty("build.test.dir",
+            "build"));
+
+    @Test
+    public void testRecovery() throws Exception {
+        File tmpDir = File.createTempFile("test", ".junit", baseTest);
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        ZooKeeperServer zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+        int oldSnapCount = SyncRequestProcessor.snapCount;
+        SyncRequestProcessor.snapCount = 1000;
+        try {
+            NIOServerCnxn.Factory f = new NIOServerCnxn.Factory(2344);
+            f.startup(zs);
+            System.out.println("starting up the the server -- sleeping");
+            Thread.sleep(1000);
+            ZooKeeper zk = new ZooKeeper("127.0.0.1:2344", 20000, this);
+            String path;
+            System.out.println("starting creating nodes");
+            for (int i = 0; i < 10; i++) {
+                path = "/" + i;
+                zk
+                        .create(path, (path + "!").getBytes(),
+                                Ids.OPEN_ACL_UNSAFE, 0);
+                for (int j = 0; j < 10; j++) {
+                    String subpath = path + "/" + j;
+                    zk.create(subpath, (subpath + "!").getBytes(),
+                            Ids.OPEN_ACL_UNSAFE, 0);
+                    for (int k = 0; k < 20; k++) {
+                        String subsubpath = subpath + "/" + k;
+                        zk.create(subsubpath, (subsubpath + "!").getBytes(),
+                                Ids.OPEN_ACL_UNSAFE, 0);
+                    }
+                }
+            }
+            f.shutdown();
+            Thread.sleep(1000);
+            zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+            f = new NIOServerCnxn.Factory(2344);
+            f.startup(zs);
+            Thread.sleep(1000);
+            Stat stat = new Stat();
+            for (int i = 0; i < 10; i++) {
+                path = "/" + i;
+                System.out.println("Checking " + path);
+                assertEquals(new String(zk.getData(path, false, stat)), path
+                        + "!");
+                for (int j = 0; j < 10; j++) {
+                    String subpath = path + "/" + j;
+                    assertEquals(new String(zk.getData(subpath, false, stat)),
+                            subpath + "!");
+                    for (int k = 0; k < 20; k++) {
+                        String subsubpath = subpath + "/" + k;
+                        assertEquals(new String(zk.getData(subsubpath, false,
+                                stat)), subsubpath + "!");
+                    }
+                }
+            }
+            f.shutdown();
+            Thread.sleep(2000);
+            zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+            f = new NIOServerCnxn.Factory(2344);
+            f.startup(zs);
+            Thread.sleep(4000);
+            stat = new Stat();
+            System.out.println("Check 2");
+            for (int i = 0; i < 10; i++) {
+                path = "/" + i;
+                assertEquals(new String(zk.getData(path, false, stat)), path
+                        + "!");
+                for (int j = 0; j < 10; j++) {
+                    String subpath = path + "/" + j;
+                    assertEquals(new String(zk.getData(subpath, false, stat)),
+                            subpath + "!");
+                    for (int k = 0; k < 20; k++) {
+                        String subsubpath = subpath + "/" + k;
+                        assertEquals(new String(zk.getData(subsubpath, false,
+                                stat)), subsubpath + "!");
+                    }
+                }
+            }
+            f.shutdown();
+        } finally {
+            SyncRequestProcessor.snapCount = oldSnapCount;
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see com.yahoo.zookeeper.Watcher#process(com.yahoo.zookeeper.proto.WatcherEvent)
+     */
+    public void process(WatcherEvent event) {
+        // TODO Auto-generated method stub
+
+    }
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/SessionTest.java b/zookeeper/test/com/yahoo/zookeeper/test/SessionTest.java
new file mode 100644
index 000000000..bf242aa9d
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/SessionTest.java
@@ -0,0 +1,67 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import org.junit.Test;
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import junit.framework.TestCase;
+
+public class SessionTest extends TestCase implements Watcher {
+    static File baseTest = new File(System.getProperty("build.test.dir",
+            "build"));
+
+    @Test
+    public void testSession() throws IOException, InterruptedException,
+            KeeperException {
+        File tmpDir = File.createTempFile("test", ".junit", baseTest);
+        tmpDir = new File(tmpDir + ".dir");
+        tmpDir.mkdirs();
+        ZooKeeperServer zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+        NIOServerCnxn.Factory f = new NIOServerCnxn.Factory(33299);
+        f.startup(zs);
+        Thread.sleep(2000);
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:33299", 30000, this);
+        zk
+                .create("/e", new byte[0], Ids.OPEN_ACL_UNSAFE,
+                        CreateFlags.EPHEMERAL);
+        System.out.println("zk with session id " + zk.getSessionId()
+                + " was destroyed!");
+        // zk.close();
+        Stat stat = new Stat();
+        try {
+            zk = new ZooKeeper("127.0.0.1:33299", 30000, this, zk
+                    .getSessionId(), zk.getSessionPasswd());
+            System.out.println("zk with session id " + zk.getSessionId()
+                    + " was created!");
+            zk.getData("/e", false, stat);
+            System.out.println("After get data /e");
+        } catch (KeeperException e) {
+            // the zk.close() above if uncommented will close the session on the
+            // server
+            // in such case we get an exception here because we've tried joining
+            // a closed session
+        }
+        zk.close();
+        Thread.sleep(10000);
+        zk = new ZooKeeper("127.0.0.1:33299", 30000, this);
+        assertEquals(null, zk.exists("/e", false));
+        System.out.println("before close zk with session id "
+                + zk.getSessionId() + "!");
+        zk.close();
+        System.out.println("before shutdown zs!");
+        zs.shutdown();
+        System.out.println("after shutdown zs!");
+    }
+
+    public void process(WatcherEvent event) {
+    }
+
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/SledgeHammer.java b/zookeeper/test/com/yahoo/zookeeper/test/SledgeHammer.java
new file mode 100644
index 000000000..db71b9c80
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/SledgeHammer.java
@@ -0,0 +1,97 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+
+public class SledgeHammer extends Thread implements Watcher {
+    ZooKeeper zk;
+
+    int count;
+
+    int readsPerWrite;
+
+    public SledgeHammer(String hosts, int count, int readsPerWrite)
+            throws KeeperException, IOException {
+        zk = new ZooKeeper(hosts, 10000, this);
+        this.count = count;
+        this.readsPerWrite = readsPerWrite;
+    }
+
+    public void run() {
+        try {
+            Stat stat = new Stat();
+            String path = zk.create("/hammers/hammer-", new byte[0],
+                    Ids.OPEN_ACL_UNSAFE, CreateFlags.SEQUENCE);
+            byte tag[] = (path + " was here!").getBytes();
+            synchronized (this) {
+                String startPath = "/hammers/start";
+                System.out.println("Waiting for " + startPath);
+                while (zk.exists(startPath, true) == null) {
+                    wait();
+                }
+                System.out.println("Running");
+            }
+            for (int i = 0; i < count; i++) {
+                try {
+                    System.out.print(i + "\r");
+                    ArrayList<String> childs = zk
+                            .getChildren("/hammers", false);
+                    Collections.shuffle(childs);
+                    for (String s : childs) {
+                        if (s.startsWith("hammer-")) {
+                            s = "/hammers/" + s;
+                            zk.setData(s, tag, -1);
+                            for (int j = 0; j < readsPerWrite; j++) {
+                                zk.getData(s, false, stat);
+                            }
+                            break;
+                        }
+                    }
+                } catch (KeeperException e) {
+                    if (e.getCode() != KeeperException.Code.ConnectionLoss) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+            System.out.println();
+            zk.close();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * @param args
+     * @throws IOException
+     * @throws KeeperException
+     * @throws NumberFormatException
+     */
+    public static void main(String[] args) throws NumberFormatException,
+            KeeperException, IOException {
+        if (args.length != 3) {
+            System.err
+                    .println("USAGE: SledgeHammer zookeeper_server reps reads_per_rep");
+            System.exit(3);
+        }
+        SledgeHammer h = new SledgeHammer(args[0], Integer.parseInt(args[1]),
+                Integer.parseInt(args[2]));
+        h.run();
+        System.exit(0);
+    }
+
+    public void process(WatcherEvent event) {
+        synchronized (this) {
+            notifyAll();
+        }
+    }
+
+}
diff --git a/zookeeper/test/com/yahoo/zookeeper/test/ZooKeeperTestClient.java b/zookeeper/test/com/yahoo/zookeeper/test/ZooKeeperTestClient.java
new file mode 100644
index 000000000..2a7380587
--- /dev/null
+++ b/zookeeper/test/com/yahoo/zookeeper/test/ZooKeeperTestClient.java
@@ -0,0 +1,388 @@
+package com.yahoo.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import junit.framework.TestCase;
+
+import org.junit.Test;
+
+import com.yahoo.zookeeper.KeeperException;
+import com.yahoo.zookeeper.Watcher;
+import com.yahoo.zookeeper.ZooDefs;
+import com.yahoo.zookeeper.ZooKeeper;
+import com.yahoo.zookeeper.KeeperException.Code;
+import com.yahoo.zookeeper.Watcher.Event;
+import com.yahoo.zookeeper.ZooDefs.CreateFlags;
+import com.yahoo.zookeeper.ZooDefs.Ids;
+import com.yahoo.zookeeper.data.Stat;
+import com.yahoo.zookeeper.proto.WatcherEvent;
+import com.yahoo.zookeeper.server.NIOServerCnxn;
+import com.yahoo.zookeeper.server.ZooKeeperServer;
+import com.yahoo.zookeeper.server.ZooLog;
+import com.yahoo.zookeeper.test.ClientTest.HammerThread;
+
+public class ZooKeeperTestClient extends TestCase implements Watcher {
+  protected String hostPort = "127.0.0.1:22801";
+
+  protected static String dirOnZK = "/test_dir";
+
+  protected String testDirOnZK = dirOnZK + "/" + System.currentTimeMillis();
+
+  LinkedBlockingQueue<WatcherEvent> events = new LinkedBlockingQueue<WatcherEvent>();
+
+  private WatcherEvent getEvent(int numTries) throws InterruptedException {
+    WatcherEvent event = null;
+    for (int i = 0; i < numTries; i++) {
+      System.out.println("i = " + i);
+      event = events.poll(10, TimeUnit.SECONDS);
+      if (event != null) {
+        break;
+      }
+      Thread.sleep(5000);
+    }
+    return event;
+
+  }
+
+  private void deleteZKDir(ZooKeeper zk, String nodeName)
+      throws KeeperException, IOException, InterruptedException {
+
+    Stat stat = zk.exists(nodeName, false);
+    if (stat == null) {
+      return;
+    }
+
+    ArrayList<String> children = zk.getChildren(nodeName, false);
+    if (children.size() == 0) {
+      zk.delete(nodeName, -1);
+      return;
+    }
+    for (String n : children) {
+      deleteZKDir(zk, n);
+    }
+  }
+
+  private void checkRoot() throws KeeperException, IOException,
+      InterruptedException {
+    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+
+    try {
+      zk.create(dirOnZK, null, Ids.OPEN_ACL_UNSAFE, 0);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NodeExists;
+      if (!valid) {
+        fail("Unexpected exception code for create " + dirOnZK + ": "
+            + ke.getMessage());
+      }
+    }
+
+    try {
+      zk.create(testDirOnZK, null, Ids.OPEN_ACL_UNSAFE, 0);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NodeExists;
+      if (!valid) {
+        fail("Unexpected exception code for create " + testDirOnZK + ": "
+            + ke.getMessage());
+      }
+    }
+
+    zk.close();
+  }
+
+  private void enode_test_1() throws KeeperException, IOException,
+      InterruptedException {
+    checkRoot();
+    String parentName = testDirOnZK;
+    String nodeName = parentName + "/enode_abc";
+    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+
+    Stat stat = zk.exists(parentName, false);
+    if (stat == null) {
+      try {
+        zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, 0);
+      } catch (KeeperException ke) {
+        fail("Creating node " + parentName + ke.getMessage());
+      }
+    }
+
+    try {
+      zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, ZooDefs.CreateFlags.EPHEMERAL);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NodeExists;
+      if (!valid) {
+        fail("Unexpected exception code for createin: " + ke.getMessage());
+      }
+    }
+
+    stat = zk.exists(nodeName, false);
+    if (stat == null) {
+      fail("node " + nodeName + " should exist");
+    }
+    long prevSessionId = zk.getSessionId();
+    byte[] prevSessionPasswd = zk.getSessionPasswd();
+    System.out.println("Closing client with sessioid:  " + prevSessionId);
+    zk.close();
+    zk = new ZooKeeper(hostPort, 10000, this);
+
+    for (int i = 0; i < 10; i++) {
+      System.out.println("i = " + i);
+      stat = zk.exists(nodeName, false);
+      if (stat != null) {
+        System.out.println("node " + nodeName
+            + " should not exist after reconnection close");
+      } else {
+        System.out.println("node " + nodeName
+            + " is gone after reconnection close!");
+        break;
+      }
+      Thread.sleep(5000);
+    }
+    deleteZKDir(zk, nodeName);
+    zk.close();
+
+  }
+
+  private void enode_test_2() throws KeeperException, IOException,
+      InterruptedException {
+    checkRoot();
+    String parentName = testDirOnZK;
+    String nodeName = parentName + "/enode_abc";
+    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+    ZooKeeper zk_1 = new ZooKeeper(hostPort, 10000, this);
+
+    Stat stat = zk_1.exists(parentName, false);
+    if (stat == null) {
+      try {
+        zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, 0);
+      } catch (KeeperException ke) {
+        fail("Creating node " + parentName + ke.getMessage());
+      }
+    }
+
+    stat = zk_1.exists(nodeName, false);
+    if (stat != null) {
+
+      try {
+        zk.delete(nodeName, -1);
+      } catch (KeeperException ke) {
+        int code = ke.getCode();
+        boolean valid = code == KeeperException.Code.NoNode
+            || code == KeeperException.Code.NotEmpty;
+        if (!valid) {
+          fail("Unexpected exception code for delete: " + ke.getMessage());
+        }
+      }
+    }
+
+    ArrayList<String> firstGen = zk_1.getChildren(parentName, true);
+
+    try {
+      zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, ZooDefs.CreateFlags.EPHEMERAL);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NodeExists;
+      if (!valid) {
+        fail("Unexpected exception code for createin: " + ke.getMessage());
+      }
+    }
+
+    Thread.sleep(5000);
+    WatcherEvent event = events.poll(10, TimeUnit.SECONDS);
+    if (event == null) {
+      throw new IOException("No event was delivered promptly");
+    }
+    if (event.getType() != Watcher.Event.EventNodeChildrenChanged
+        || !event.getPath().equalsIgnoreCase(parentName)) {
+      fail("Unexpected event was delivered: " + event.toString());
+    }
+
+    stat = zk_1.exists(nodeName, false);
+    if (stat == null) {
+      fail("node " + nodeName + " should exist");
+    }
+
+    try {
+      zk.delete(parentName, -1);
+      fail("Should be impossible to delete a non-empty node " + parentName);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NotEmpty;
+      if (!valid) {
+        fail("Unexpected exception code for delete: " + code);
+      }
+    }
+
+    try {
+      zk.create(nodeName + "/def", null, Ids.OPEN_ACL_UNSAFE, ZooDefs.CreateFlags.EPHEMERAL);
+      fail("Should be impossible to create child off Ephemeral node "
+          + nodeName);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NoChildrenForEphemerals;
+      if (!valid) {
+        fail("Unexpected exception code for createin: " + code);
+      }
+    }
+
+    try {
+      ArrayList<String> children = zk.getChildren(nodeName, false);
+      if (children.size() > 0) {
+        fail("ephemeral node " + nodeName + " should not have children");
+      }
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NoNode;
+      if (!valid) {
+        fail("Unexpected exception code for createin: " + code);
+      }
+    }
+    firstGen = zk_1.getChildren(parentName, true);
+    stat = zk_1.exists(nodeName, true);
+    if (stat == null) {
+      fail("node " + nodeName + " should exist");
+    }
+    System.out.println("session id of zk: " + zk.getSessionId());
+    System.out.println("session id of zk_1: " + zk_1.getSessionId());
+    zk.close();
+  
+    stat = zk_1.exists("nosuchnode", false);
+    
+    event = this.getEvent(10);
+    if (event == null) {
+      fail("First event was not delivered promptly");
+    }
+    if (!((event.getType() == Watcher.Event.EventNodeChildrenChanged && 
+           event.getPath().equalsIgnoreCase(parentName)) ||
+         (event.getType() == Watcher.Event.EventNodeDeleted && 
+           event.getPath().equalsIgnoreCase(nodeName)))) {
+      System.out.print(parentName + " " 
+          + Watcher.Event.EventNodeChildrenChanged + " " + nodeName + " " + Watcher.Event.EventNodeDeleted);
+      fail("Unexpected first event was delivered: " + event.toString());
+    }
+
+    event = this.getEvent(10);
+
+    if (event == null) {
+      fail("Second event was not delivered promptly");
+    }
+    if (!((event.getType() == Watcher.Event.EventNodeChildrenChanged && 
+        event.getPath().equalsIgnoreCase(parentName)) ||
+      (event.getType() == Watcher.Event.EventNodeDeleted && 
+        event.getPath().equalsIgnoreCase(nodeName)))) {
+      System.out.print(parentName + " " 
+          + Watcher.Event.EventNodeChildrenChanged + " " + nodeName + " " + Watcher.Event.EventNodeDeleted);
+      fail("Unexpected second event was delivered: " + event.toString());
+    }
+
+    firstGen = zk_1.getChildren(parentName, false);
+    stat = zk_1.exists(nodeName, false);
+    if (stat != null) {
+      fail("node " + nodeName + " should have been deleted");
+    }
+    if (firstGen.contains(nodeName)) {
+      fail("node " + nodeName + " should not be a children");
+    }
+    deleteZKDir(zk_1, nodeName);
+    zk_1.close();
+  }
+
+  private void delete_create_get_set_test_1() throws KeeperException,
+      IOException, InterruptedException {
+    checkRoot();
+    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);
+    String parentName = testDirOnZK;
+    String nodeName = parentName + "/benwashere";
+    try {
+      zk.delete(nodeName, -1);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NoNode
+          || code == KeeperException.Code.NotEmpty;
+      if (!valid) {
+        fail("Unexpected exception code for delete: " + ke.getMessage());
+      }
+    }
+    try {
+      zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, 0);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NodeExists;
+      if (!valid) {
+        fail("Unexpected exception code for create: " + ke.getMessage());
+      }
+    }
+    try {
+      zk.setData(nodeName, "hi".getBytes(), 5700);
+      fail("Should have gotten BadVersion exception");
+    } catch (KeeperException ke) {
+      if (ke.getCode() != Code.BadVersion) {
+        fail("Should have gotten BadVersion exception");
+      }
+    }
+    zk.setData(nodeName, "hi".getBytes(), -1);
+    Stat st = new Stat();
+    byte[] bytes = zk.getData(nodeName, false, st);
+    String retrieved = new String(bytes);
+    if (!"hi".equals(retrieved)) {
+      fail("The retrieved data [" + retrieved
+          + "] is differented than the expected [hi]");
+    }
+    try {
+      zk.delete(nodeName, 6800);
+      fail("Should have gotten BadVersion exception");
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NotEmpty
+          || code == KeeperException.Code.BadVersion;
+      if (!valid) {
+        fail("Unexpected exception code for delete: " + ke.getMessage());
+      }
+    }
+    try {
+      zk.delete(nodeName, -1);
+    } catch (KeeperException ke) {
+      int code = ke.getCode();
+      boolean valid = code == KeeperException.Code.NotEmpty;
+      if (!valid) {
+        fail("Unexpected exception code for delete: " + code);
+      }
+    }
+    deleteZKDir(zk, nodeName);
+    zk.close();
+  }
+
+  @Test
+  public void my_test_1() throws KeeperException, IOException,
+      InterruptedException {
+    enode_test_1();
+    enode_test_2();
+    delete_create_get_set_test_1();
+  }
+
+  synchronized public void process(WatcherEvent event) {
+    try {
+      System.out.println("Got an event " + event.toString());
+      events.put(event);
+    } catch (InterruptedException e) {
+      e.printStackTrace();
+    }
+  }
+
+  public static void main(String[] args) {
+    ZooKeeperTestClient zktc = new ZooKeeperTestClient();
+    try {
+      zktc.my_test_1();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+}
\ No newline at end of file
