diff --git a/zookeeper/c/tests/CppAssertHelper.h b/zookeeper/c/tests/CppAssertHelper.h
new file mode 100644
index 000000000..423b13231
--- /dev/null
+++ b/zookeeper/c/tests/CppAssertHelper.h
@@ -0,0 +1,19 @@
+#ifndef CPPASSERTHELPER_H_
+#define CPPASSERTHELPER_H_
+
+#include <cppunit/TestAssert.h>
+
+// make it possible to specify location of the ASSERT call
+#define CPPUNIT_ASSERT_EQUAL_LOC(expected,actual,file,line) \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_NS::SourceLine(file,line),    \
+                              "" ) )
+
+#define CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC(message,expected,actual,file,line) \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_NS::SourceLine(file,line), \
+                              (message) ) )
+
+#endif /*CPPASSERTHELPER_H_*/
diff --git a/zookeeper/c/tests/LibCMocks.cc b/zookeeper/c/tests/LibCMocks.cc
new file mode 100644
index 000000000..2f518b776
--- /dev/null
+++ b/zookeeper/c/tests/LibCMocks.cc
@@ -0,0 +1,281 @@
+#include <cstdlib>
+#include <cstdarg>
+#include <iostream>
+#include <stdarg.h>
+
+#include "LibCMocks.h"
+#include "LibCSymTable.h"
+#include "Util.h"
+
+using namespace std;
+
+// *****************************************************************************
+// gethostbyname
+
+struct hostent* gethostbyname(const char *name) {
+    if(!Mock_gethostbyname::mock_)
+        return LIBC_SYMBOLS.gethostbyname(name);
+    return Mock_gethostbyname::mock_->call(name);
+}
+
+Mock_gethostbyname* Mock_gethostbyname::mock_=0;
+
+Mock_gethostbyname::~Mock_gethostbyname(){
+    mock_=0;
+    for(unsigned int i=0;i<gethostbynameReturns.size();i++)
+        delete gethostbynameReturns[i];
+}
+
+Mock_gethostbyname::HostEntry& Mock_gethostbyname::addHostEntry(
+        const char* hostName, short addrtype) {
+    gethostbynameReturns.push_back(new HostEntry(hostName, addrtype));
+    return *gethostbynameReturns.back();
+}
+
+hostent* Mock_gethostbyname::call(const char* name) {
+    assert("Must add one or more mock hostent entries first"&&
+            (gethostbynameReturns.size()!=0));
+    return gethostbynameReturns[current++ % gethostbynameReturns.size()];
+}
+
+static char** appendString(char **list,const char* str,int len=0){
+    const int SIZE_INCREMENT=16;
+    if(list==0)
+        list=(char**)LIBC_SYMBOLS.calloc(SIZE_INCREMENT,sizeof(char*));
+    // find the first available slot
+    int count=0;
+    for(char** ptr=list; *ptr!=0; ptr++,count++);
+    if(((count+1)%SIZE_INCREMENT)==0){
+        list=(char**)LIBC_SYMBOLS.realloc(list,(count+1+SIZE_INCREMENT)*sizeof(char*));
+        memset(list+count+1,0,SIZE_INCREMENT*sizeof(char*));
+    }
+    if(len==0){
+        len=strlen(str)+1;
+    }
+    char* ptr=(char*)malloc(len);
+    memcpy(ptr,str,len);
+    list[count]=ptr;
+    return list;
+}
+
+static void freeList(char **list){
+    if(list==0) return;
+    for(char** ptr=list; *ptr!=0; ptr++)
+        LIBC_SYMBOLS.free((void*)*ptr);
+    LIBC_SYMBOLS.free((void*)list);
+}
+
+Mock_gethostbyname::HostEntry::HostEntry(const char* hostName, short addrtype) {
+    h_name=strdup(hostName);
+    h_addrtype=addrtype;
+    if(addrtype==AF_INET)
+        h_length=4;
+    else{
+#ifdef AF_INET6
+        h_length=6; // TODO: not really sure, verify!
+#else
+        assert("AF_INET6 not supported yet"&&false);
+#endif
+    }
+    h_aliases=h_addr_list=0;
+}
+
+Mock_gethostbyname::HostEntry::~HostEntry(){
+    if(h_name) LIBC_SYMBOLS.free((void*)h_name);
+    freeList(h_aliases); h_aliases=0;
+    freeList(h_addr_list); h_addr_list=0;
+}
+
+Mock_gethostbyname::HostEntry& Mock_gethostbyname::HostEntry::addAlias(
+        const char* alias) {
+    h_aliases=appendString(h_aliases,alias);
+    return *this;
+}
+
+Mock_gethostbyname::HostEntry& Mock_gethostbyname::HostEntry::addAddress(
+        const char* addr4) {
+    h_addr_list=appendString(h_addr_list,addr4,4);
+    return *this;
+}
+
+
+// *****************************************************************************
+// calloc
+
+DECLARE_WRAPPER(void*,calloc,(size_t p1, size_t p2)){
+    if(!Mock_calloc::mock_)
+        return CALL_REAL(calloc,(p1,p2));
+    return Mock_calloc::mock_->call(p1,p2);
+}
+
+Mock_calloc* Mock_calloc::mock_=0;
+
+void* Mock_calloc::call(size_t p1, size_t p2){
+    if(counter++ ==callsBeforeFailure){
+        counter=0;
+        errno=errnoOnFailure;
+        return 0;
+    }
+    return CALL_REAL(calloc,(p1,p2));
+}
+
+// *****************************************************************************
+// realloc
+
+void* realloc(void* p, size_t s){
+    if(!Mock_realloc::mock_)
+        return LIBC_SYMBOLS.realloc(p,s);
+    return Mock_realloc::mock_->call(p,s);
+}
+
+Mock_realloc* Mock_realloc::mock_=0;
+
+void* Mock_realloc::call(void* p, size_t s){
+    if(counter++ ==callsBeforeFailure){
+        counter=0;
+        errno=errnoOnFailure;
+        return 0;
+    }
+    return LIBC_SYMBOLS.realloc(p,s);
+}
+
+// *****************************************************************************
+// random
+RANDOM_RET_TYPE random(){
+    if(!Mock_random::mock_)
+        return LIBC_SYMBOLS.random();
+    return Mock_random::mock_->call();    
+}
+
+void srandom(unsigned long seed){
+    if (!Mock_random::mock_)
+        LIBC_SYMBOLS.srandom(seed);
+    else
+        Mock_random::mock_->setSeed(seed);
+}
+
+Mock_random* Mock_random::mock_=0;
+
+int Mock_random::call(){
+    assert("Must specify one or more random integers"&&(randomReturns.size()!=0));
+    return randomReturns[currentIdx++ % randomReturns.size()];
+}
+
+// *****************************************************************************
+// free
+DECLARE_WRAPPER(void,free,(void* p)){
+    if(Mock_free_noop::mock_ && !Mock_free_noop::mock_->nested)
+        Mock_free_noop::mock_->call(p);
+    else
+        CALL_REAL(free,(p));
+}
+void Mock_free_noop::call(void* p){
+    // on cygwin libc++ is linked statically
+    // push_back() may call free(), hence the nesting guards
+    synchronized(mx);
+    nested++;
+    callCounter++;
+    requested.push_back(p);
+    nested--;
+}
+void Mock_free_noop::freeRequested(){
+    synchronized(mx);
+    for(unsigned i=0; i<requested.size();i++)
+        CALL_REAL(free,(requested[i]));
+}
+
+int Mock_free_noop::getFreeCount(void* p){
+    int cnt=0;
+    synchronized(mx);
+    for(unsigned i=0;i<requested.size();i++)
+        if(requested[i]==p)cnt++;
+    return cnt;
+}
+
+bool Mock_free_noop::isFreed(void* p){
+    synchronized(mx);
+    for(unsigned i=0;i<requested.size();i++)
+        if(requested[i]==p)return true;
+    return false;
+}
+
+Mock_free_noop* Mock_free_noop::mock_=0;
+
+// *****************************************************************************
+// socket
+int socket(int domain, int type, int protocol){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.socket(domain,type,protocol);
+    return Mock_socket::mock_->callSocket(domain,type,protocol);
+}
+
+int close(int fd){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.close(fd);
+    return Mock_socket::mock_->callClose(fd);
+}
+
+int getsockopt(int s,int level,int optname,void *optval,socklen_t *optlen){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.getsockopt(s,level,optname,optval,optlen);
+    return Mock_socket::mock_->callGet(s,level,optname,optval,optlen);    
+}
+
+int setsockopt(int s,int level,int optname,const void *optval,socklen_t optlen){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.setsockopt(s,level,optname,optval,optlen);
+    return Mock_socket::mock_->callSet(s,level,optname,optval,optlen);      
+}
+int connect(int s,const struct sockaddr *addr,socklen_t len){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.connect(s,addr,len);
+    return Mock_socket::mock_->callConnect(s,addr,len);
+}
+ssize_t send(int s,const void *buf,size_t len,int flags){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.send(s,buf,len,flags);
+    return Mock_socket::mock_->callSend(s,buf,len,flags);    
+}
+
+ssize_t recv(int s,void *buf,size_t len,int flags){
+    if (!Mock_socket::mock_)
+        return LIBC_SYMBOLS.recv(s,buf,len,flags);
+    return Mock_socket::mock_->callRecv(s,buf,len,flags);        
+}
+
+Mock_socket* Mock_socket::mock_=0;
+
+// *****************************************************************************
+// fcntl
+extern "C" int fcntl(int fd,int cmd,...){
+    va_list va;
+    va_start(va,cmd);
+    void* arg = va_arg(va, void *);
+    va_end (va);
+    if (!Mock_fcntl::mock_)
+        return LIBC_SYMBOLS.fcntl(fd,cmd,arg);
+    return Mock_fcntl::mock_->call(fd,cmd,arg);    
+}
+
+Mock_fcntl* Mock_fcntl::mock_=0;
+
+// *****************************************************************************
+// select
+int select(int nfds,fd_set *rfds,fd_set *wfds,fd_set *efds,struct timeval *timeout){
+    if (!Mock_select::mock_)
+        return LIBC_SYMBOLS.select(nfds,rfds,wfds,efds,timeout);
+    return Mock_select::mock_->call(nfds,rfds,wfds,efds,timeout);        
+}
+
+Mock_select* Mock_select::mock_=0;
+
+// *****************************************************************************
+// gettimeofday
+int gettimeofday(struct timeval *tp, GETTIMEOFDAY_ARG2_TYPE tzp){
+    if (!Mock_gettimeofday::mock_)
+        return LIBC_SYMBOLS.gettimeofday(tp,tzp);
+    return Mock_gettimeofday::mock_->call(tp,tzp);            
+}
+
+Mock_gettimeofday* Mock_gettimeofday::mock_=0;
+
diff --git a/zookeeper/c/tests/LibCMocks.h b/zookeeper/c/tests/LibCMocks.h
new file mode 100644
index 000000000..539768158
--- /dev/null
+++ b/zookeeper/c/tests/LibCMocks.h
@@ -0,0 +1,304 @@
+#ifndef LIBCMOCKS_H_
+#define LIBCMOCKS_H_
+
+#include <string>
+#include <vector>
+#include <deque>
+
+#include <errno.h>
+
+#include "MocksBase.h"
+#include "LibCSymTable.h"
+#include "Util.h"
+
+// *****************************************************************************
+// gethostbyname
+
+class Mock_gethostbyname: public Mock
+{
+public:
+    struct HostEntry: public hostent {
+        HostEntry(const char* hostName,short addrtype);
+        ~HostEntry();
+        HostEntry& addAlias(const char* alias);
+        HostEntry& addAddress(const char* addr4);
+    };
+
+    Mock_gethostbyname():current(0){mock_=this;}
+    virtual ~Mock_gethostbyname();
+    HostEntry& addHostEntry(const char* hostName,short addrtype=AF_INET);
+    virtual hostent* call(const char* name);
+
+    typedef std::vector<HostEntry*> HostEntryCollection;
+    HostEntryCollection gethostbynameReturns;
+    int current;
+    static Mock_gethostbyname* mock_;
+};
+
+class MockFailed_gethostbyname: public Mock_gethostbyname
+{
+public:
+    MockFailed_gethostbyname():h_errnoReturn(HOST_NOT_FOUND) {}
+
+    int h_errnoReturn;
+    virtual hostent* call(const char* name) {
+        h_errno=h_errnoReturn;
+        return 0;
+    }
+};
+
+// *****************************************************************************
+// calloc
+
+class Mock_calloc: public Mock
+{
+public:
+    Mock_calloc():errnoOnFailure(ENOMEM),callsBeforeFailure(-1),counter(0) {
+        mock_=this;
+    }
+    virtual ~Mock_calloc() {mock_=0;}
+
+    int errnoOnFailure;
+    int callsBeforeFailure;
+    int counter;
+    virtual void* call(size_t p1, size_t p2);
+
+    static Mock_calloc* mock_;
+};
+
+// *****************************************************************************
+// realloc
+
+class Mock_realloc: public Mock
+{
+public:
+    Mock_realloc():errnoOnFailure(ENOMEM),callsBeforeFailure(-1),counter(0) {
+        mock_=this;
+    }
+    virtual ~Mock_realloc() {mock_=0;}
+
+    int errnoOnFailure;
+    int callsBeforeFailure;
+    int counter;
+    virtual void* call(void* p, size_t s);
+
+    static Mock_realloc* mock_;
+};
+
+// *****************************************************************************
+// random
+
+class Mock_random: public Mock
+{
+public:
+    Mock_random():currentIdx(0) {mock_=this;}
+    virtual ~Mock_random() {mock_=0;}
+
+    int currentIdx;
+    std::vector<int> randomReturns;
+    virtual int call();
+    void setSeed(unsigned long){currentIdx=0;}
+
+    static Mock_random* mock_;
+};
+
+// *****************************************************************************
+// no-op free; keeps track of all deallocation requests
+class Mock_free_noop: public Mock
+{
+    Mutex mx;
+    std::vector<void*> requested;
+public:
+    Mock_free_noop():nested(0),callCounter(0){mock_=this;}
+    virtual ~Mock_free_noop(){
+        mock_=0;
+        freeRequested();
+    }
+    
+    int nested;
+    int callCounter;
+    virtual void call(void* p);
+    void freeRequested();
+    void disable(){mock_=0;}
+    // returns number of times the pointer was freed
+    int getFreeCount(void*);
+    bool isFreed(void*);
+    
+    static Mock_free_noop* mock_;
+};
+
+// *****************************************************************************
+// socket and related system calls
+
+class Mock_socket: public Mock
+{
+public:
+    static const int FD=63;
+    Mock_socket():socketReturns(FD),closeReturns(0),getsocketoptReturns(0),
+        optvalSO_ERROR(0),
+        setsockoptReturns(0),connectReturns(0),connectErrno(0),
+        sendErrno(0),recvErrno(0)
+    {
+        mock_=this;
+    }
+    virtual ~Mock_socket(){mock_=0;}
+
+    int socketReturns;
+    virtual int callSocket(int domain, int type, int protocol){
+        return socketReturns;
+    }
+    int closeReturns;
+    virtual int callClose(int fd){
+        return closeReturns;
+    }
+    int getsocketoptReturns;
+    int optvalSO_ERROR;
+    virtual int callGet(int s,int level,int optname,void *optval,socklen_t *len){
+        if(level==SOL_SOCKET && optname==SO_ERROR){
+            setSO_ERROR(optval,*len);
+        }
+        return getsocketoptReturns;
+    }
+    virtual void setSO_ERROR(void *optval,socklen_t len){
+        memcpy(optval,&optvalSO_ERROR,len);
+    }
+    
+    int setsockoptReturns;
+    virtual int callSet(int s,int level,int optname,const void *optval,socklen_t len){
+        return setsockoptReturns;
+    }
+    int connectReturns;
+    int connectErrno;
+    virtual int callConnect(int s,const struct sockaddr *addr,socklen_t len){
+        errno=connectErrno;
+        return connectReturns;
+    }
+    
+    virtual void notifyBufferSent(const std::string& buffer){}
+    
+    int sendErrno;
+    std::string sendBuffer;
+    virtual ssize_t callSend(int s,const void *buf,size_t len,int flags){
+        if(sendErrno!=0){
+            errno=sendErrno;
+            return -1;
+        }
+        // first call to send() is always the length of the buffer to follow
+        bool sendingLength=sendBuffer.size()==0;
+        // overwrite the length bytes
+        sendBuffer.assign((const char*)buf,len);
+        if(!sendingLength){
+            notifyBufferSent(sendBuffer);
+            sendBuffer.erase();
+        }
+        return len;
+    }
+
+    int recvErrno;
+    std::string recvReturnBuffer;
+    virtual ssize_t callRecv(int s,void *buf,size_t len,int flags){
+        if(recvErrno!=0){
+            errno=recvErrno;
+            return -1;
+        }
+        int k=std::min(len,recvReturnBuffer.length());
+        if(k==0)
+            return 0;
+        memcpy(buf,recvReturnBuffer.data(),k);
+        recvReturnBuffer.erase(0,k);
+        return k;
+    }
+    virtual bool hasMoreRecv() const{
+        return recvReturnBuffer.size()!=0;
+    }
+    static Mock_socket* mock_;
+};
+
+// *****************************************************************************
+// fcntl
+class Mock_fcntl: public Mock
+{
+public:
+    Mock_fcntl():callReturns(0),trapFD(-1){mock_=this;}
+    ~Mock_fcntl(){mock_=0;}
+    
+    int callReturns;
+    int trapFD;
+    virtual int call(int fd, int cmd, void* arg){
+        if(trapFD==-1)
+            return LIBC_SYMBOLS.fcntl(fd,cmd,arg);
+        return callReturns;
+    }
+
+    static Mock_fcntl* mock_;
+};
+
+// *****************************************************************************
+// select
+class Mock_select: public Mock
+{
+public:
+    Mock_select(Mock_socket* s,int fd):sock(s),
+        callReturns(0),myFD(fd),timeout(50)
+    {
+        mock_=this;
+    }
+    ~Mock_select(){mock_=0;}
+    
+    Mock_socket* sock;
+    int callReturns;
+    int myFD;
+    int timeout; //in millis
+    virtual int call(int nfds,fd_set *rfds,fd_set *wfds,fd_set *efds,struct timeval *tv){
+        bool isWritableRequested=(wfds && FD_ISSET(myFD,wfds));
+        if(rfds) FD_CLR(myFD,rfds);
+        if(wfds) FD_CLR(myFD,wfds);
+        // this timeout is only to prevent a tight loop
+        timeval myTimeout={0,0};
+        if(!isWritableRequested && !isFDReadable()){
+            myTimeout.tv_sec=timeout/1000;
+            myTimeout.tv_usec=(timeout%1000)*1000;
+        }
+        LIBC_SYMBOLS.select(nfds,rfds,wfds,efds,&myTimeout);
+        // myFD is always writable
+        if(isWritableRequested) FD_SET(myFD,wfds);
+        // myFD is only readable if the socket has anything to read
+        if(isFDReadable() && rfds) FD_SET(myFD,rfds);
+        return callReturns;
+    }
+
+    virtual bool isFDReadable() const {
+        return sock->hasMoreRecv();
+    }
+    
+    static Mock_select* mock_;
+};
+
+// *****************************************************************************
+// gettimeofday
+class Mock_gettimeofday: public Mock
+{
+public:
+    Mock_gettimeofday(){
+        LIBC_SYMBOLS.gettimeofday(&tv,0);
+        mock_=this;
+    }
+    ~Mock_gettimeofday(){mock_=0;}
+    
+    timeval tv;
+    virtual int call(struct timeval *tp, GETTIMEOFDAY_ARG2_TYPE tzp){
+        *tp=tv;
+        return 0;
+    }
+    // advance secs
+    virtual void tick(int howmuch=1){tv.tv_sec+=howmuch;}
+    // advance milliseconds
+    virtual void millitick(int howmuch=1){
+        int ms=tv.tv_usec/1000+howmuch;
+        tv.tv_sec+=ms/1000;
+        tv.tv_usec=ms%1000;
+    }
+    static Mock_gettimeofday* mock_;
+};
+
+#endif /*LIBCMOCKS_H_*/
diff --git a/zookeeper/c/tests/LibCSymTable.cc b/zookeeper/c/tests/LibCSymTable.cc
new file mode 100644
index 000000000..2d7863f80
--- /dev/null
+++ b/zookeeper/c/tests/LibCSymTable.cc
@@ -0,0 +1,64 @@
+#include "LibCSymTable.h" 
+
+#define LOAD_SYM(sym) \
+    sym=(sym##_sig)dlsym(handle,#sym); \
+    assert("Unable to load "#sym" from libc"&&sym)      
+    
+
+LibCSymTable& LibCSymTable::instance(){
+    static LibCSymTable tbl;
+    return tbl;
+}
+
+//******************************************************************************
+// preload original libc symbols
+LibCSymTable::LibCSymTable()
+{
+    void* handle=getHandle();
+    LOAD_SYM(gethostbyname);
+    LOAD_SYM(calloc);
+    LOAD_SYM(realloc);
+    LOAD_SYM(free);
+    LOAD_SYM(random);
+    LOAD_SYM(srandom);
+    LOAD_SYM(printf);
+    LOAD_SYM(socket);
+    LOAD_SYM(close);
+    LOAD_SYM(getsockopt);
+    LOAD_SYM(setsockopt);
+    LOAD_SYM(fcntl);
+    LOAD_SYM(connect);
+    LOAD_SYM(send);
+    LOAD_SYM(recv);
+    LOAD_SYM(select);
+    LOAD_SYM(gettimeofday);
+#ifdef THREADED
+    LOAD_SYM(pthread_create);
+    LOAD_SYM(pthread_detach);
+    LOAD_SYM(pthread_cond_broadcast);
+    LOAD_SYM(pthread_cond_destroy);
+    LOAD_SYM(pthread_cond_init);
+    LOAD_SYM(pthread_cond_signal);
+    LOAD_SYM(pthread_cond_timedwait);
+    LOAD_SYM(pthread_cond_wait);
+    LOAD_SYM(pthread_join);
+    LOAD_SYM(pthread_mutex_destroy);
+    LOAD_SYM(pthread_mutex_init);
+    LOAD_SYM(pthread_mutex_lock);
+    LOAD_SYM(pthread_mutex_trylock);
+    LOAD_SYM(pthread_mutex_unlock);
+#endif
+}
+
+void* LibCSymTable::getHandle(){
+    static void* handle=0;
+    if(!handle){
+#ifdef __CYGWIN__
+        handle=dlopen("cygwin1.dll",RTLD_LAZY);
+        assert("Unable to dlopen global sym table"&&handle);
+#else
+        handle=RTLD_NEXT;
+#endif
+    }
+    return handle;
+}
diff --git a/zookeeper/c/tests/LibCSymTable.h b/zookeeper/c/tests/LibCSymTable.h
new file mode 100644
index 000000000..8d176ed35
--- /dev/null
+++ b/zookeeper/c/tests/LibCSymTable.h
@@ -0,0 +1,80 @@
+#ifndef LIBCSYMTABLE_H_
+#define LIBCSYMTABLE_H_
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <stddef.h>
+#include <dlfcn.h>
+#include <cassert>
+
+#ifdef THREADED
+#include <pthread.h>
+#endif
+
+#ifdef __CYGWIN__
+#define RANDOM_RET_TYPE int
+#define GETTIMEOFDAY_ARG2_TYPE void*
+#else
+#define RANDOM_RET_TYPE long int
+#define GETTIMEOFDAY_ARG2_TYPE struct timezone*
+#endif
+
+#define DECLARE_SYM(ret,sym,sig) \
+    typedef ret (*sym##_sig)sig; \
+    static sym##_sig preload_##sym () { \
+        static sym##_sig ptr=0;\
+        if(!ptr){ void* h=getHandle(); ptr=(sym##_sig)dlsym(h,#sym); } \
+        assert("Unable to load "#sym" from libc"&&ptr); \
+        return ptr; \
+    } \
+    sym##_sig sym
+
+#define LIBC_SYMBOLS LibCSymTable::instance()
+
+//******************************************************************************
+// preload original libc symbols
+struct LibCSymTable
+{
+    DECLARE_SYM(hostent*,gethostbyname,(const char*));
+    DECLARE_SYM(void*,calloc,(size_t, size_t));
+    DECLARE_SYM(void*,realloc,(void*, size_t));
+    DECLARE_SYM(void,free,(void*));
+    DECLARE_SYM(RANDOM_RET_TYPE,random,(void));
+    DECLARE_SYM(void,srandom,(unsigned long));
+    DECLARE_SYM(int,printf,(const char*, ...));
+    DECLARE_SYM(int,socket,(int,int,int));
+    DECLARE_SYM(int,close,(int));
+    DECLARE_SYM(int,getsockopt,(int,int,int,void*,socklen_t*));
+    DECLARE_SYM(int,setsockopt,(int,int,int,const void*,socklen_t));
+    DECLARE_SYM(int,fcntl,(int,int,...));
+    DECLARE_SYM(int,connect,(int,const struct sockaddr*,socklen_t));
+    DECLARE_SYM(ssize_t,send,(int,const void*,size_t,int));
+    DECLARE_SYM(ssize_t,recv,(int,const void*,size_t,int));
+    DECLARE_SYM(int,select,(int,fd_set*,fd_set*,fd_set*,struct timeval*));
+    DECLARE_SYM(int,gettimeofday,(struct timeval*,GETTIMEOFDAY_ARG2_TYPE));
+#ifdef THREADED
+    DECLARE_SYM(int,pthread_create,(pthread_t *, const pthread_attr_t *,
+                void *(*)(void *), void *));
+    DECLARE_SYM(int,pthread_detach,(pthread_t));
+    DECLARE_SYM(int,pthread_cond_broadcast,(pthread_cond_t *));
+    DECLARE_SYM(int,pthread_cond_destroy,(pthread_cond_t *));
+    DECLARE_SYM(int,pthread_cond_init,(pthread_cond_t *, const pthread_condattr_t *));
+    DECLARE_SYM(int,pthread_cond_signal,(pthread_cond_t *));
+    DECLARE_SYM(int,pthread_cond_timedwait,(pthread_cond_t *,
+                    pthread_mutex_t *, const struct timespec *));
+    DECLARE_SYM(int,pthread_cond_wait,(pthread_cond_t *, pthread_mutex_t *));
+    DECLARE_SYM(int,pthread_join,(pthread_t, void **));
+    DECLARE_SYM(int,pthread_mutex_destroy,(pthread_mutex_t *));
+    DECLARE_SYM(int,pthread_mutex_init,(pthread_mutex_t *, const pthread_mutexattr_t *));
+    DECLARE_SYM(int,pthread_mutex_lock,(pthread_mutex_t *));
+    DECLARE_SYM(int,pthread_mutex_trylock,(pthread_mutex_t *));
+    DECLARE_SYM(int,pthread_mutex_unlock,(pthread_mutex_t *));
+#endif
+    LibCSymTable();
+    
+    static void* getHandle();
+    static LibCSymTable& instance();
+};
+
+#endif /*LIBCSYMTABLE_H_*/
diff --git a/zookeeper/c/tests/MocksBase.cc b/zookeeper/c/tests/MocksBase.cc
new file mode 100644
index 000000000..c33420a53
--- /dev/null
+++ b/zookeeper/c/tests/MocksBase.cc
@@ -0,0 +1,18 @@
+#include <cstdlib>
+#include <new>
+
+#include "MocksBase.h"
+#include "LibCSymTable.h"
+
+// *****************************************************************************
+// Mock base
+void* Mock::operator new(std::size_t s){
+    void* p=malloc(s);
+    if(!p)
+        throw std::bad_alloc();
+    return p;
+}
+
+void Mock::operator delete(void* p){
+    LIBC_SYMBOLS.free(p);
+}
diff --git a/zookeeper/c/tests/MocksBase.h b/zookeeper/c/tests/MocksBase.h
new file mode 100644
index 000000000..cfa1121f6
--- /dev/null
+++ b/zookeeper/c/tests/MocksBase.h
@@ -0,0 +1,18 @@
+#ifndef MOCKSBASE_H_
+#define MOCKSBASE_H_
+
+#include <cstddef>
+
+// *****************************************************************************
+// Mock base
+
+class Mock
+{
+public:
+    virtual ~Mock(){}
+
+    static void* operator new(std::size_t s);
+    static void operator delete(void* p);
+};
+
+#endif /*MOCKSBASE_H_*/
diff --git a/zookeeper/c/tests/PthreadMocks.cc b/zookeeper/c/tests/PthreadMocks.cc
new file mode 100644
index 000000000..a6c0c741a
--- /dev/null
+++ b/zookeeper/c/tests/PthreadMocks.cc
@@ -0,0 +1,86 @@
+#include "PthreadMocks.h"
+#include "LibCSymTable.h"
+#include "Util.h"
+
+MockPthreadsBase* MockPthreadsBase::mock_=0;
+
+int pthread_cond_broadcast (pthread_cond_t *c){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_broadcast(c);
+    return MockPthreadsBase::mock_->pthread_cond_broadcast(c);
+}
+int pthread_cond_destroy (pthread_cond_t *c){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_destroy(c);
+    return MockPthreadsBase::mock_->pthread_cond_destroy(c);
+}
+int pthread_cond_init (pthread_cond_t *c, const pthread_condattr_t *a){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_init(c,a);
+    return MockPthreadsBase::mock_->pthread_cond_init(c,a);
+}
+int pthread_cond_signal (pthread_cond_t *c){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_signal(c);
+    return MockPthreadsBase::mock_->pthread_cond_signal(c);
+}
+int pthread_cond_timedwait (pthread_cond_t *c,
+                pthread_mutex_t *m, const struct timespec *t){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_timedwait(c,m,t);
+    return MockPthreadsBase::mock_->pthread_cond_timedwait(c,m,t);
+}
+int pthread_cond_wait (pthread_cond_t *c, pthread_mutex_t *m){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_cond_wait(c,m);
+    return MockPthreadsBase::mock_->pthread_cond_wait(c,m);
+}
+int pthread_create (pthread_t *t, const pthread_attr_t *a,
+            void *(*f)(void *), void *d){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_create(t,a,f,d);
+    return MockPthreadsBase::mock_->pthread_create(t,a,f,d);
+}
+int pthread_detach(pthread_t t){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_detach(t);
+    return MockPthreadsBase::mock_->pthread_detach(t);    
+}
+int pthread_join (pthread_t t, void **r){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_join(t,r);
+    return MockPthreadsBase::mock_->pthread_join(t,r);
+}
+int pthread_mutex_destroy (pthread_mutex_t *m){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_mutex_destroy(m);
+    return MockPthreadsBase::mock_->pthread_mutex_destroy(m);
+}
+int pthread_mutex_init (pthread_mutex_t *m, const pthread_mutexattr_t *a){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_mutex_init(m,a);
+    return MockPthreadsBase::mock_->pthread_mutex_init(m,a);
+}
+
+DECLARE_WRAPPER(int,pthread_mutex_lock,(pthread_mutex_t *m)){
+    if(!MockPthreadsBase::mock_)
+        return CALL_REAL(pthread_mutex_lock,(m));
+    return MockPthreadsBase::mock_->pthread_mutex_lock(m);
+}
+
+int pthread_mutex_trylock (pthread_mutex_t *m){
+    if(!MockPthreadsBase::mock_)
+        return LIBC_SYMBOLS.pthread_mutex_trylock(m);
+    return MockPthreadsBase::mock_->pthread_mutex_trylock(m);
+}
+
+DECLARE_WRAPPER(int,pthread_mutex_unlock,(pthread_mutex_t *m)){
+    if(!MockPthreadsBase::mock_)
+        return CALL_REAL(pthread_mutex_unlock,(m));
+    return MockPthreadsBase::mock_->pthread_mutex_unlock(m);
+}
+
+CheckedPthread::ThreadMap CheckedPthread::tmap_;
+CheckedPthread::MutexMap CheckedPthread::mmap_;
+CheckedPthread::CVMap CheckedPthread::cvmap_;
+Mutex CheckedPthread::mx;
diff --git a/zookeeper/c/tests/PthreadMocks.h b/zookeeper/c/tests/PthreadMocks.h
new file mode 100644
index 000000000..6c22429de
--- /dev/null
+++ b/zookeeper/c/tests/PthreadMocks.h
@@ -0,0 +1,381 @@
+#ifndef PTHREADMOCKS_H_
+#define PTHREADMOCKS_H_
+
+#include <pthread.h>
+#include <string.h>
+#include <errno.h>
+
+#include "src/zk_adaptor.h"
+#include "src/zk_log.h"
+
+#include "Util.h"
+#include "MocksBase.h"
+#include "LibCSymTable.h"
+
+// an ABC for pthreads
+class MockPthreadsBase: public Mock
+{
+public:
+    MockPthreadsBase(){mock_=this;}
+    virtual ~MockPthreadsBase(){mock_=0;}
+    
+    virtual int pthread_create(pthread_t * t, const pthread_attr_t *a,
+            void *(*f)(void *), void *d) =0;
+    virtual int pthread_join(pthread_t t, void ** r) =0;
+    virtual int pthread_detach(pthread_t t) =0;
+    virtual int pthread_cond_broadcast(pthread_cond_t *c) =0;
+    virtual int pthread_cond_destroy(pthread_cond_t *c) =0;
+    virtual int pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *a) =0;
+    virtual int pthread_cond_signal(pthread_cond_t *c) =0;
+    virtual int pthread_cond_timedwait(pthread_cond_t *c,
+            pthread_mutex_t *m, const struct timespec *t) =0;
+    virtual int pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m) =0;
+    virtual int pthread_mutex_destroy(pthread_mutex_t *m) =0;
+    virtual int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a) =0;
+    virtual int pthread_mutex_lock(pthread_mutex_t *m) =0;
+    virtual int pthread_mutex_trylock(pthread_mutex_t *m) =0;
+    virtual int pthread_mutex_unlock(pthread_mutex_t *m) =0;
+    
+    static MockPthreadsBase* mock_;
+};
+
+// all pthread functions simply return an error code
+// and increment their invocation counter. No actual threads are spawned.
+class MockPthreadsNull: public MockPthreadsBase
+{
+public:
+    MockPthreadsNull():
+    pthread_createReturns(0),pthread_createCounter(0),
+    pthread_joinReturns(0),pthread_joinCounter(0),pthread_joinResultReturn(0),
+    pthread_detachReturns(0),pthread_detachCounter(0),
+    pthread_cond_broadcastReturns(0),pthread_cond_broadcastCounter(0),
+    pthread_cond_destroyReturns(0),pthread_cond_destroyCounter(0),
+    pthread_cond_initReturns(0),pthread_cond_initCounter(0),
+    pthread_cond_signalReturns(0),pthread_cond_signalCounter(0),
+    pthread_cond_timedwaitReturns(0),pthread_cond_timedwaitCounter(0),
+    pthread_cond_waitReturns(0),pthread_cond_waitCounter(0),
+    pthread_mutex_destroyReturns(0),pthread_mutex_destroyCounter(0),
+    pthread_mutex_initReturns(0),pthread_mutex_initCounter(0),
+    pthread_mutex_lockReturns(0),pthread_mutex_lockCounter(0),
+    pthread_mutex_trylockReturns(0),pthread_mutex_trylockCounter(0),
+    pthread_mutex_unlockReturns(0),pthread_mutex_unlockCounter(0)
+    {
+        memset(threads,0,sizeof(threads));
+    }
+    
+    short threads[512];
+    
+    int pthread_createReturns;
+    int pthread_createCounter;
+    virtual int pthread_create(pthread_t * t, const pthread_attr_t *a,
+            void *(*f)(void *), void *d){
+        char* p=(char*)&threads[pthread_createCounter++];
+        p[0]='i'; // mark as created
+        *t=(pthread_t)p;
+        return pthread_createReturns; 
+    }
+    int pthread_joinReturns;
+    int pthread_joinCounter;
+    void* pthread_joinResultReturn;
+    virtual int pthread_join(pthread_t t, void ** r){
+        pthread_joinCounter++;
+        if(r!=0)
+            *r=pthread_joinResultReturn;
+        char* p=(char*)t;
+        p[0]='x';p[1]+=1;
+        return pthread_joinReturns; 
+    }
+    int pthread_detachReturns;
+    int pthread_detachCounter;        
+    virtual int pthread_detach(pthread_t t){
+        pthread_detachCounter++;
+        char* p=(char*)t;
+        p[0]='x';p[1]+=1;        
+        return pthread_detachReturns;
+    }
+
+    template<class T>
+    static bool isInitialized(const T& t){
+        return ((char*)t)[0]=='i';
+    }
+    template<class T>
+    static bool isDestroyed(const T& t){
+        return ((char*)t)[0]=='x';
+    }
+    template<class T>
+    static int getDestroyCounter(const T& t){
+        return ((char*)t)[1];
+    }
+    template<class T>
+    static int getInvalidAccessCounter(const T& t){
+        return ((char*)t)[2];
+    }
+    int pthread_cond_broadcastReturns;
+    int pthread_cond_broadcastCounter;
+    virtual int pthread_cond_broadcast(pthread_cond_t *c){
+        pthread_cond_broadcastCounter++;
+        if(isDestroyed(c))((char*)c)[2]++;
+        return pthread_cond_broadcastReturns; 
+    }
+    int pthread_cond_destroyReturns;
+    int pthread_cond_destroyCounter;
+    virtual int pthread_cond_destroy(pthread_cond_t *c){
+        pthread_cond_destroyCounter++;
+        char* p=(char*)c;
+        p[0]='x';p[1]+=1;
+        return pthread_cond_destroyReturns; 
+    }
+    int pthread_cond_initReturns;
+    int pthread_cond_initCounter;
+    virtual int pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *a){
+        pthread_cond_initCounter++;
+        char* p=(char*)c;
+        p[0]='i'; // mark as created
+        p[1]=0;   // destruction counter
+        p[2]=0;   // access after destruction counter
+        return pthread_cond_initReturns; 
+    }
+    int pthread_cond_signalReturns;
+    int pthread_cond_signalCounter;
+    virtual int pthread_cond_signal(pthread_cond_t *c){
+        pthread_cond_signalCounter++;
+        if(isDestroyed(c))((char*)c)[2]++;
+        return pthread_cond_signalReturns; 
+    }
+    int pthread_cond_timedwaitReturns;
+    int pthread_cond_timedwaitCounter;
+    virtual int pthread_cond_timedwait(pthread_cond_t *c,
+            pthread_mutex_t *m, const struct timespec *t){
+        pthread_cond_timedwaitCounter++;
+        if(isDestroyed(c))((char*)c)[2]++;
+        return pthread_cond_timedwaitReturns; 
+    }
+    int pthread_cond_waitReturns;
+    int pthread_cond_waitCounter;
+    virtual int pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m){
+        pthread_cond_waitCounter++;
+        if(isDestroyed(c))((char*)c)[2]++;
+        return pthread_cond_waitReturns; 
+    }
+    int pthread_mutex_destroyReturns;
+    int pthread_mutex_destroyCounter;
+    virtual int pthread_mutex_destroy(pthread_mutex_t *m){
+        pthread_mutex_destroyCounter++;
+        char* p=(char*)m;
+        p[0]='x';p[1]+=1;
+        return pthread_mutex_destroyReturns; 
+    }
+    int pthread_mutex_initReturns;
+    int pthread_mutex_initCounter;
+    virtual int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a){
+        pthread_mutex_initCounter++;
+        char* p=(char*)m;
+        p[0]='i'; // mark as created
+        p[1]=0;   // destruction counter
+        p[2]=0;   // access after destruction counter
+        return pthread_mutex_initReturns; 
+    }
+    int pthread_mutex_lockReturns;
+    int pthread_mutex_lockCounter;
+    virtual int pthread_mutex_lock(pthread_mutex_t *m){
+        pthread_mutex_lockCounter++;
+        if(isDestroyed(m))((char*)m)[2]++;
+        return pthread_mutex_lockReturns; 
+    }
+    int pthread_mutex_trylockReturns;
+    int pthread_mutex_trylockCounter;
+    virtual int pthread_mutex_trylock(pthread_mutex_t *m){
+        pthread_mutex_trylockCounter++;
+        if(isDestroyed(m))((char*)m)[2]++;
+        return pthread_mutex_trylockReturns; 
+    }
+    int pthread_mutex_unlockReturns;
+    int pthread_mutex_unlockCounter;
+    virtual int pthread_mutex_unlock(pthread_mutex_t *m){
+        pthread_mutex_unlockCounter++;
+        if(isDestroyed(m))((char*)m)[2]++;
+        return pthread_mutex_unlockReturns; 
+    }
+};
+
+// simulates the way zookeeper threads make use of api_prolog/epilog and
+// 
+class MockPthreadZKNull: public MockPthreadsNull
+{
+    typedef std::map<pthread_t,zhandle_t*> Map;
+    Map map_;
+public:
+    virtual int pthread_create(pthread_t * t, const pthread_attr_t *a,
+            void *(*f)(void *), void *d){
+        int ret=MockPthreadsNull::pthread_create(t,a,f,d);
+        zhandle_t* zh=(zhandle_t*)d;
+        adaptor_threads* ad=(adaptor_threads*)zh->adaptor_priv;
+        api_prolog(zh);
+        ad->threadsToWait--;
+        putValue(map_,*t,zh);
+        return ret;
+    }
+    virtual int pthread_join(pthread_t t, void ** r){
+        zhandle_t* zh=0;
+        if(getValue(map_,t,zh))
+            api_epilog(zh,0);
+        return MockPthreadsNull::pthread_join(t,r);
+    }
+};
+
+class CheckedPthread: public MockPthreadsBase
+{
+    // first => destruction counter
+    // second => invalid access counter
+    typedef std::pair<int,int> Entry;
+    typedef std::map<pthread_t,Entry> ThreadMap;
+    static ThreadMap tmap_;
+    static ThreadMap& getMap(const TypeOp<pthread_t>::BareT&){return tmap_;}
+    typedef std::map<pthread_mutex_t*,Entry> MutexMap;
+    static MutexMap mmap_;
+    static MutexMap& getMap(const TypeOp<pthread_mutex_t>::BareT&){return mmap_;}
+    typedef std::map<pthread_cond_t*,Entry> CVMap;
+    static CVMap cvmap_;
+    static CVMap& getMap(const TypeOp<pthread_cond_t>::BareT&){return cvmap_;}
+    
+    static Mutex mx;
+    
+    template<class T>
+    static void markDestroyed(T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        if(getValue(getMap(Type()),t,e)){
+            putValue(getMap(Type()),t,Entry(e.first+1,e.second));
+        }else{
+            putValue(getMap(Type()),t,Entry(1,0));
+        }
+    }
+    template<class T>
+    static void markCreated(T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        if(!getValue(getMap(Type()),t,e))
+            putValue(getMap(Type()),t,Entry(0,0));
+    }
+    template<class T>
+    static void checkAccessed(T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        if(getValue(getMap(Type()),t,e) && e.first>0)
+            putValue(getMap(Type()),t,Entry(e.first,e.second+1));
+    }
+
+public:
+    bool verbose;
+    CheckedPthread():verbose(false){
+        tmap_.clear();
+        mmap_.clear();
+        cvmap_.clear();
+        mx.release();
+    }
+    template <class T>
+    static bool isInitialized(const T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        return getValue(getMap(Type()),t,e) && e.first==0;
+    }
+    template <class T>
+    static bool isDestroyed(const T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        return getValue(getMap(Type()),t,e) && e.first>0;
+    }
+    template <class T>
+    static int getDestroyCounter(const T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        return getValue(getMap(Type()),t,e)?e.first:-1;
+    }
+    template<class T>
+    static int getInvalidAccessCounter(const T& t){
+        typedef typename TypeOp<T>::BareT Type;
+        Entry e;
+        synchronized(mx);
+        return getValue(getMap(Type()),t,e)?e.second:-1;
+    }
+
+    virtual int pthread_create(pthread_t * t, const pthread_attr_t *a,
+            void *(*f)(void *), void *d){
+        int ret=LIBC_SYMBOLS.pthread_create(t,a,f,d);
+        if(ret==0)
+            markCreated(*t);
+        if(verbose){
+            log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,
+                    format_log_message("thread created %p",*t));
+        }
+        return ret;
+    }
+    virtual int pthread_join(pthread_t t, void ** r){
+        if(verbose) TEST_TRACE(("thread joined %p",t));
+        int ret=LIBC_SYMBOLS.pthread_join(t,r);
+        if(ret==0)
+            markDestroyed(t);
+        return ret;
+    }
+    virtual int pthread_detach(pthread_t t){
+        if(verbose) TEST_TRACE(("thread detached %p",t));
+        int ret=LIBC_SYMBOLS.pthread_detach(t);
+        if(ret==0)
+            markDestroyed(t);
+        return ret;
+    }
+    virtual int pthread_cond_broadcast(pthread_cond_t *c){
+        checkAccessed(c);
+        return LIBC_SYMBOLS.pthread_cond_broadcast(c);
+    }
+    virtual int pthread_cond_destroy(pthread_cond_t *c){
+        markDestroyed(c);
+        return LIBC_SYMBOLS.pthread_cond_destroy(c);
+    }
+    virtual int pthread_cond_init(pthread_cond_t *c, const pthread_condattr_t *a){
+        markCreated(c);
+        return LIBC_SYMBOLS.pthread_cond_init(c,a);
+    }
+    virtual int pthread_cond_signal(pthread_cond_t *c){
+        checkAccessed(c);
+        return LIBC_SYMBOLS.pthread_cond_signal(c);
+    }
+    virtual int pthread_cond_timedwait(pthread_cond_t *c,
+            pthread_mutex_t *m, const struct timespec *t){
+        checkAccessed(c);
+        return LIBC_SYMBOLS.pthread_cond_timedwait(c,m,t);
+    }
+    virtual int pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m){
+        checkAccessed(c);
+        return LIBC_SYMBOLS.pthread_cond_wait(c,m);
+    }
+    virtual int pthread_mutex_destroy(pthread_mutex_t *m){
+        markDestroyed(m);
+        return LIBC_SYMBOLS.pthread_mutex_destroy(m);
+    }
+    virtual int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a){
+        markCreated(m);
+        return LIBC_SYMBOLS.pthread_mutex_init(m,a);
+    }
+    virtual int pthread_mutex_lock(pthread_mutex_t *m){
+        checkAccessed(m);
+        return LIBC_SYMBOLS.pthread_mutex_lock(m);
+    }
+    virtual int pthread_mutex_trylock(pthread_mutex_t *m){
+        checkAccessed(m);
+        return LIBC_SYMBOLS.pthread_mutex_trylock(m);
+    }
+    virtual int pthread_mutex_unlock(pthread_mutex_t *m){
+        checkAccessed(m);
+        return LIBC_SYMBOLS.pthread_mutex_unlock(m);
+    }    
+};
+
+#endif /*PTHREADMOCKS_H_*/
+
diff --git a/zookeeper/c/tests/TestDriver.cc b/zookeeper/c/tests/TestDriver.cc
new file mode 100644
index 000000000..796b7d3cb
--- /dev/null
+++ b/zookeeper/c/tests/TestDriver.cc
@@ -0,0 +1,93 @@
+#include <string>
+#include <cppunit/TestRunner.h>
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <stdexcept>
+#include <cppunit/Exception.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/XmlOutputter.h>
+#include <fstream>
+
+using namespace std;
+
+CPPUNIT_NS_BEGIN
+
+class EclipseOutputter: public CompilerOutputter
+{
+public:
+  EclipseOutputter(TestResultCollector *result,ostream &stream):
+        CompilerOutputter(result,stream,"%p:%l: "),stream_(stream)
+    {
+    }
+    virtual void printFailedTestName( TestFailure *failure ){}
+    virtual void printFailureMessage( TestFailure *failure )
+    {
+      stream_<<": ";
+      Message msg = failure->thrownException()->message();
+      stream_<< msg.shortDescription();
+
+      string text;
+      for(int i=0; i<msg.detailCount();i++){
+          text+=msg.detailAt(i);
+          if(i+1!=msg.detailCount())
+              text+=", ";
+      }
+      if(text.length()!=0)
+          stream_ <<" ["<<text<<"]";
+      stream_<<"\n";
+    }
+    ostream& stream_;
+};
+
+CPPUNIT_NS_END
+
+int main( int argc, char* argv[] ) { 
+   // if command line contains "-ide" then this is the post build check
+   // => the output must be in the compiler error format.
+   //bool selfTest = (argc > 1) && (std::string("-ide") == argv[1]);
+   std::string testPath = (argc > 1) ? std::string(argv[1]) : std::string("");
+
+   // Create the event manager and test controller
+   CPPUNIT_NS::TestResult controller;
+   // Add a listener that colllects test result
+   CPPUNIT_NS::TestResultCollector result;
+   controller.addListener( &result );
+   
+   // Add a listener that print dots as test run.
+//   CPPUNIT_NS::TextTestProgressListener progress;
+   CPPUNIT_NS::BriefTestProgressListener progress;
+   controller.addListener( &progress );
+ 
+   CPPUNIT_NS::TestRunner runner;
+   runner.addTest( CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest() );
+ 
+   try
+   {
+     cout << "Running "  <<  testPath;
+     runner.run( controller, testPath );
+
+     cout<<endl;
+
+     // Print test in a compiler compatible format.
+     CPPUNIT_NS::EclipseOutputter outputter( &result,cout);
+     outputter.write(); 
+
+ // Uncomment this for XML output
+     std::ofstream file( "tests.xml" );
+     CPPUNIT_NS::XmlOutputter xml( &result, file );
+     xml.setStyleSheet( "report.xsl" );
+     xml.write();
+     file.close();
+   }
+   catch ( std::invalid_argument &e )  // Test path not resolved
+   {
+     cout<<"\nERROR: "<<e.what()<<endl;
+     return 0;
+   }
+
+   return result.wasSuccessful() ? 0 : 1;
+ }
diff --git a/zookeeper/c/tests/TestOperations.cc b/zookeeper/c/tests/TestOperations.cc
new file mode 100644
index 000000000..d30605fbd
--- /dev/null
+++ b/zookeeper/c/tests/TestOperations.cc
@@ -0,0 +1,273 @@
+#include <cppunit/extensions/HelperMacros.h>
+
+#include <zookeeper.h>
+#include "src/zk_adaptor.h"
+
+#include "LibCMocks.h"
+#include "ZKMocks.h"
+#include "CppAssertHelper.h"
+#ifdef THREADED
+#include "PthreadMocks.h"
+#endif
+
+using namespace std;
+
+class Zookeeper_operations : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE(Zookeeper_operations);
+    CPPUNIT_TEST(testConcurrentOperations1);
+    //CPPUNIT_TEST(testOperationsAndCloseConcurrently1);
+    CPPUNIT_TEST_SUITE_END();
+    zhandle_t *zh;
+
+    static void watcher(zhandle_t *, int, int, const char *){}
+public: 
+    void setUp()
+    {
+        zoo_set_debug_level((ZooLogLevel)0); // disable logging
+        zoo_deterministic_conn_order(0);
+        zh=0;
+    }
+    
+    void tearDown()
+    {
+        zookeeper_close(zh);
+    }
+
+#ifndef THREADED
+    void testConcurrentOperations1()
+    {
+        
+    }
+    void testOperationsAndCloseConcurrently1()
+    {
+        
+    }
+#else
+    class Latch{
+    public:
+        virtual ~Latch(){}
+        virtual void await() =0;
+        virtual void signalAndWait() =0;
+        virtual void signal() =0;
+    };
+    
+    class CountDownLatch: public Latch{
+    public:
+        CountDownLatch(int count):count_(count){
+            pthread_cond_init(&cond_,0);
+            pthread_mutex_init(&mut_,0);            
+        }
+        virtual ~CountDownLatch(){
+            pthread_mutex_lock(&mut_);
+            if(count_!=0){
+                count_=0;
+                pthread_cond_broadcast(&cond_);                
+            }
+            pthread_mutex_unlock(&mut_);            
+            
+            pthread_cond_destroy(&cond_);
+            pthread_mutex_destroy(&mut_);            
+        }
+
+        virtual void await(){
+            pthread_mutex_lock(&mut_);
+            awaitImpl();
+            pthread_mutex_unlock(&mut_);                
+        }
+        virtual void signalAndWait(){
+            pthread_mutex_lock(&mut_);
+            signalImpl();
+            awaitImpl();
+            pthread_mutex_unlock(&mut_);                            
+        }
+        virtual void signal(){
+            pthread_mutex_lock(&mut_);
+            signalImpl();
+            pthread_mutex_unlock(&mut_);            
+        }
+    private:
+        void awaitImpl(){
+            while(count_!=0) 
+                pthread_cond_wait(&cond_,&mut_);            
+        }
+        void signalImpl(){
+            if(count_>0){
+                count_--;
+                pthread_cond_broadcast(&cond_);                
+            }
+        }
+        int count_;
+        pthread_mutex_t mut_;
+        pthread_cond_t cond_;
+    };
+    class TestJob{
+    public:
+        typedef long JobId;
+        TestJob():startLatch_(0),endLatch_(0){}
+        virtual ~TestJob(){}
+        
+        virtual void run() =0;
+        virtual void validate(const char* file, int line) const =0;
+        
+        virtual void start(Latch* startLatch=0,Latch* endLatch=0) {
+            startLatch_=startLatch;endLatch_=endLatch;
+            pthread_create(&thread_, 0, thread, this);
+        }
+        virtual JobId getJobId() const {
+            return (JobId)thread_;
+        }
+    private:
+        void awaitStart(){
+            if(startLatch_==0) return;
+            startLatch_->signalAndWait();
+        }
+        void signalFinished(){
+            if(endLatch_==0) return;
+            endLatch_->signal();
+        }
+        static void* thread(void* p){
+            TestJob* j=(TestJob*)p;
+            j->awaitStart();  // wait for the start command
+            j->run();
+            j->signalFinished();
+            pthread_detach(j->thread_);
+            return 0;
+        }
+        Latch* startLatch_;
+        Latch* endLatch_;
+        pthread_t thread_;
+    };
+#define VALIDATE_JOB(j) j.validate(__FILE__,__LINE__)
+    
+    class TestGetJob: public TestJob{
+    public:
+        static const int REPS=3000;
+        TestGetJob(ZookeeperServer* svr,zhandle_t* zh)
+            :svr_(svr),zh_(zh),rc_(ZAPIERROR){}
+        virtual void run(){
+            int i;
+            for(i=0;i<REPS;i++){
+                char buf;
+                int size=sizeof(buf);
+                svr_->addSendResponse(new ZooGetResponse("1",1));
+                rc_=zoo_get(zh_,"/x/y/z",0,&buf,&size,0);
+                if(rc_!=ZOK){
+                    break;
+                }
+            }
+            //TEST_TRACE(("Finished %d iterations",i));
+        }
+        virtual void validate(const char* file, int line) const{
+            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
+        }
+        ZookeeperServer* svr_;
+        zhandle_t* zh_;
+        int rc_;
+    };
+    void testConcurrentOperations1()
+    {
+        // frozen time -- no timeouts and no pings
+        Mock_gettimeofday timeMock;
+        
+        ZookeeperServer zkServer;
+        Mock_select selMock(&zkServer,ZookeeperServer::FD);
+        // must call zookeeper_close() while all the mocks are in the scope!
+        CloseFinally guard(&zh);
+        
+        zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // make sure the client has connected
+        while(zh->state!=CONNECTED_STATE)
+            millisleep(2);
+                
+        TestGetJob j1(&zkServer,zh);
+        TestGetJob j2(&zkServer,zh);
+        TestGetJob j3(&zkServer,zh);
+        TestGetJob j4(&zkServer,zh);
+        TestGetJob j5(&zkServer,zh);
+        TestGetJob j6(&zkServer,zh);
+        TestGetJob j7(&zkServer,zh);
+        TestGetJob j8(&zkServer,zh);
+        TestGetJob j9(&zkServer,zh);
+        TestGetJob j10(&zkServer,zh);
+
+        const int THREAD_COUNT=10;
+        CountDownLatch startLatch(THREAD_COUNT);
+        CountDownLatch endLatch(THREAD_COUNT);
+
+        j1.start(&startLatch,&endLatch);
+        j2.start(&startLatch,&endLatch);
+        j3.start(&startLatch,&endLatch);
+        j4.start(&startLatch,&endLatch);
+        j5.start(&startLatch,&endLatch);
+        j6.start(&startLatch,&endLatch);
+        j7.start(&startLatch,&endLatch);
+        j8.start(&startLatch,&endLatch);
+        j9.start(&startLatch,&endLatch);
+        j10.start(&startLatch,&endLatch);
+        endLatch.await();
+        // validate test results
+        VALIDATE_JOB(j1);
+        VALIDATE_JOB(j2);
+        VALIDATE_JOB(j3);
+        VALIDATE_JOB(j4);
+        VALIDATE_JOB(j5);
+        VALIDATE_JOB(j6);
+        VALIDATE_JOB(j7);
+        VALIDATE_JOB(j8);
+        VALIDATE_JOB(j9);
+        VALIDATE_JOB(j10);
+    }
+    class TestGetWithCloseJob: public TestJob{
+    public:
+        static const int REPS=3000;
+        TestGetWithCloseJob(ZookeeperServer* svr,zhandle_t* zh)
+            :svr_(svr),zh_(zh),rc_(ZAPIERROR){}
+        virtual void run(){
+            int i;
+            for(i=0;i<REPS;i++){
+                char buf;
+                int size=sizeof(buf);                
+                svr_->addSendResponse(new ZooGetResponse("1",1));
+                rc_=zoo_get(zh_,"/x/y/z",0,&buf,&size,0);
+                if(rc_!=ZOK){
+                    break;
+                }
+            }
+            //TEST_TRACE(("Finished %d iterations",i));
+        }
+        virtual void validate(const char* file, int line) const{
+            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
+        }
+        ZookeeperServer* svr_;
+        zhandle_t* zh_;
+        int rc_;
+    };
+
+    void testOperationsAndCloseConcurrently1()
+    {
+        for(int counter=0; counter<1; counter++){
+            // frozen time -- no timeouts and no pings
+            Mock_gettimeofday timeMock;
+            
+            ZookeeperServer zkServer;
+            Mock_select selMock(&zkServer,ZookeeperServer::FD);
+            // must call zookeeper_close() while all the mocks are in the scope!
+            CloseFinally guard(&zh);
+            
+            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
+            CPPUNIT_ASSERT(zh!=0);
+            // make sure the client has connected
+            while(zh->state!=CONNECTED_STATE)
+                millisleep(2);
+            
+            TestGetWithCloseJob j1(&zkServer,zh);
+
+        }
+        
+    }
+#endif
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION(Zookeeper_operations);
diff --git a/zookeeper/c/tests/TestZookeeperClose.cc b/zookeeper/c/tests/TestZookeeperClose.cc
new file mode 100644
index 000000000..0c9e32883
--- /dev/null
+++ b/zookeeper/c/tests/TestZookeeperClose.cc
@@ -0,0 +1,313 @@
+#include <cppunit/extensions/HelperMacros.h>
+
+#include <zookeeper.h>
+#include "src/zk_adaptor.h"
+
+#include "LibCMocks.h"
+#include "ZKMocks.h"
+#include "Util.h"
+
+#ifdef THREADED
+#include "PthreadMocks.h"
+#endif
+
+using namespace std;
+
+class Zookeeper_close : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE(Zookeeper_close);
+    CPPUNIT_TEST(testCloseUnconnected);
+    CPPUNIT_TEST(testCloseUnconnected1);
+    CPPUNIT_TEST(testCloseConnected1);
+    CPPUNIT_TEST(testCloseFromWatcher1);
+    CPPUNIT_TEST_SUITE_END();
+    zhandle_t *zh;
+    static void watcher(zhandle_t *, int, int, const char *){}
+public: 
+    void setUp()
+    {
+        zoo_set_debug_level((ZooLogLevel)0); // disable logging
+        zoo_deterministic_conn_order(0);
+        zh=0;
+    }
+    
+    void tearDown()
+    {
+        zookeeper_close(zh);
+    }
+
+#ifndef THREADED
+    void testCloseUnconnected()
+    {       
+        zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0);       
+        CPPUNIT_ASSERT(zh!=0);
+        
+        // do not actually free the memory while in zookeeper_close()
+        Mock_free_noop freeMock;
+        // make a copy of zhandle before close() overwrites some of 
+        // it members with NULLs
+        zhandle_t lzh;
+        memcpy(&lzh,zh,sizeof(lzh));
+        int rc=zookeeper_close(zh);
+        zhandle_t* savezh=zh; zh=0;
+        freeMock.disable(); // disable mock's fake free()- use libc's free() instead
+        
+        // verify that zookeeper_close has done its job
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // memory
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.hostname));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.addrs));
+        CPPUNIT_ASSERT_EQUAL(3,freeMock.callCounter);
+    }
+    void testCloseUnconnected1()
+    {
+        zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0);       
+        CPPUNIT_ASSERT(zh!=0);
+        // simulate connected state 
+        zh->fd=100;
+        zh->state=CONNECTED_STATE;
+        Mock_flush_send_queue zkMock;
+        // do not actually free the memory while in zookeeper_close()
+        Mock_free_noop freeMock;
+        // make a copy of zhandle before close() overwrites some of 
+        // it members with NULLs
+        zhandle_t lzh;
+        memcpy(&lzh,zh,sizeof(lzh));
+        int rc=zookeeper_close(zh);
+        zhandle_t* savezh=zh; zh=0;
+        freeMock.disable(); // disable mock's fake free()- use libc's free() instead
+
+        // verify that zookeeper_close has done its job
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // memory
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.hostname));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.addrs));
+        // the close request sent?
+        CPPUNIT_ASSERT_EQUAL(1,zkMock.counter);
+    }
+    void testCloseConnected1()
+    {
+        zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0);       
+        CPPUNIT_ASSERT(zh!=0);
+
+        Mock_socket sockMock;
+        const int MY_FD=100;
+        sockMock.socketReturns=MY_FD;
+        sockMock.connectReturns=-1;
+        sockMock.connectErrno=EWOULDBLOCK;
+        
+        Mock_gettimeofday timeMock;
+        
+        int fd=0;
+        int interest=0;
+        timeval tv;
+        int rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        CPPUNIT_ASSERT_EQUAL(CONNECTING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOOKEEPER_READ|ZOOKEEPER_WRITE,interest);
+        
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
+        
+        timeMock.tick();
+        rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // prepare the handshake response
+        sockMock.recvReturnBuffer=HandshakeResponse().toString();
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        CPPUNIT_ASSERT_EQUAL(CONNECTED_STATE,zoo_state(zh));
+    }
+    void testCloseFromWatcher1()
+    {
+    }
+#else
+    void testCloseUnconnected()
+    {
+        // disable threading
+        MockPthreadZKNull pthreadMock;
+        zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0); 
+        
+        CPPUNIT_ASSERT(zh!=0);
+        adaptor_threads* adaptor=(adaptor_threads*)zh->adaptor_priv;
+        CPPUNIT_ASSERT(adaptor!=0);
+
+        // do not actually free the memory while in zookeeper_close()
+        Mock_free_noop freeMock;
+        // make a copy of zhandle before close() overwrites some of 
+        // it members with NULLs
+        zhandle_t lzh;
+        memcpy(&lzh,zh,sizeof(lzh));
+        int rc=zookeeper_close(zh);
+        zhandle_t* savezh=zh; zh=0;
+        // we're done, disable mock's fake free(), use libc's free() instead
+        freeMock.disable();
+        
+        // verify that zookeeper_close has done its job
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // memory
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.hostname));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.addrs));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(adaptor));
+        CPPUNIT_ASSERT_EQUAL(4,freeMock.callCounter);
+        // threads
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(adaptor->io));
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(adaptor->completion));
+        // mutexes
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->to_process.lock));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->to_process.lock));
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->to_send.lock));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->to_send.lock));
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->sent_requests.lock));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->sent_requests.lock));
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->completions_to_process.lock));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->completions_to_process.lock));
+        // conditionals
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->sent_requests.cond));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->sent_requests.cond));
+        CPPUNIT_ASSERT_EQUAL(1,MockPthreadsNull::getDestroyCounter(&savezh->completions_to_process.cond));
+        CPPUNIT_ASSERT_EQUAL(0,MockPthreadsNull::getInvalidAccessCounter(&savezh->completions_to_process.cond));
+    }
+    void testCloseUnconnected1()
+    {
+        for(int i=0; i<100;i++){
+            zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0); 
+            CPPUNIT_ASSERT(zh!=0);
+            adaptor_threads* adaptor=(adaptor_threads*)zh->adaptor_priv;
+            CPPUNIT_ASSERT(adaptor!=0);
+            int rc=zookeeper_close(zh);
+            zh=0;
+            CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        }
+    }
+    void testCloseConnected1()
+    {
+        // frozen time -- no timeouts and no pings
+        Mock_gettimeofday timeMock;
+
+        for(int i=0;i<500;i++){
+            ZookeeperServer zkServer;
+            Mock_select selMock(&zkServer,ZookeeperServer::FD);
+            // use a checked version of pthread calls
+            CheckedPthread threadMock;
+            // do not actually free the memory while in zookeeper_close()
+            Mock_free_noop freeMock;
+            
+            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0); 
+            CPPUNIT_ASSERT(zh!=0);
+            // make sure the client has connected
+            while(zh->state!=CONNECTED_STATE)
+                millisleep(2);
+            // make a copy of zhandle before close() overwrites some of 
+            // its members with NULLs
+            zhandle_t lzh;
+            memcpy(&lzh,zh,sizeof(lzh));
+            int rc=zookeeper_close(zh);
+            zhandle_t* savezh=zh; zh=0;
+            // we're done, disable mock's fake free(), use libc's free() instead
+            freeMock.disable();
+            
+            CPPUNIT_ASSERT_EQUAL(ZOK,rc);            
+            adaptor_threads* adaptor=(adaptor_threads*)lzh.adaptor_priv;
+            // memory
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.hostname));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.addrs));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(adaptor));
+            // threads
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->io));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->completion));
+            // mutexes
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->completions_to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->completions_to_process.lock));
+            // conditionals
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&savezh->completions_to_process.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&savezh->completions_to_process.cond));
+        }
+    }
+    
+    class CloseOnSessionExpired: public WatcherAction{
+    public:
+        CloseOnSessionExpired(Zookeeper_close& test):test_(test),rc(ZOK){}
+        virtual void onSessionExpired(zhandle_t* zh){
+            memcpy(&lzh,zh,sizeof(lzh));
+            rc=zookeeper_close(zh);           
+        }
+        Zookeeper_close& test_;
+        zhandle_t lzh;
+        int rc;
+    };
+
+    void testCloseFromWatcher1()
+    {
+        // frozen time -- no timeouts and no pings
+        Mock_gettimeofday timeMock;
+        
+        for(int i=0;i<500;i++){
+            ZookeeperServer zkServer;
+            // make the server return a non-matching session id
+            zkServer.returnSessionExpired();
+            
+            Mock_select selMock(&zkServer,ZookeeperServer::FD);
+            // use a checked version of pthread calls
+            CheckedPthread threadMock;
+            // do not actually free the memory while in zookeeper_close()
+            Mock_free_noop freeMock;
+
+            CloseOnSessionExpired closeAction(*this);
+            zh=zookeeper_init("localhost:2121",activeWatcher,10000,
+                    &testClientId,&closeAction,0);
+            
+            CPPUNIT_ASSERT(zh!=0);
+            // we rely on the fact that zh is freed the last right before
+            // zookeeper_close() returns...
+            while(!freeMock.isFreed(zh))
+                millisleep(2);
+            zhandle_t* lzh=zh;
+            zh=0;
+            // we're done, disable mock's fake free(), use libc's free() instead
+            freeMock.disable();
+            
+            CPPUNIT_ASSERT_EQUAL(ZOK,closeAction.rc);          
+            adaptor_threads* adaptor=(adaptor_threads*)closeAction.lzh.adaptor_priv;
+            // memory
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.hostname));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.addrs));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(adaptor));
+            // threads
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->io));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->completion));
+            // mutexes
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->completions_to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->completions_to_process.lock));
+            // conditionals
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->completions_to_process.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->completions_to_process.cond));
+        }
+    }
+#endif
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION(Zookeeper_close);
diff --git a/zookeeper/c/tests/TestZookeeperInit.cc b/zookeeper/c/tests/TestZookeeperInit.cc
new file mode 100644
index 000000000..803f3d7be
--- /dev/null
+++ b/zookeeper/c/tests/TestZookeeperInit.cc
@@ -0,0 +1,244 @@
+#include <cppunit/extensions/HelperMacros.h>
+
+#include <zookeeper.h>
+#include "src/zk_adaptor.h"
+
+#include <netinet/in.h>
+#include <errno.h>
+
+#include "LibCMocks.h"
+#include "Util.h"
+#ifdef THREADED
+#include "PthreadMocks.h"
+#else
+class MockPthreadsNull;
+#endif
+
+using namespace std;
+
+class Zookeeper_init : public CPPUNIT_NS::TestFixture
+{
+	CPPUNIT_TEST_SUITE(Zookeeper_init);
+	CPPUNIT_TEST(testBasic);
+    CPPUNIT_TEST(testAddressResolution);
+    CPPUNIT_TEST(testMultipleAddressResolution);
+    CPPUNIT_TEST(testInvalidAddressString1);
+    CPPUNIT_TEST(testInvalidAddressString2);
+    CPPUNIT_TEST(testNonexistentHost);
+    CPPUNIT_TEST(testOutOfMemory_init);
+    CPPUNIT_TEST(testOutOfMemory_getaddrs1);
+    CPPUNIT_TEST(testOutOfMemory_getaddrs2);
+    CPPUNIT_TEST(testPermuteAddrsList);
+	CPPUNIT_TEST_SUITE_END();
+    zhandle_t *zh;
+    MockPthreadsNull* pthreadMock;   
+    static void watcher(zhandle_t *, int , int , const char *){}
+public: 
+    Zookeeper_init():zh(0),pthreadMock(0){}
+    
+    void setUp()
+    {
+    	zoo_set_debug_level((ZooLogLevel)0); // disable logging
+        zoo_deterministic_conn_order(0);
+#ifdef THREADED
+        // disable threading
+        pthreadMock=new MockPthreadZKNull;
+#endif        
+        zh=0;
+    }
+    
+    void tearDown()
+    {
+        zookeeper_close(zh);
+#ifdef THREADED
+        delete pthreadMock;
+#endif
+    }
+
+    void testBasic()
+    {
+    	const string EXPECTED_HOST("localhost:2121");
+    	const int EXPECTED_ADDRS_COUNT =1;
+    	const int EXPECTED_RECV_TIMEOUT=10000;
+        clientid_t cid;
+    	memset(&cid,0xFE,sizeof(cid));
+        
+    	zh=zookeeper_init(EXPECTED_HOST.c_str(),watcher,EXPECTED_RECV_TIMEOUT,
+    	        &cid,(void*)1,0);
+        
+        CPPUNIT_ASSERT(zh!=0);
+    	CPPUNIT_ASSERT(zh->fd == -1);
+    	CPPUNIT_ASSERT(zh->hostname!=0);
+    	CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
+    	CPPUNIT_ASSERT_EQUAL(EXPECTED_HOST,string(zh->hostname));
+        CPPUNIT_ASSERT(zh->state == 0);
+        CPPUNIT_ASSERT(zh->context == (void*)1);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_RECV_TIMEOUT,zh->recv_timeout);
+        CPPUNIT_ASSERT(zh->watcher == watcher);
+        CPPUNIT_ASSERT(zh->connect_index==0);
+        CPPUNIT_ASSERT(zh->primer_buffer.buffer==zh->primer_storage_buffer);
+        CPPUNIT_ASSERT(zh->primer_buffer.curr_offset ==0);
+        CPPUNIT_ASSERT(zh->primer_buffer.len == sizeof(zh->primer_storage_buffer));
+        CPPUNIT_ASSERT(zh->primer_buffer.next == 0);
+        CPPUNIT_ASSERT(zh->last_zxid ==0);
+        CPPUNIT_ASSERT(memcmp(&zh->client_id,&cid,sizeof(cid))==0);
+
+#ifdef THREADED
+        // thread specific checks
+        adaptor_threads* adaptor=(adaptor_threads*)zh->adaptor_priv;
+        CPPUNIT_ASSERT(adaptor!=0);
+        CPPUNIT_ASSERT(pthreadMock->pthread_createCounter==2);
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(adaptor->io));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(adaptor->completion));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->to_process.lock));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->to_send.lock));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->sent_requests.lock));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->completions_to_process.lock));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->sent_requests.cond));
+        CPPUNIT_ASSERT(MockPthreadsNull::isInitialized(&zh->completions_to_process.cond));
+#endif
+    }
+    void testAddressResolution()
+    {
+        const char EXPECTED_IPS[][4]={{127,0,0,1},{127,0,0,2},{127,0,0,3}};
+        const int EXPECTED_ADDRS_COUNT =COUNTOF(EXPECTED_IPS);
+        Mock_gethostbyname mock;
+        mock.addHostEntry("somehostname").addAddress(EXPECTED_IPS[0]).
+            addAddress(EXPECTED_IPS[1]).addAddress(EXPECTED_IPS[2]);
+
+        zoo_deterministic_conn_order(1);
+        zh=zookeeper_init("host:2121",0,10000,0,0,0);
+        
+        CPPUNIT_ASSERT(zh!=0);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
+        for(int i=0;i<zh->addrs_count;i++){
+            sockaddr_in* addr=(struct sockaddr_in*)&zh->addrs[i];
+            CPPUNIT_ASSERT(memcmp(EXPECTED_IPS[i],&addr->sin_addr,sizeof(addr->sin_addr))==0);
+            CPPUNIT_ASSERT_EQUAL(2121,(int)ntohs(addr->sin_port));
+        }
+    }
+    void testMultipleAddressResolution()
+    {
+        const string EXPECTED_HOST("host1:2121,host2:3434");
+        const char EXPECTED_IPS[][4]={{127,0,0,1},{127,0,0,2},{127,0,0,3},
+                {126,1,1,1},{126,2,2,2}};
+        const int EXPECTED_ADDRS_COUNT =COUNTOF(EXPECTED_IPS);
+        Mock_gethostbyname mock;
+        mock.addHostEntry("somehost1").addAddress(EXPECTED_IPS[0]).
+            addAddress(EXPECTED_IPS[1]).addAddress(EXPECTED_IPS[2]);
+        mock.addHostEntry("somehost2").addAddress(EXPECTED_IPS[3]).
+            addAddress(EXPECTED_IPS[4]);
+
+        zoo_deterministic_conn_order(1);
+        zh=zookeeper_init(EXPECTED_HOST.c_str(),0,1000,0,0,0);
+
+        CPPUNIT_ASSERT(zh!=0);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
+
+        for(int i=0;i<zh->addrs_count;i++){
+            sockaddr_in* addr=(struct sockaddr_in*)&zh->addrs[i];
+            CPPUNIT_ASSERT(memcmp(EXPECTED_IPS[i],&addr->sin_addr,sizeof(addr->sin_addr))==0);
+            if(i<3)
+                CPPUNIT_ASSERT_EQUAL(2121,(int)ntohs(addr->sin_port));
+            else
+                CPPUNIT_ASSERT_EQUAL(3434,(int)ntohs(addr->sin_port));
+        }
+    }
+    void testInvalidAddressString1()
+    {
+        const string INVALID_HOST("host1");
+        zh=zookeeper_init(INVALID_HOST.c_str(),0,0,0,0,0);
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(EINVAL,errno);
+    }
+    void testInvalidAddressString2()
+    {
+        const string INVALID_HOST("host1:1111+host:123");
+        zh=zookeeper_init(INVALID_HOST.c_str(),0,0,0,0,0);
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(EINVAL,errno);
+    }
+    void testNonexistentHost()
+    {
+        const string EXPECTED_HOST("host1:1111");
+        MockFailed_gethostbyname mock;
+        
+        zh=zookeeper_init(EXPECTED_HOST.c_str(),0,0,0,0,0);
+        
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(EINVAL,errno);
+        CPPUNIT_ASSERT_EQUAL(HOST_NOT_FOUND,h_errno);
+    }
+    void testOutOfMemory_init()
+    {
+        Mock_calloc mock;
+        mock.callsBeforeFailure=0; // fail first calloc in init()
+        
+        zh=zookeeper_init("ahost:123",watcher,10000,0,0,0);
+        
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
+    }
+    void testOutOfMemory_getaddrs1()
+    {
+        Mock_realloc reallocMock;
+        reallocMock.callsBeforeFailure=0; // fail on first call to realloc
+
+        Mock_gethostbyname gethostbynameMock;
+        gethostbynameMock.addHostEntry("ahost").addAddress("\1\1\1\1");
+
+        zh=zookeeper_init("ahost:123",0,0,0,0,0);
+        
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
+    }
+    void testOutOfMemory_getaddrs2()
+    {
+        const char ADDR[]="\1\1\1\1";
+        Mock_realloc reallocMock;
+        reallocMock.callsBeforeFailure=1; // fail on the second call to realloc
+
+        Mock_gethostbyname gethostbynameMock;
+        // need >16 IPs to get realloc called the second time
+        gethostbynameMock.addHostEntry("ahost").
+            addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).
+            addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).
+            addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).
+            addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).addAddress(ADDR).
+            addAddress(ADDR);
+
+        zh=zookeeper_init("ahost:123",0,0,0,0,0);
+        
+        CPPUNIT_ASSERT(zh==0);
+        CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
+    }
+    void testPermuteAddrsList()
+    {
+        const char EXPECTED[][5]={"\0\0\0\0","\1\1\1\1","\2\2\2\2","\3\3\3\3"};
+        const int EXPECTED_ADDR_COUNT=COUNTOF(EXPECTED);
+        
+        Mock_gethostbyname gethostbynameMock;
+        gethostbynameMock.addHostEntry("ahost").
+            addAddress(EXPECTED[0]).addAddress(EXPECTED[1]).
+            addAddress(EXPECTED[2]).addAddress(EXPECTED[3]);
+
+        const int RAND_SEQ[]={0,1,2,3,1,3,2,0,-1};
+        const int RAND_SIZE=COUNTOF(RAND_SEQ);
+        Mock_random randomMock;
+        randomMock.randomReturns.assign(RAND_SEQ,RAND_SEQ+RAND_SIZE-1);
+        zh=zookeeper_init("ahost:123",0,1000,0,0,0);
+        
+        CPPUNIT_ASSERT(zh!=0);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDR_COUNT,zh->addrs_count);
+        const string EXPECTED_SEQ("3210");
+        char ACTUAL_SEQ[EXPECTED_ADDR_COUNT+1]; ACTUAL_SEQ[EXPECTED_ADDR_COUNT]=0;
+        for(int i=0;i<zh->addrs_count;i++){
+            sockaddr_in* addr=(struct sockaddr_in*)&zh->addrs[i];
+            // match the first byte of the EXPECTED and of the actual address
+            ACTUAL_SEQ[i]=((char*)&addr->sin_addr)[0]+'0';
+        }
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_SEQ,string(ACTUAL_SEQ));
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION(Zookeeper_init);
diff --git a/zookeeper/c/tests/Util.cc b/zookeeper/c/tests/Util.cc
new file mode 100644
index 000000000..8bb3f2440
--- /dev/null
+++ b/zookeeper/c/tests/Util.cc
@@ -0,0 +1,42 @@
+#include <zookeeper.h>
+#include "Util.h"
+#include "LibCSymTable.h"
+
+#ifdef THREADED
+#include <pthread.h>
+
+struct Mutex::Impl{
+    Impl(){
+        LIBC_SYMBOLS.pthread_mutex_init(&mut_, 0);        
+    }
+    ~Impl(){
+        LIBC_SYMBOLS.pthread_mutex_destroy(&mut_);        
+    }
+    pthread_mutex_t mut_;
+};
+
+Mutex::Mutex():impl_(new Impl) {}
+Mutex::~Mutex() { delete impl_;}
+void Mutex::acquire() {
+    LIBC_SYMBOLS.pthread_mutex_lock(&impl_->mut_);
+}
+void Mutex::release() {
+    LIBC_SYMBOLS.pthread_mutex_unlock(&impl_->mut_);
+}
+#endif
+
+void millisleep(int ms){
+    timespec ts;
+    ts.tv_sec=ms/1000;
+    ts.tv_nsec=(ms%1000)*1000000; // to nanoseconds
+    nanosleep(&ts,0);
+}
+
+void activeWatcher(zhandle_t *zh, int type, int state, const char *path){
+    if(zh==0 || zoo_get_context(zh)==0) return;
+    WatcherAction* action=(WatcherAction*)zoo_get_context(zh);
+        
+    if(type==SESSION_EVENT && state==EXPIRED_SESSION_STATE)
+        action->onSessionExpired(zh);
+    // TODO: implement for the rest of the event types
+}
diff --git a/zookeeper/c/tests/Util.h b/zookeeper/c/tests/Util.h
new file mode 100644
index 000000000..e85373d77
--- /dev/null
+++ b/zookeeper/c/tests/Util.h
@@ -0,0 +1,121 @@
+#ifndef UTIL_H_
+#define UTIL_H_
+
+#include <map>
+
+#include <zookeeper.h>
+
+// number of elements in array
+#define COUNTOF(array) sizeof(array)/sizeof(array[0])
+
+#define DECLARE_WRAPPER(ret,sym,sig) \
+    extern "C" ret __real_##sym sig; \
+    extern "C" ret __wrap_##sym sig
+
+#define CALL_REAL(sym,params) \
+    __real_##sym params
+
+// must include "src/zk_log.h" to be able to use this macro
+#define TEST_TRACE(x) \
+    log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
+
+// *****************************************************************************
+// A bit of wizardry to get to the bare type from a reference or a pointer 
+// to the type
+template <class T>
+struct TypeOp {
+    typedef T BareT;
+    typedef T ArgT;
+};
+
+// partial specialization for reference types
+template <class T>
+struct TypeOp<T&>{
+    typedef T& ArgT;
+    typedef typename TypeOp<T>::BareT BareT;
+};
+
+// partial specialization for pointers
+template <class T>
+struct TypeOp<T*>{
+    typedef T* ArgT;
+    typedef typename TypeOp<T>::BareT BareT;
+};
+
+// *****************************************************************************
+// Threading primitives
+
+#ifdef THREADED
+class Mutex{
+public:
+    Mutex();
+    ~Mutex();
+    void acquire();
+    void release();
+private:
+    Mutex(const Mutex&);
+    Mutex& operator=(const Mutex&);
+    struct Impl;
+    Impl* impl_;
+};
+
+class MTLock{
+public:
+    MTLock(Mutex& m):m_(m){m.acquire();}
+    ~MTLock(){m_.release();}
+    Mutex& m_;
+};
+#define synchronized(m) MTLock __lock(m)
+#else 
+// single THREADED
+class Mutex{
+public:
+    void acquire(){}
+    void release(){}
+};
+#define synchronized(m)
+#endif
+
+// *****************************************************************************
+// Container utilities
+
+template <class K, class V>
+void putValue(std::map<K,V>& map,const K& k, const V& v){
+    typedef std::map<K,V> Map;
+    typename Map::const_iterator it=map.find(k);
+    if(it==map.end())
+        map.insert(typename Map::value_type(k,v));
+    else
+        map[k]=v;
+}
+
+template <class K, class V>
+bool getValue(const std::map<K,V>& map,const K& k,V& v){
+    typedef std::map<K,V> Map;
+    typename Map::const_iterator it=map.find(k);
+    if(it==map.end())
+        return false;
+    v=it->second;
+    return true;
+}
+
+// *****************************************************************************
+// misc utils
+void millisleep(int ms);
+
+
+// *****************************************************************************
+// Abstract watcher action
+class WatcherAction{
+public:
+    virtual ~WatcherAction(){}
+    
+    virtual void onSessionExpired(zhandle_t*) =0;
+    // TODO: add the rest of the events
+};
+// zh->context is a pointer to a WatcherAction instance
+// based on the event type and state, the watcher calls a specific watcher 
+// action method
+void activeWatcher(zhandle_t *zh, int type, int state, const char *path);
+
+#endif /*UTIL_H_*/
diff --git a/zookeeper/c/tests/ZKMocks.cc b/zookeeper/c/tests/ZKMocks.cc
new file mode 100644
index 000000000..0f905b757
--- /dev/null
+++ b/zookeeper/c/tests/ZKMocks.cc
@@ -0,0 +1,163 @@
+#include <arpa/inet.h>  // for htonl
+#include <memory>
+
+#include "ZKMocks.h"
+#include "Util.h"
+
+#include <zookeeper.jute.h>
+#include <proto.h>
+
+using namespace std;
+
+TestClientId testClientId;
+const char* TestClientId::PASSWD="1234567890123456";
+
+HandshakeRequest* HandshakeRequest::parse(const std::string& buf){
+    auto_ptr<HandshakeRequest> req(new HandshakeRequest);
+
+    memcpy(&req->protocolVersion,buf.data(), sizeof(req->protocolVersion));
+    req->protocolVersion = htonl(req->protocolVersion);
+    
+    int offset=sizeof(req->protocolVersion);
+    
+    memcpy(&req->lastZxidSeen,buf.data()+offset,sizeof(req->lastZxidSeen));
+    req->lastZxidSeen = htonll(req->lastZxidSeen);
+    offset+=sizeof(req->lastZxidSeen);
+    
+    memcpy(&req->timeOut,buf.data()+offset,sizeof(req->timeOut));
+    req->timeOut = htonl(req->timeOut);
+    offset+=sizeof(req->timeOut);
+    
+    memcpy(&req->sessionId,buf.data()+offset,sizeof(req->sessionId));
+    req->sessionId = htonll(req->sessionId);
+    offset+=sizeof(req->sessionId);
+    
+    memcpy(&req->passwd_len,buf.data()+offset,sizeof(req->passwd_len));
+    req->passwd_len = htonl(req->passwd_len);
+    offset+=sizeof(req->passwd_len);
+    
+    memcpy(req->passwd,buf.data()+offset,sizeof(req->passwd));
+    if(testClientId.client_id==req->sessionId &&
+            !memcmp(testClientId.passwd,req->passwd,sizeof(req->passwd)))
+        return req.release();
+    // the request didn't match -- may not be a handshake request after all
+    return 0;
+}
+
+//******************************************************************************
+//
+DECLARE_WRAPPER(int,flush_send_queue,(zhandle_t*zh, int timeout))
+{
+    if(!Mock_flush_send_queue::mock_)
+        return CALL_REAL(flush_send_queue,(zh,timeout));
+    return Mock_flush_send_queue::mock_->call(zh,timeout);
+}
+
+Mock_flush_send_queue* Mock_flush_send_queue::mock_=0;
+
+//******************************************************************************
+//
+DECLARE_WRAPPER(int,adaptor_init,(zhandle_t* zh))
+{
+    if(!GetZHandleBeforInitReturned::mock_)
+        return CALL_REAL(adaptor_init,(zh));
+    return GetZHandleBeforInitReturned::mock_->call(zh);
+}
+
+int GetZHandleBeforInitReturned::call(zhandle_t *zh){
+    ptr=zh;
+    return CALL_REAL(adaptor_init,(zh));
+}
+
+GetZHandleBeforInitReturned* GetZHandleBeforInitReturned::mock_=0;
+
+//******************************************************************************
+//
+string HandshakeResponse::toString() const {
+    string buf;
+    int32_t tmp=htonl(protocolVersion);
+    buf.append((char*)&tmp,sizeof(tmp));
+    tmp=htonl(timeOut);
+    buf.append((char*)&tmp,sizeof(tmp));
+    int64_t tmp64=htonll(sessionId);
+    buf.append((char*)&tmp64,sizeof(sessionId));
+    tmp=htonl(passwd_len);
+    buf.append((char*)&tmp,sizeof(tmp));
+    buf.append(passwd,sizeof(passwd));
+    // finally set the buffer length
+    tmp=htonl(buf.size()+sizeof(tmp));
+    buf.insert(0,(char*)&tmp, sizeof(tmp));
+    return buf;
+}
+
+string ZooGetResponse::toString() const{
+    oarchive* oa=create_buffer_oarchive();
+    
+    ReplyHeader h = {xid_,1,ZOK};
+    serialize_ReplyHeader(oa, "hdr", &h);
+    
+    GetDataResponse resp;
+    resp.data.len=data_.size();
+    resp.data.buff=(char*)malloc(data_.size());
+    data_.copy(resp.data.buff, data_.size());
+    resp.stat=stat_;
+    serialize_GetDataResponse(oa, "reply", &resp);
+    int32_t len=htonl(get_buffer_len(oa));
+    string buf((char*)&len,sizeof(len));
+    buf.append(get_buffer(oa),get_buffer_len(oa));
+    
+    close_buffer_oarchive(&oa,1);
+    return buf;
+}
+
+//******************************************************************************
+// Zookeeper server simulator
+// 
+ssize_t ZookeeperServer::callRecv(int s,void *buf,size_t len,int flags){
+    // done transmitting the current buffer?
+    if(recvReturnBuffer.size()==0){
+        synchronized(recvQMx);
+        Element& el=recvQueue.front();
+        if(el.first!=0){
+            recvReturnBuffer=el.first->toString();
+            delete el.first;
+        }
+        recvErrno=el.second;
+        recvQueue.pop_front();
+    }
+    return Mock_socket::callRecv(s,buf,len,flags);
+}
+
+void ZookeeperServer::notifyBufferSent(const std::string& buffer){
+    if(HandshakeRequest::isValid(buffer)){
+        // could be a connect request
+        auto_ptr<HandshakeRequest> req(HandshakeRequest::parse(buffer));
+        if(req.get()!=0){
+            // handle the handshake
+            int64_t sessId=sessionExpired?req->sessionId+1:req->sessionId;
+            sessionExpired=false;
+            addRecvResponse(new HandshakeResponse(sessId));            
+            return;
+        }
+        // not a connect request -- fall thru
+    }
+    // parse the buffer to extract the request type and its xid
+    iarchive *ia=create_buffer_iarchive((char*)buffer.data(), buffer.size());
+    RequestHeader rh;
+    deserialize_RequestHeader(ia,"hdr",&rh);
+    close_buffer_iarchive(&ia);
+    if(rh.type==CLOSE_OP)
+        return; // no reply for close requests
+    // get the next response from the response queue and append it to the receive list
+    Element e;
+    {
+        synchronized(respQMx);
+        if(respQueue.empty())
+            return;
+       e=respQueue.front();
+       respQueue.pop_front();
+    }
+    e.first->setXID(rh.xid);
+    addRecvResponse(e);
+}
+
diff --git a/zookeeper/c/tests/ZKMocks.h b/zookeeper/c/tests/ZKMocks.h
new file mode 100644
index 000000000..9e7c368ef
--- /dev/null
+++ b/zookeeper/c/tests/ZKMocks.h
@@ -0,0 +1,240 @@
+#ifndef ZKMOCKS_H_
+#define ZKMOCKS_H_
+
+#include <zookeeper.h>
+#include "src/zk_adaptor.h"
+
+#include "MocksBase.h"
+#include "Util.h"
+#include "LibCMocks.h"
+
+struct CloseFinally{
+    CloseFinally(zhandle_t** zh):zh_(zh){}
+    ~CloseFinally(){
+        if(zh_==0)return;
+        zookeeper_close(*zh_);
+        *zh_=0;
+    }
+    void disarm(){zh_=0;}
+    zhandle_t ** zh_;
+};
+
+struct TestClientId: clientid_t{
+    static const int SESSION_ID=123456789;
+    static const char* PASSWD;
+    TestClientId(){
+        client_id=SESSION_ID;
+        memcpy(passwd,PASSWD,sizeof(passwd));
+    }
+};
+
+extern TestClientId testClientId;
+
+struct HandshakeRequest: public connect_req
+{
+    static HandshakeRequest* parse(const std::string& buf);
+    static bool isValid(const std::string& buf){
+        // this is just quick and dirty check before we go and parse the request
+        return buf.size()==HANDSHAKE_REQ_SIZE;
+    }
+};
+
+// *****************************************************************************
+// flush_send_queue
+
+class Mock_flush_send_queue: public Mock
+{
+public:
+    Mock_flush_send_queue():counter(0),callReturns(ZOK){mock_=this;}
+    ~Mock_flush_send_queue(){mock_=0;}
+    
+    int counter;
+    int callReturns;
+    virtual int call(zhandle_t* zh, int timeout){
+        counter++;
+        return callReturns;
+    }
+
+    static Mock_flush_send_queue* mock_;
+};
+
+// *****************************************************************************
+// There is a problem with the existing Sync API: a watcher can be called before
+// the init function returned. It makes it impossible to set the watcher context
+// properly, if you want to use the zhandle in the watcher. 
+// This class is a dirty trick to get the newly allocated zhandle_t pointer 
+// before zoookeeper_init returned. 
+
+class GetZHandleBeforInitReturned: public Mock
+{
+public:
+    GetZHandleBeforInitReturned():ptr(0){mock_=this;}
+    ~GetZHandleBeforInitReturned(){mock_=0;}
+    
+    zhandle_t* ptr;
+    virtual int call(zhandle_t *zh);
+
+    static GetZHandleBeforInitReturned* mock_;
+};
+
+// *****************************************************************************
+// a zookeeper Stat wrapper
+struct NodeStat: public Stat
+{
+    NodeStat(){
+        czxid=0;
+        mzxid=0;
+        ctime=0;
+        mtime=0;
+        version=1;
+        cversion=0;
+        aversion=0;
+        ephemeralOwner=0;
+    }
+};
+
+// *****************************************************************************
+// Abstract server Response
+class Response
+{
+public:
+    virtual ~Response(){}
+    
+    virtual void setXID(int32_t xid) =0;
+    virtual std::string toString() const =0;
+};
+
+// *****************************************************************************
+// Handshake response
+class HandshakeResponse: public Response
+{
+public:
+    HandshakeResponse(int64_t sessId=1)
+        :protocolVersion(1),timeOut(10000),sessionId(sessId),passwd_len(sizeof(passwd))
+    {
+        memcpy(passwd,"1234567890123456",sizeof(passwd));
+    }
+    int32_t protocolVersion;
+    int32_t timeOut;
+    int64_t sessionId;
+    int32_t passwd_len;
+    char passwd[16];
+    virtual std::string toString() const ;
+    virtual void setXID(int32_t xid) {/* no-op */}
+};
+
+// zoo_get() response
+class ZooGetResponse: public Response
+{
+public:
+    ZooGetResponse(char* data, int len,int rc=ZOK,const Stat& stat=NodeStat())
+        :xid_(0),data_(data,len),rc_(rc),stat_(stat)
+    {
+    }
+    virtual std::string toString() const;
+    virtual void setXID(int32_t xid) {xid_=xid;}
+    
+private:
+    int32_t xid_;
+    std::string data_;
+    int rc_;
+    Stat stat_;
+};
+
+// ****************************************************************************
+// Zookeeper server simulator
+
+class ZookeeperServer: public Mock_socket
+{
+public:
+    ZookeeperServer():serverDownSkipCount_(-1),sessionExpired(false){
+        connectReturns=-1;
+        connectErrno=EWOULDBLOCK;        
+    }
+    virtual ~ZookeeperServer(){
+        clearRecvQueue();
+        clearRespQueue();
+    }
+    virtual int callClose(int fd){
+        if(fd!=FD)
+            return LIBC_SYMBOLS.close(fd);
+        clearRecvQueue();
+        clearRespQueue();
+        return Mock_socket::callClose(fd);
+    }
+    // connection handling
+    // what to do when the handshake request comes in?
+    int serverDownSkipCount_;
+    // this will cause getsockopt(zh->fd,SOL_SOCKET,SO_ERROR,&error,&len) call fail
+    // after skipCount dropped to zero
+    // passing skipCount==-1 will make every connect attempt succeed
+    void setServerDown(int skipCount=0){ 
+        serverDownSkipCount_=skipCount;
+        optvalSO_ERROR=0;            
+    }
+    virtual void setSO_ERROR(void *optval,socklen_t len){
+        if(serverDownSkipCount_!=-1){
+            if(serverDownSkipCount_==0)
+                optvalSO_ERROR=ECONNREFUSED;
+            else
+                serverDownSkipCount_--;
+        }
+        Mock_socket::setSO_ERROR(optval,len);
+    }
+
+    // this is a trigger that gets reset back to false
+    // a connect request will return a non-matching session id thus causing 
+    // the client throw SESSION_EXPIRED
+    bool sessionExpired;
+    void returnSessionExpired(){ sessionExpired=true; }
+    
+    // recv
+    typedef std::pair<Response*,int> Element;
+    typedef std::deque<Element> ResponseList;
+    ResponseList recvQueue;
+    mutable Mutex recvQMx;
+    ZookeeperServer& addRecvResponse(Response* resp, int errnum=0){
+        synchronized(recvQMx);
+        recvQueue.push_back(Element(resp,errnum));
+        return *this;
+    }
+    ZookeeperServer& addRecvResponse(int errnum){
+        synchronized(recvQMx);
+        recvQueue.push_back(Element(0,errnum));
+        return *this;
+    }
+    ZookeeperServer& addRecvResponse(const Element& e){
+        synchronized(recvQMx);
+        recvQueue.push_back(e);
+        return *this;
+    }
+    void clearRecvQueue(){
+        synchronized(recvQMx);
+        for(unsigned i=0; i<recvQueue.size();i++)
+            delete recvQueue[i].first;
+        recvQueue.clear();
+    }
+    virtual ssize_t callRecv(int s,void *buf,size_t len,int flags);
+    virtual bool hasMoreRecv() const{
+        synchronized(recvQMx);
+        return recvQueue.size()!=0;
+    }
+    
+    // send operation doesn't try to match request to the response
+    ResponseList respQueue;
+    mutable Mutex respQMx;
+    ZookeeperServer& addSendResponse(Response* resp, int errnum=0){
+        synchronized(respQMx);
+        respQueue.push_back(Element(resp,errnum));
+        return *this;
+    }
+    void clearRespQueue(){
+        synchronized(respQMx);
+        for(unsigned i=0; i<respQueue.size();i++)
+            delete respQueue[i].first;
+        respQueue.clear();
+    }
+    virtual void notifyBufferSent(const std::string& buffer);
+};
+
+#endif /*ZKMOCKS_H_*/
diff --git a/zookeeper/c/tests/wrappers-mt.opt b/zookeeper/c/tests/wrappers-mt.opt
new file mode 100644
index 000000000..1d94e0147
--- /dev/null
+++ b/zookeeper/c/tests/wrappers-mt.opt
@@ -0,0 +1,2 @@
+-Wl,--wrap -Wl,pthread_mutex_lock
+-Wl,--wrap -Wl,pthread_mutex_unlock
\ No newline at end of file
diff --git a/zookeeper/c/tests/wrappers.opt b/zookeeper/c/tests/wrappers.opt
new file mode 100644
index 000000000..b5b11a7c7
--- /dev/null
+++ b/zookeeper/c/tests/wrappers.opt
@@ -0,0 +1,4 @@
+-Wl,--wrap -Wl,calloc
+-Wl,--wrap -Wl,free
+-Wl,--wrap -Wl,flush_send_queue
+-Wl,--wrap -Wl,adaptor_init
\ No newline at end of file
