diff --git a/zookeeper/build.xml b/zookeeper/build.xml
index 4fd8cb600..d3d9be7f0 100644
--- a/zookeeper/build.xml
+++ b/zookeeper/build.xml
@@ -8,6 +8,7 @@
     <property name="src.dir" value="${basedir}/java/src" />
     <property name="build.dir" value="${basedir}/build" />
     <property name="src_generated.dir" value="${build.dir}/java/generated" />
+    <property name="csrc_generated.dir" value="${build.dir}/c/generated" />
     <property name="build.classes" value="${build.dir}/classes" />
     <property name="config.dir" value="${basedir}/test/config" />
     <property name="build.docs" value="${build.dir}/docs" />
@@ -38,12 +39,23 @@
     <target name="compile_jute" depends="jute">
         <mkdir dir="${build.classes}" />
         <mkdir dir="${src_generated.dir}" />
+	<mkdir dir="${csrc_generated.dir}" />
         <java classname="com.yahoo.jute.compiler.generated.Rcc" fork="true" dir="${src_generated.dir}">
-            <arg value="../../../zookeeper.jute" />
+            <arg value="-l" />
+	    <arg value="java" />
+	    <arg value="../../../zookeeper.jute" /> 
             <classpath>
                 <pathelement path="${build.classes}" />
             </classpath>
         </java>
+	<java classname="com.yahoo.jute.compiler.generated.Rcc" fork="true" dir="${csrc_generated.dir}">
+	    <arg value="-l" />
+	    <arg value="c" />
+	    <arg value="../../../zookeeper.jute" />
+	    <classpath>
+	        <pathelement path="${build.classes}" />
+	    </classpath>
+         </java>
         <javac srcdir="${src_generated.dir}" destdir="${build.classes}" target="1.5" source="1.5" debug="on">
         </javac>
     </target>
diff --git a/zookeeper/c/Makefile b/zookeeper/c/Makefile
new file mode 100644
index 000000000..d02e005fb
--- /dev/null
+++ b/zookeeper/c/Makefile
@@ -0,0 +1,34 @@
+cc = gcc -Wall -g -O2
+ldflags = -g -fPIC
+
+all:    lib cli_mt cli_st
+
+lib:	libzookeeper_st.so libzookeeper_mt.so
+
+libzookeeper_st.so:	recordio.o zookeeper_st.o zookeeper.jute.o st_adaptor.o
+	${cc} -g  -shared -o $@ $^
+
+libzookeeper_mt.so:	recordio.o zookeeper_mt.o zookeeper.jute.o mt_adaptor.o
+	${cc} -g -shared -o $@ $^
+
+zookeeper_mt.o:	src/zookeeper.c Makefile include/*.h ../build/c/generated/* src/*.h
+	${cc} -DTHREADED ${ldflags} -I../build/c/generated/ -Iinclude/ -o $@ -c $<
+
+zookeeper_st.o:	src/zookeeper.c Makefile include/*.h ../build/c/generated/*
+	${cc} ${ldflags} -I../build/c/generated/ -Iinclude/ -o $@ -c $<
+
+zookeeper.jute.o: ../build/c/generated/*
+	${cc} ${ldflags} -I../build/c/generated/ -Iinclude/ -o $@ -c $<
+
+%.o:	src/%.c Makefile include/*.h
+	${cc} ${ldflags} -I../build/c/generated/ -Iinclude/ -c $<
+
+
+cli_mt:	src/cli.c include/*.h Makefile ../build/c/generated/* libzookeeper_mt.so
+	${cc} -I../build/c/generated/ -I include/ -L. -DTHREADED -lzookeeper_mt -lpthread $< -o cli_mt
+
+cli_st:	src/cli.c include/*.h Makefile libzookeeper_st.so
+	${cc} -g  -I../build/c/generated/ -Iinclude/ -L. -lzookeeper_st $< -o cli_st
+
+clean : 
+	rm -rf *.o *.so cli_mt cli_st
diff --git a/zookeeper/c/c-doc.Doxyfile b/zookeeper/c/c-doc.Doxyfile
new file mode 100644
index 000000000..35de272db
--- /dev/null
+++ b/zookeeper/c/c-doc.Doxyfile
@@ -0,0 +1,1252 @@
+# Doxyfile 1.4.7
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME = "ZooKeeper"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY = 
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING = NO
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA = NO
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
+# include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT = NO
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST = YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES = NO
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT = include/zookeeper.h
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py
+
+FILE_PATTERNS = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.  Otherwise they will link to the documentstion.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN = YES
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a caller dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable caller graphs for selected 
+# functions only using the \callergraph command.
+
+CALLER_GRAPH = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE = NO
diff --git a/zookeeper/c/include/proto.h b/zookeeper/c/include/proto.h
new file mode 100755
index 000000000..ed0fb7292
--- /dev/null
+++ b/zookeeper/c/include/proto.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef PROTO_H_
+#define PROTO_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static const int NOTIFY_OP=0;
+static const int CREATE_OP=1;
+static const int DELETE_OP=2;
+static const int EXISTS_OP=3;
+static const int GETDATA_OP=4;
+static const int SETDATA_OP=5;
+static const int GETACL_OP=6;
+static const int SETACL_OP=7;
+static const int GETCHILDREN_OP=8;
+static const int GETMAXCHILDREN_OP=9;
+static const int SETMAXCHILDREN_OP=10;
+static const int PING_OP=11;
+static const int CLOSE_OP=-11;
+static const int SETAUTH_OP=100;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*PROTO_H_*/
diff --git a/zookeeper/c/include/recordio.h b/zookeeper/c/include/recordio.h
new file mode 100755
index 000000000..3d075e9bd
--- /dev/null
+++ b/zookeeper/c/include/recordio.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __RECORDIO_H__
+#define __RECORDIO_H__
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct buffer {
+    int len;
+    char *buff;
+};
+
+void deallocate_String(char **s);
+void deallocate_Buffer(struct buffer *b);
+void deallocate_vector(void *d);
+struct iarchive {
+    int (*start_record)(struct iarchive *ia, const char *tag);
+    int (*end_record)(struct iarchive *ia, const char *tag);
+    int (*start_vector)(struct iarchive *ia, const char *tag, int *count);
+    int (*end_vector)(struct iarchive *ia, const char *tag);
+    int (*deserialize_Bool)(struct iarchive *ia, const char *name, int *);
+    int (*deserialize_Int)(struct iarchive *ia, const char *name, int *);
+    int (*deserialize_Long)(struct iarchive *ia, const char *name, long long *);
+    int (*deserialize_Buffer)(struct iarchive *ia, const char *name,
+            struct buffer *);
+    int (*deserialize_String)(struct iarchive *ia, const char *name, char **);
+    void *priv;
+};
+struct oarchive {
+    int (*start_record)(struct oarchive *oa, const char *tag);
+    int (*end_record)(struct oarchive *oa, const char *tag);
+    int (*start_vector)(struct oarchive *oa, const char *tag, const int *count);
+    int (*end_vector)(struct oarchive *oa, const char *tag);
+    int (*serialize_Bool)(struct oarchive *oa, const char *name, const int *);
+    int (*serialize_Int)(struct oarchive *oa, const char *name, const int *);
+    int (*serialize_Long)(struct oarchive *oa, const char *name,
+            const long long *);
+    int (*serialize_Buffer)(struct oarchive *oa, const char *name,
+            const struct buffer *);
+    int (*serialize_String)(struct oarchive *oa, const char *name, char **);
+    void *priv;
+};
+
+struct oarchive *create_buffer_oarchive();
+void close_buffer_oarchive(struct oarchive **oa, int free_buffer);
+struct iarchive *create_buffer_iarchive(char *buffer, int len);
+void close_buffer_iarchive(struct iarchive **ia);
+char *get_buffer(struct oarchive *);
+int get_buffer_len(struct oarchive *);
+
+int64_t htonll(int64_t v);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/zookeeper/c/include/zookeeper.h b/zookeeper/c/include/zookeeper.h
new file mode 100644
index 000000000..29613dd24
--- /dev/null
+++ b/zookeeper/c/include/zookeeper.h
@@ -0,0 +1,759 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ZOOKEEPER_H_
+#define ZOOKEEPER_H_
+
+#include <sys/time.h>
+#include "recordio.h"
+#include "zookeeper.jute.h"
+
+/**
+ * \file zookeeper.h 
+ * \brief ZooKeeper functions and definitions.
+ * 
+ * ZooKeeper is a network service that may be backed by a cluster of
+ * synchronized servers. The data in the service is represented as a tree
+ * of data nodes. Each node has data, children, an ACL, and status information.
+ * The data for a node is read and write in its entirety.
+ * 
+ * ZooKeeper clients can leave watches when they queries the data or children
+ * of a node. If a watch is left, that client will be notified of the change.
+ * The notification is a one time trigger. Subsequent chances to the node will
+ * not trigger a notification unless the client issues a querity with the watch
+ * flag set. If the client is ever disconnected from the service, even if the
+ * disconnection is temporary, the watches of the client will be removed from
+ * the service, so a client must treat a disconnect notification as an implicit
+ * trigger of all outstanding watches.
+ * 
+ * When a node is created, it may be flagged as an ephemeral node. Ephemeral
+ * nodes are automatically removed when a client session is closed or when
+ * a session times out due to inactivity (the ZooKeeper runtime fills in
+ * periods of inactivity with pings). Ephemeral nodes cannot have children.
+ * 
+ * ZooKeeper clients are identified by a server assigned session id. For
+ * security reasons The server
+ * also generates a corresponding password for a session. A client may save its
+ * id and corresponding password to persistent storage in order to use the
+ * session across program invocation boundaries.
+ */
+
+/* Support for building on various platforms */
+
+// on cygwin we should take care of exporting/importing symbols properly 
+#if defined(__CYGWIN__) && !defined(ZOO_STATIC_LIB)
+# ifdef BUILD_LIB
+#  define ZOOAPI __declspec(dllexport)
+# else
+#  define ZOOAPI __declspec(dllimport)
+# endif
+#else
+#  define ZOOAPI
+#endif
+
+/** zookeeper return constants **/
+
+#define ZOK                                    0
+#define ZSYSTEMERROR                          -1
+#define ZRUNTIMEINCONSISTENCY (ZSYSTEMERROR - 1)
+#define ZDATAINCONSISTENCY    (ZSYSTEMERROR - 2)
+#define ZCONNECTIONLOSS       (ZSYSTEMERROR - 3)
+#define ZMARSHALLINGERROR     (ZSYSTEMERROR - 4)
+#define ZUNIMPLEMENTED        (ZSYSTEMERROR - 5)
+#define ZOPERATIONTIMEOUT     (ZSYSTEMERROR - 6)
+#define ZBADARGUMENTS         (ZSYSTEMERROR - 7)
+#define ZINVALIDSTATE         (ZSYSTEMERROR - 8)
+#define ZAPIERROR                           -100
+#define ZNONODE                  (ZAPIERROR - 1)
+#define ZNOAUTH                  (ZAPIERROR - 2)
+#define ZBADVERSION              (ZAPIERROR - 3)
+#define ZNOCHILDRENFOREPHEMERALS (ZAPIERROR - 8)
+#define ZNODEEXISTS             (ZAPIERROR - 10)
+#define ZNOTEMPTY               (ZAPIERROR - 11)
+#define ZSESSIONEXPIRED         (ZAPIERROR - 12)
+#define ZINVALIDCALLBACK        (ZAPIERROR - 13)
+#define ZINVALIDACL             (ZAPIERROR - 14)
+#define ZAUTHFAILED             (ZAPIERROR - 15)
+#define ZCLOSING                (ZAPIERROR - 16)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+*  @name Debug levels
+*/
+typedef enum {LOG_LEVEL_ERROR=1,LOG_LEVEL_WARN=2,LOG_LEVEL_INFO=3,LOG_LEVEL_DEBUG=4} ZooLogLevel;
+/**
+ * @name ACL Consts
+ */
+extern ZOOAPI const int PERM_READ;
+extern ZOOAPI const int PERM_WRITE;
+extern ZOOAPI const int PERM_CREATE;
+extern ZOOAPI const int PERM_DELETE;
+extern ZOOAPI const int PERM_ADMIN;
+extern ZOOAPI const int PERM_ALL;
+
+extern ZOOAPI struct Id ANYONE_ID_UNSAFE;
+extern ZOOAPI struct Id AUTH_IDS;
+
+extern ZOOAPI struct ACL _OPEN_ACL_UNSAFE_ACL[];
+extern ZOOAPI struct ACL _READ_ACL_UNSAFE_ACL[];
+extern ZOOAPI struct ACL _CREATOR_ALL_ACL_ACL[];
+extern ZOOAPI struct ACL_vector OPEN_ACL_UNSAFE;
+extern ZOOAPI struct ACL_vector READ_ACL_UNSAFE;
+extern ZOOAPI struct ACL_vector CREATOR_ALL_ACL;
+
+/**
+ * @name Interest Consts
+ * These constants are used to express interest in an event and to
+ * indicate to zookeeper which events have occurred. They can
+ * be ORed together to express multiple interests. These flags are
+ * used in the interest and event parameters of 
+ * \ref zookeeper_interest and \ref zookeeper_process.
+ */
+// @{
+extern ZOOAPI const int ZOOKEEPER_WRITE;
+extern ZOOAPI const int ZOOKEEPER_READ;
+// @}
+
+/**
+ * @name Create Flags
+ * 
+ * These flags are used by zoo_create to affect node create. They may
+ * be ORed together to combine effects.
+ */
+// @{
+extern ZOOAPI const int EPHEMERAL;
+extern ZOOAPI const int SEQUENCE;
+// @}
+
+/**
+ * @name State Consts
+ * These constants represent the states of a zookeeper connection. They are
+ * possible parameters of the watcher callback. If a connection moves from
+ * the CONNECTED_STATE to the CONNECTING_STATE, all outstanding watches will
+ * be removed.
+ */
+// @{
+extern ZOOAPI const int EXPIRED_SESSION_STATE;
+extern ZOOAPI const int AUTH_FAILED_STATE;
+extern ZOOAPI const int CONNECTING_STATE;
+extern ZOOAPI const int ASSOCIATING_STATE;
+extern ZOOAPI const int CONNECTED_STATE;
+// @}
+
+/**
+ * @name Watch Types
+ * These constants indicate the event that caused the watch event. They are
+ * possible values of the first parameter of the watcher callback.
+ */
+// @{
+/**
+ * \brief a node has been created.
+ * 
+ * This is only generated by watches on non-existent nodes. These watches
+ * are set using \ref zoo_exists.
+ */
+extern ZOOAPI const int CREATED_EVENT;
+/**
+ * \brief a node has been deleted.
+ * 
+ * This is only generated by watches on nodes. These watches
+ * are set using \ref zoo_exists and \ref zoo_get.
+ */
+extern ZOOAPI const int DELETED_EVENT;
+/**
+ * \brief a node has changed.
+ * 
+ * This is only generated by watches on nodes. These watches
+ * are set using \ref zoo_exists and \ref zoo_get.
+ */
+extern ZOOAPI const int CHANGED_EVENT;
+/**
+ * \brief a change as occurred in the list of children.
+ * 
+ * This is only generated by watches on the child list of a node. These watches
+ * are set using \ref zoo_get_children.
+ */
+extern ZOOAPI const int CHILD_EVENT;
+/**
+ * \brief a session has been lost.
+ * 
+ * This is generated when a client loses contact or reconnects with a server.
+ */
+extern ZOOAPI const int SESSION_EVENT;
+
+/**
+ * \brief a watch has been removed.
+ * 
+ * This is generated when the server for some reason, probably a resource
+ * constraint, will no longer watch a node for a client.
+ */
+extern ZOOAPI const int NOTWATCHING_EVENT;
+// @}
+
+/**
+ * \brief ZooKeeper handle.
+ * 
+ * This is the handle that represents a connection to the ZooKeeper service.
+ * It is needed to invoke any ZooKeeper function. A handle is obtained using
+ * \ref zookeeper_init.
+ */
+typedef struct _zhandle zhandle_t;
+
+/**
+ * \brief client id structure.
+ * 
+ * This structure holds the id and password for the session. This structure
+ * should be treated as opaque. It is received from the server when a session
+ * is established and needs to be sent back as-is when reconnecting a session.
+ */
+typedef struct {
+    int64_t client_id;
+    char passwd[16];
+} clientid_t;
+
+/**
+ * \brief signature of a watch function.
+ * 
+ * Programs wishing to receive events from ZooKeeper need to implement a method 
+ * with this signature and pass a pointer to the method to \ref zookeeper_init.
+ */
+typedef void (*watcher_fn)(void *, int type, int state, const char *path);
+
+/**
+ * \brief create a handle to used communicate with zookeeper.
+ * 
+ * This method creates a new handle and a zookeeper session that corresponds
+ * to that handle.
+ * \param host the host name to connect to. This may be a comma separated list
+ *   of different hosts.
+ * \param fn the watcher callback function. When notifications are triggered
+ *   this function will be invoked.
+ * \param clientid the id of a previously established session that this
+ *   client will be reconnecting to. Pass 0 if not reconnecting to a previous
+ *   session. If the session timed out or the id is invalid, a new
+ *   session will be automatically generated. Clients should check the actual
+ *   session id by calling \ref zoo_client_id. 
+ * \param passwd the password of a previously established session. Pass 0 if
+ *   reconnecting to a previous session. 
+ * \return a pointer to the opaque zhandle structure. If it fails to create 
+ * a new zhandle the function returns NULL and the errno variable 
+ * indicates the reason.
+ */
+ZOOAPI zhandle_t *zookeeper_init(const char *host, watcher_fn fn,
+  int recv_timeout, const clientid_t *clientid);
+
+/**
+ * \brief close the zookeeper handle and free up any resources.
+ * 
+ * After this call, the client session will no longer be valid. The function
+ * will flush any outstanding send requests before return. As a result it may 
+ * block.
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \return a result code. Regardless of the error code returned, the zhandle 
+ * will be destroyed and all resources freed. 
+ * ZOK - success
+ * ZBADARGUMENTS - invalid input parameters
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ * ZOPERATIONTIMEOUT - failed to flush the buffers within the specified timeout.
+ * ZCONNECTIONLOSS - a network error occured while attempting to send request to server
+ * ZSYSTEMERROR -- a system (OS) error occured; it's worth checking errno to get details
+ */
+ZOOAPI int zookeeper_close(zhandle_t *zh);
+
+/**
+ * \brief return the client session id
+ */
+ZOOAPI const clientid_t *zoo_client_id(zhandle_t *zh);
+
+ZOOAPI int zoo_recv_timeout(zhandle_t *zh);
+
+ZOOAPI const void *zoo_get_context(zhandle_t *zh);
+
+ZOOAPI void zoo_set_context(zhandle_t *zh, void *context);
+
+/**
+ * \brief set a watcher function
+ * \return previous watcher function
+ */
+ZOOAPI watcher_fn zoo_set_watcher(zhandle_t *zh,watcher_fn newFn);
+
+#ifndef THREADED
+/**
+ * \brief Returns the events that zookeeper is interested in.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param fd is the file descriptor of interest
+ * \param interest is an or of the ZOOKEEPER_WRITE and ZOOKEEPER_READ flags to
+ *    indicate the I/O of interest on fd.
+ * \param tv a timeout value to be used with select/poll system call
+ * \return a result code.
+ * ZOK - success
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZCONNECTIONLOSS - a network error occured while attempting to establish 
+ * a connection to the server
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ * ZOPERATIONTIMEOUT - hasn't received anything from the server for 2/3 of the
+ * timeout value specified in zookeeper_init()
+ * ZSYSTEMERROR -- a system (OS) error occured; it's worth checking errno to get details
+ */
+ZOOAPI int zookeeper_interest(zhandle_t *zh, int *fd, int *interest, 
+	struct timeval *tv);
+
+/**
+ * \brief Notifies zookeeper that an event of interest has happened.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param events will be an OR of the ZOOKEEPER_WRITE and ZOOKEEPER_READ flags.
+ * \return a result code. 
+ * ZOK - success
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZCONNECTIONLOSS - a network error occured while attempting to send request to server
+ * ZSESSIONEXPIRED - connection attempt failed -- the session's expired
+ * ZAUTHFAILED - authentication request failed, e.i. invalid credentials
+ * ZRUNTIMEINCONSISTENCY - a server response came out of order
+ * ZSYSTEMERROR -- a system (OS) error occured; it's worth checking errno to get details
+ */
+ZOOAPI int zookeeper_process(zhandle_t *zh, int events);
+#endif
+
+/**
+ * \brief signature of a completion function for a call that returns void.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void (*void_completion_t)(int rc, const void *data);
+
+/**
+ * \brief signature of a completion function that returns a Stat structure.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param stat a pointer to the stat information for the node involved in
+ *   this function. If a non zero error code is returned, the content of
+ *   stat is undefined. The programmer is NOT responsible for freeing stat.
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void (*stat_completion_t)(int rc, const struct Stat *stat,
+        const void *data);
+
+/**
+ * \brief signature of a completion function that returns data.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param value the value of the information returned by the asynchronous call.
+ *   If a non zero error code is returned, the content of value is undefined.
+ *   The programmer is NOT responsible for freeing value.
+ * \param value_len the number of bytes in value.
+ * \param stat a pointer to the stat information for the node involved in
+ *   this function. If a non zero error code is returned, the content of
+ *   stat is undefined. The programmer is NOT responsible for freeing stat.
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void (*data_completion_t)(int rc, const char *value, int value_len,
+        const struct Stat *stat, const void *data);
+
+/**
+ * \brief signature of a completion function that returns a list of strings.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param strings a pointer to the structure containng the list of strings of the
+ *   names of the children of a node. If a non zero error code is returned,
+ *   the content of strings is undefined. The programmer is NOT responsible
+ *   for freeing strings.
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void (*strings_completion_t)(int rc,
+        const struct String_vector *strings, const void *data);
+
+/**
+ * \brief signature of a completion function that returns a list of strings.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param value the value of the string returned.
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void
+        (*string_completion_t)(int rc, const char *value, const void *data);
+
+/**
+ * \brief signature of a completion function that returns an ACL.
+ * 
+ * This method will be invoked at the end of a asynchronous call and also as 
+ * a result of connection loss or timeout.
+ * \param rc the error code of the call. Connection loss/timeout triggers 
+ * the completion with one of the following error codes:
+ * ZCONNECTIONLOSS -- lost connection to the server
+ * ZOPERATIONTIMEOUT -- connection timed out
+ * Data related events trigger the completion with error codes listed the 
+ * Exceptions section of the documentation of the function that initiated the
+ * call. (Zero indicates call was successful.)
+ * \param acl a pointer to the structure containng the ACL of a node. If a non 
+ *   zero error code is returned, the content of strings is undefined. The
+ *   programmer is NOT responsible for freeing acl.
+ * \param stat a pointer to the stat information for the node involved in
+ *   this function. If a non zero error code is returned, the content of
+ *   stat is undefined. The programmer is NOT responsible for freeing stat.
+ * \param data the pointer that was passed by the caller when the function
+ *   that this completion corresponds to was invoked. The programmer
+ *   is responsible for any memory freeing associated with the data
+ *   pointer.
+ */
+typedef void (*acl_completion_t)(int rc, struct ACL_vector *acl,
+        struct Stat *stat, const void *data);
+
+/**
+ * \brief get the state of the zookeeper connection.
+ * 
+ * The return value will be one of the \ref State Consts.
+ */
+ZOOAPI int zoo_state(zhandle_t *zh);
+
+/**
+ * \brief create a node.
+ * 
+ * This method will create a node in ZooKeeper. A node can only be created if
+ * it does not already exists. The Create Flags affect the creation of nodes.
+ * If EPHEMERAL flag is set, the node will automatically get removed if the
+ * client session goes away. If the SEQUENCE flag is set, a unique
+ * monotonically increasing sequence number is appended to the path name.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path The name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param value The data to be stored in the node.
+ * \param valuelen The number of bytes in data.
+ * \param acl The initial ACL of the node. If null, the ACL of the parent will be
+ *    used.
+ * \param flags this parameter can be set to 0 for normal create or an OR
+ *    of the Create Flags
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the parent node does not exist.
+ * ZNODEEXISTS the node already exists
+ * ZNOAUTH the client does not have permission.
+ * ZNOCHILDRENFOREPHEMERALS cannot create children of ephemeral nodes.
+ * \param data The data that will be passed to the completion routine when the 
+ * function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_acreate(zhandle_t *zh, const char *path, const char *value, 
+        int valuelen, const struct ACL_vector *acl, int flags,
+        string_completion_t completion, const void *data);
+
+/**
+ * \brief delete a node in zookeeper.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param version the expected version of the node. The function will fail if the
+ *    actual version of the node does not match the expected version.
+ *  If -1 is used the version check will not take place. 
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * ZBADVERSION expected version does not match actual version.
+ * ZNOTEMPTY children are present; node cannot be deleted.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_adelete(zhandle_t *zh, const char *path, int version, 
+        void_completion_t completion, const void *data);
+
+/**
+ * \brief checks the existence of a node in zookeeper.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param watch if nonzero, a watch will be set at the server to notify the 
+ * client if the node changes. The watch will be set even if the node does not 
+ * exist. This allows clients to watch for nodes to appear.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * \param data the data that will be passed to the completion routine when the 
+ * function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aexists(zhandle_t *zh, const char *path, int watch, 
+        stat_completion_t completion, const void *data);
+
+/**
+ * \brief gets the data associated with a node.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param watch if nonzero, a watch will be set at the server to notify 
+ * the client if the node changes.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either in SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aget(zhandle_t *zh, const char *path, int watch, 
+        data_completion_t completion, const void *data);
+
+/**
+ * \brief sets the data associated with a node.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param buffer the buffer holding data to be written to the node.
+ * \param buflen the number of bytes from buffer to write.
+ * \param version the expected version of the node. The function will fail if 
+ * the actual version of the node does not match the expected version. If -1 is 
+ * used the version check will not take place. * completion: If null, 
+ * the function will execute synchronously. Otherwise, the function will return 
+ * immediately and invoke the completion routine when the request completes.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * ZBADVERSION expected version does not match actual version.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aset(zhandle_t *zh, const char *path, const char *buffer, int buflen, 
+        int version, stat_completion_t completion, const void *data);
+
+/**
+ * \brief lists the children of a node.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param watch if nonzero, a watch will be set at the server to notify 
+ * the client if the node changes.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aget_children(zhandle_t *zh, const char *path, int watch, 
+        strings_completion_t completion, const void *data);
+
+/**
+ * \brief gets the acl associated with a node.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aget_acl(zhandle_t *zh, const char *path, acl_completion_t completion, 
+        const void *data);
+
+/**
+ * \brief sets the acl associated with a node.
+ * 
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param path the name of the node. Expressed as a file name with slashes 
+ * separating ancestors of the node.
+ * \param buffer the buffer holding the acls to be written to the node.
+ * \param buflen the number of bytes from buffer to write.
+ * \param completion the routine to invoke when the request completes. The completion
+ * will be triggered with one of the following codes passed in as the rc argument:
+ * ZOK operation completed succesfully
+ * ZNONODE the node does not exist.
+ * ZNOAUTH the client does not have permission.
+ * ZINVALIDACL invalid ACL specified
+ * ZBADVERSION expected version does not match actual version.
+ * \param data the data that will be passed to the completion routine when 
+ * the function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ */
+ZOOAPI int zoo_aset_acl(zhandle_t *zh, const char *path, int version, 
+        struct ACL_vector *acl, void_completion_t, const void *data);
+
+/**
+ * \brief return an error string.
+ * 
+ * \param return code
+ * \return string corresponding to the return code
+ */
+ZOOAPI const char* zerror(int c);
+
+/**
+ * \brief specify application credentials.
+ * 
+ * The application calls this function to specify its credentials for purposes
+ * of authentication. The server will use the security provider specified by 
+ * the scheme parameter to authenticate the client connection. If the 
+ * authentication request has failed:
+ * - the server connection is dropped
+ * - the watcher is called with the AUTH_FAILED_STATE value as the state 
+ * parameter.
+ * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
+ * \param scheme the id of authentication scheme. Natively supported:
+ * "digest" password-based authentication
+ * \param cert application credentials. The actual value depends on the scheme.
+ * \param certLen the length of the data parameter
+ * \param completion the routine to invoke when the request completes. One of 
+ * the following result codes may be passed into the completion callback:
+ * ZOK operation completed successfully
+ * ZAUTHFAILED authentication failed 
+ * \param data the data that will be passed to the completion routine when the 
+ * function completes.
+ * \return ZOK on success or one of the following errcodes on failure:
+ * ZBADARGUMENTS - invalid input parameters
+ * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
+ * ZSYSTEMERROR - a system error occured
+ */
+ZOOAPI int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert, 
+	int certLen, void_completion_t completion, const void *data);
+
+/**
+ * \brief checks if the current zookeeper connection state can't be recovered.
+ * 
+ *  The application must close the zhandle and try to reconnect.
+ * 
+ * \param zh the zookeeper handle (see \ref zookeeper_init)
+ * \return ZINVALIDSTATE if connection is unrecoverable
+ */
+ZOOAPI int is_unrecoverable(zhandle_t *zh);
+
+/**
+ * \brief sets the debugging level for the library 
+ */
+ZOOAPI void zoo_set_debug_level(ZooLogLevel logLevel);
+
+/**
+ * \brief enable/disable quorum endpoint order randomization
+ * 
+ * If passed a non-zero value, will make the client connect to quorum peers
+ * in the order as specified in the zookeeper_init() call.
+ * A zero value causes zookeeper_init() to permute the peer endpoints
+ * which is good for more even client connection distribution among the 
+ * quorum peers.
+ */
+ZOOAPI void zoo_deterministic_conn_order(int yesOrNo);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ZOOKEEPER_H_*/
diff --git a/zookeeper/c/src/cli.c b/zookeeper/c/src/cli.c
new file mode 100644
index 000000000..20106e789
--- /dev/null
+++ b/zookeeper/c/src/cli.c
@@ -0,0 +1,463 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <zookeeper.h>
+#include <proto.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <time.h>
+
+#ifdef YCA
+#include <yca/yca.h>
+#endif
+
+#define _LL_CAST_ (long long)
+
+static zhandle_t *zh;
+static clientid_t myid;
+static const char *clientIdFile = 0;
+struct timeval startTime;
+
+static int to_send=0;
+static int sent=0;
+static int recvd=0;
+
+int64_t ntohll(int64_t le)
+{
+	return le;
+}
+
+static int shutdownThisThing=0;
+
+void watcher(void *v, int type, int state, const char *path)
+{
+	fprintf(stderr,"Watcher %d state = %d for %s\n", type, state, (path ? path: "null"));
+	if (type == SESSION_EVENT) {
+		if (state == CONNECTED_STATE) {
+			const clientid_t *id = zoo_client_id(zh);
+			if (myid.client_id == 0|| myid.client_id != id->client_id) {
+				myid = *id;
+				fprintf(stderr, "Got a new id: %llx\n", _LL_CAST_ ntohll(myid.client_id));
+				if (clientIdFile) {
+					FILE *fh = fopen(clientIdFile, "w");
+					if (!fh) {
+						perror(clientIdFile);
+					} else {
+						fwrite(&myid, sizeof(myid), 1, fh);
+						fclose(fh);
+					}
+				}
+			}
+		} else if(state == AUTH_FAILED_STATE) {
+			fprintf(stderr, "Authentication failure. Shutting down...\n");
+			zookeeper_close(zh);
+			shutdownThisThing=2;
+		} else if(state == EXPIRED_SESSION_STATE) {
+			fprintf(stderr, "Session expired. Shutting down...\n");
+			zookeeper_close(zh);
+			shutdownThisThing=2;
+		}
+	}
+}
+
+void dumpStat(const struct Stat *stat)
+{
+	char tctimes[40];
+	char tmtimes[40];
+	time_t tctime;
+	time_t tmtime;
+
+	if (!stat) {
+		fprintf(stderr,"null\n");
+		return;
+	}
+	tctime = stat->ctime/1000;
+	tmtime = stat->mtime/1000;
+	fprintf(stderr, "\tctime = %s\tczxid=%llx\n"
+	"\tmtime=%s\tmzxid=%llx\n"
+	"\tversion=%x\taversion=%x\n"
+	"\tephemeralOwner = %llx\n",
+	ctime_r(&tctime, tctimes), _LL_CAST_ stat->czxid, ctime_r(&tmtime, tmtimes), _LL_CAST_ stat->mzxid,
+	stat->version, stat->aversion,
+	_LL_CAST_ ntohll(stat->ephemeralOwner));
+}
+
+void my_string_completion(int rc, const char *name, const void *data)
+{
+	fprintf(stderr, "[%s]: rc = %d\n", (char*)(data==0?"null":data), rc);
+	if (!rc) {
+		fprintf(stderr, "\tname = %s\n", name);
+	}
+}
+
+void my_data_completion(int rc, const char *value, int value_len,
+        const struct Stat *stat, const void *data)
+{
+	struct timeval tv;
+	int sec;
+	int usec;
+	gettimeofday(&tv, 0);
+	sec = tv.tv_sec - startTime.tv_sec;
+	usec = tv.tv_usec - startTime.tv_usec;
+	fprintf(stderr, "time = %d msec\n", sec*1000 + usec/1000);
+	fprintf(stderr, "%s: rc = %d\n", (char*)data, rc);
+	if (value) {
+		fprintf(stderr, " value_len = %d\n", value_len);
+		write(2, value, value_len);
+	}
+	fprintf(stderr, "\nStat:\n");
+	dumpStat(stat);
+	free((void*)data);
+}
+
+void my_silent_data_completion(int rc, const char *value, int value_len,
+        const struct Stat *stat, const void *data) 
+{
+//    char buf[value_len+1];
+//    if(value){
+//        strncpy(buf,value,value_len);buf[value_len]=0;
+//    }
+//    fprintf(stderr, "Data completion: %s=\n[%s] rc = %d\n",(char*)data,
+//            value?buf:"null", rc);
+    recvd++;
+    fprintf(stderr, "Data completion %s rc = %d\n",(char*)data,rc);
+    free((void*)data);
+    if(recvd==to_send){
+        fprintf(stderr,"Recvd %d responses for %d requests sent\n",recvd,to_send);
+    }
+}
+
+void my_strings_completion(int rc, const struct String_vector *strings,
+        const void *data)
+{
+	struct timeval tv;
+	int sec;
+	int usec;
+	int i;
+
+	gettimeofday(&tv, 0);
+	sec = tv.tv_sec - startTime.tv_sec;
+	usec = tv.tv_usec - startTime.tv_usec;
+	fprintf(stderr, "time = %d msec\n", sec*1000 + usec/1000);
+	fprintf(stderr, "%s: rc = %d\n", (char*)data, rc);
+	if (strings)
+		for (i=0; i < strings->count; i++) {
+			fprintf(stderr, "\t%s\n", strings->data[i]);
+		}
+	free((void*)data);
+	gettimeofday(&tv, 0);
+	sec = tv.tv_sec - startTime.tv_sec;
+	usec = tv.tv_usec - startTime.tv_usec;
+	fprintf(stderr, "time = %d msec\n", sec*1000 + usec/1000);
+}
+
+void my_void_completion(int rc, const void *data)
+{
+	fprintf(stderr, "%s: rc = %d\n", (char*)data, rc);
+	free((void*)data);
+}
+
+void my_stat_completion(int rc, const struct Stat *stat, const void *data)
+{
+	fprintf(stderr, "%s: rc = %d Stat:\n", (char*)data, rc);
+	dumpStat(stat);
+	free((void*)data);
+}
+
+void my_silent_stat_completion(int rc, const struct Stat *stat,
+        const void *data)
+{
+//    fprintf(stderr, "State completion: [%s] rc = %d\n", (char*)data, rc);
+    sent++;
+    free((void*)data);
+}
+
+static void sendRequest(const char* data)
+{
+    zoo_aset(zh, "/od", data, strlen(data), -1, my_silent_stat_completion,
+            strdup("/od"));
+    zoo_aget(zh, "/od", 1, my_silent_data_completion, strdup("/od"));
+}
+
+void od_completion(int rc, const struct Stat *stat, const void *data)
+{
+    int i;
+    fprintf(stderr, "od command response: rc = %d Stat:\n", rc);
+    dumpStat(stat);
+    // send a whole bunch of requests
+    to_send=40;
+    for(i=0;i<to_send;i++){
+        char buf[4096*16];
+        memset(buf,-1,sizeof(buf)-1);
+        buf[sizeof(buf)]=0;
+        sendRequest(buf);
+    }
+}
+
+int startsWith(const char *line, const char *prefix)
+{
+	int len = strlen(prefix);
+	return strncmp(line, prefix, len) == 0;
+}
+
+void processline(char *line)
+{
+	int rc;
+	if (startsWith(line, "get ")) {
+		line += 4;
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+		gettimeofday(&startTime, 0);
+		rc = zoo_aget(zh, line, 1, my_data_completion, strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (startsWith(line, "set ")) {
+		char *ptr;
+		line += 4;
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+		ptr = strchr(line, ' ');
+		if (!ptr) {
+			fprintf(stderr, "No data found after path\n");
+			return;
+		}
+		*ptr = '\0';
+		ptr++;
+		rc = zoo_aset(zh, line, ptr, strlen(ptr), -1, my_stat_completion,
+				strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (startsWith(line, "ls ")) {
+		line += 3;
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+		gettimeofday(&startTime, 0);
+		rc= zoo_aget_children(zh, line, 1, my_strings_completion, strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (startsWith(line, "create ")) {
+		int flags = 0;
+		line += 7;
+		if (line[0] == '+') {
+			line++;
+			if (line[0] == 'e') {
+				flags |= EPHEMERAL;
+				line++;
+			}
+			if (line[0] == 's') {
+				flags |= SEQUENCE;
+				line++;
+			}
+			line++;
+		}
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+        fprintf(stderr, "Creating [%s] node\n", line);
+		rc = zoo_acreate(zh, line, "new", 3, &OPEN_ACL_UNSAFE, flags,
+				my_string_completion, strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (startsWith(line, "delete ")) {
+		line += 7;
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+		rc = zoo_adelete(zh, line, -1, my_void_completion, strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (startsWith(line, "exists ")) {
+		line += 7;
+		if (line[0] != '/') {
+			fprintf(stderr, "Path must start with /, found: %s\n", line);
+			return;
+		}
+		rc = zoo_aexists(zh, line, 1, my_stat_completion, strdup(line));
+		if (rc) {
+			fprintf(stderr, "Error %d for %s\n", rc, line);
+		}
+	} else if (strcmp(line, "myid") == 0) {
+		printf("session Id = %llx\n", _LL_CAST_ zoo_client_id(zh)->client_id);
+	} else if (startsWith(line, "quit")) {
+		fprintf(stderr, "Quitting...\n");
+		shutdownThisThing=1;
+	}else if (startsWith(line, "od")) {
+	    const char val[]="fire off";
+        fprintf(stderr, "Overdosing...\n");
+        rc = zoo_aset(zh, "/od",val,sizeof(val)-1, -1, od_completion,0);
+        if (rc)
+            fprintf(stderr, "od command failed: %d\n", rc);
+    }
+}
+
+int main(int argc, char **argv)
+{
+#ifndef THREADED
+	fd_set rfds, wfds, efds;
+#endif
+	char buffer[4096];
+	char p[2048];
+#ifdef YCA  
+	char *cert=0;
+	char appId[64];
+#endif
+	int bufoff = 0;
+	FILE *fh;
+
+	if (argc < 2) {
+		fprintf(stderr, "USAGE %s zookeeper_host_list [clientid_file]\n", argv[0]);
+		return 2;
+	}
+	if (argc > 2) {
+		clientIdFile = argv[2];
+		fh = fopen(clientIdFile, "r");
+		if (fh) {
+			fread(&myid, sizeof(myid), 1, fh);
+			fclose(fh);
+		}
+	}
+#ifdef YCA
+	strcpy(appId,"yahoo.example.yca_test");
+	cert = yca_get_cert_once(appId);
+	if(cert!=0){
+	  fprintf(stderr,"Certificate for appid [%s] is [%s]\n",appId,cert);
+	  strncpy(p,cert,sizeof(p)-1);
+	  free(cert);
+	}else{
+	  fprintf(stderr,"Certificate for appid [%s] not found\n",appId);
+	  strcpy(p,"dummy");
+	}
+#else
+	strcpy(p,"dummy");
+#endif
+	zoo_deterministic_conn_order(1);  // enable deterministic order
+	zh = zookeeper_init(argv[1], watcher, 10000, &myid);
+	if (!zh) {
+		return errno;
+	}
+	
+#ifdef YCA
+	if(zoo_add_auth(zh,"yca",p,strlen(p),0,0)!=ZOK)
+		return 2;
+#endif
+
+#ifdef THREADED
+	while(!shutdownThisThing) {
+	    int rc;
+        int len = sizeof(buffer) - bufoff -1;
+        if (len <= 0) {
+            fprintf(stderr, "Can't handle lines that long!\n");
+            exit(2);
+        }
+        rc = read(0, buffer+bufoff, len);
+        if (rc <= 0) {
+            fprintf(stderr, "bye\n");
+            break;
+        }
+        bufoff += rc;
+        buffer[bufoff] = '\0';
+        while (strchr(buffer, '\n')) {
+            char *ptr = strchr(buffer, '\n');
+            *ptr = '\0';
+            processline(buffer);
+            ptr++;
+            memmove(buffer, ptr, strlen(ptr)+1);
+            bufoff = 0;
+        }
+	}
+#else 
+	FD_ZERO(&rfds);
+	FD_ZERO(&wfds);
+	FD_ZERO(&efds);
+	while(!shutdownThisThing) {
+		int fd;
+		int interest;
+		int events;
+		struct timeval tv;
+		int rc;
+		zookeeper_interest(zh, &fd, &interest, &tv);
+		if (fd != -1) {
+			if (interest&ZOOKEEPER_READ) {
+				FD_SET(fd, &rfds);
+			} else {
+				FD_CLR(fd, &rfds);
+			}
+			if (interest&ZOOKEEPER_WRITE) {
+				FD_SET(fd, &wfds);
+			} else {
+				FD_CLR(fd, &wfds);
+			}
+		} else {
+			fd = 0;
+		}
+		FD_SET(0, &rfds);
+		rc = select(fd+1, &rfds, &wfds, &efds, &tv);
+		events = 0;
+		if (FD_ISSET(fd, &rfds)) {
+			events |= ZOOKEEPER_READ;
+		}
+		if (FD_ISSET(fd, &wfds)) {
+			events |= ZOOKEEPER_WRITE;
+		}
+		if (FD_ISSET(0, &rfds)) {
+			int rc;
+			int len = sizeof(buffer) - bufoff -1;
+			if (len <= 0) {
+				fprintf(stderr, "Can't handle lines that long!\n");
+				exit(2);
+			}
+			rc = read(0, buffer+bufoff, len);
+			if (rc <= 0) {
+				fprintf(stderr, "bye\n");
+				break;
+			}
+			bufoff += rc;
+			buffer[bufoff] = '\0';
+			while (strchr(buffer, '\n')) {
+				char *ptr = strchr(buffer, '\n');
+				*ptr = '\0';
+				processline(buffer);
+				ptr++;
+				memmove(buffer, ptr, strlen(ptr)+1);
+				bufoff = 0;
+			}
+		}
+		zookeeper_process(zh, events);
+	}
+#endif
+	if(to_send!=0)
+	    fprintf(stderr,"Recvd %d responses for %d requests sent\n",recvd,sent);
+	if(shutdownThisThing==1)
+		zookeeper_close(zh);
+	return 0;
+}
diff --git a/zookeeper/c/src/mt_adaptor.c b/zookeeper/c/src/mt_adaptor.c
new file mode 100755
index 000000000..cc5aa2621
--- /dev/null
+++ b/zookeeper/c/src/mt_adaptor.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef THREADED
+#define THREADED
+#endif
+
+#define BUILD_LIB
+#define _GNU_SOURCE
+#include "zk_adaptor.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+#include <signal.h>
+#include <sys/select.h>
+
+
+void lock_buffer_list(buffer_head_t *l)
+{
+    pthread_mutex_lock(&l->lock);
+}
+void unlock_buffer_list(buffer_head_t *l)
+{
+    pthread_mutex_unlock(&l->lock);
+}
+void lock_completion_list(completion_head_t *l)
+{
+    pthread_mutex_lock(&l->lock);
+}
+void unlock_completion_list(completion_head_t *l)
+{
+    pthread_cond_broadcast(&l->cond);
+    pthread_mutex_unlock(&l->lock);
+}
+struct sync_completion *alloc_sync_completion(void)
+{
+    struct sync_completion *sc = (struct sync_completion*)calloc(1, sizeof(struct sync_completion));
+    if (sc) {
+       pthread_cond_init(&sc->cond, 0); 
+    }
+    return sc;
+}
+int wait_sync_completion(struct sync_completion *sc)
+{
+    pthread_mutex_lock(&sc->lock);
+    while (!sc->complete) {
+        pthread_cond_wait(&sc->cond, &sc->lock);
+    }
+    pthread_mutex_unlock(&sc->lock);
+    return 0;
+}
+
+void free_sync_completion(struct sync_completion *sc)
+{
+    free(sc);
+}
+
+void notify_sync_completion(struct sync_completion *sc)
+{
+    pthread_mutex_lock(&sc->lock);
+    sc->complete = 1;
+    pthread_cond_broadcast(&sc->cond);
+    pthread_mutex_unlock(&sc->lock);
+}
+
+int process_async(int outstanding_sync)
+{
+    return 0;
+}
+struct adaptor_threads {
+    pthread_t io;
+    pthread_t completion;
+};
+
+void *do_io(void *);
+void *do_completion(void *);
+
+int adaptor_init(zhandle_t *zh)
+{
+    struct adaptor_threads *adaptor_threads = calloc(1, sizeof(*adaptor_threads)); 
+    if (!adaptor_threads) {
+        return -1;
+    }
+    zh->adaptor_priv = adaptor_threads;
+    pthread_create(&adaptor_threads->io, 0, do_io, zh);
+    pthread_create(&adaptor_threads->completion, 0, do_completion, zh);
+    return 0;
+}
+
+void adaptor_finish(zhandle_t *zh)
+{
+    struct adaptor_threads *adaptor_threads = zh->adaptor_priv;
+      
+    if (zh->state >= 0) {
+        fprintf(stderr, "Forcibly setting state to CLOSED\n");
+        zh->state = -1;
+    }
+    pthread_kill(adaptor_threads->io, SIGUSR1);
+    pthread_mutex_lock(&zh->completions_to_process.lock);
+    pthread_cond_broadcast(&zh->completions_to_process.cond);
+    pthread_mutex_unlock(&zh->completions_to_process.lock);
+    pthread_join(adaptor_threads->io, 0);
+    pthread_join(adaptor_threads->completion, 0);
+}
+
+int adaptor_send_queue(zhandle_t *zh, int timeout)
+{
+    struct adaptor_threads *adaptor_threads = zh->adaptor_priv;
+    pthread_kill(adaptor_threads->io, SIGUSR1);
+    return 0;
+}
+
+static void nothing(int num) {}
+
+/* These two are declared here because we will run the event loop
+ * and not the client */
+int zookeeper_interest(zhandle_t *zh, int *fd, int *interest,
+        struct timeval *tv);
+int zookeeper_process(zhandle_t *zh, int events);
+
+
+void *do_io(void *v)
+{
+    zhandle_t *zh = (zhandle_t*)v;
+    int fd;
+    int interest;
+    struct timeval tv;
+    fd_set rfds;
+    fd_set wfds;
+    fd_set efds;
+    sigset_t nosigusr1;
+    sigset_t sigusr1;
+    struct timespec timeout;
+    sigemptyset(&nosigusr1);
+    sigaddset(&nosigusr1, SIGUSR1);
+    sigemptyset(&sigusr1);
+    pthread_sigmask(SIG_SETMASK, &nosigusr1, 0);
+    signal(SIGUSR1, nothing);
+    FD_ZERO(&rfds);
+    FD_ZERO(&wfds);
+    FD_ZERO(&efds);
+    while(zh->state >= 0) {
+        int result;
+        zookeeper_interest(zh, &fd, &interest, &tv);
+        if (fd != -1) {
+            if (interest&ZOOKEEPER_READ) {
+                    FD_SET(fd, &rfds);
+            } else {
+                    FD_CLR(fd, &rfds);
+            }
+            if (interest&ZOOKEEPER_WRITE) {
+                    FD_SET(fd, &wfds);
+            } else {
+                    FD_CLR(fd, &wfds);
+            }
+        }
+        timeout.tv_sec = tv.tv_sec;
+        timeout.tv_nsec = tv.tv_usec*1000;
+        result = pselect((fd == -1 ? 0 : fd+1), &rfds, &wfds, &efds, &timeout, &sigusr1);
+        interest = 0;
+        if (fd != -1) {
+            if (FD_ISSET(fd, &rfds)) {
+                interest |= ZOOKEEPER_READ;
+            }
+            if (FD_ISSET(fd, &wfds)) {
+                interest |= ZOOKEEPER_WRITE;
+            }
+        }
+        result = zookeeper_process(zh, interest);
+    }
+    return 0;
+}
+
+void *do_completion(void *v)
+{
+    zhandle_t *zh = v;
+    while(zh->state >= 0) {
+        pthread_mutex_lock(&zh->completions_to_process.lock);
+                while(!zh->completions_to_process.head && zh->state >= 0) {
+            pthread_cond_wait(&zh->completions_to_process.cond, &zh->completions_to_process.lock);
+        }
+        pthread_mutex_unlock(&zh->completions_to_process.lock);
+        process_completions(zh);
+    }
+    return 0;
+}
+
+int inc_nesting_level(nesting_level_t* nl,int i)
+{
+    int v;
+    pthread_mutex_lock(&nl->lock);
+    nl->level+=(i<0?-1:(i>0?1:0));
+    v=nl->level;
+    pthread_mutex_unlock(&nl->lock);
+    return v;
+}
diff --git a/zookeeper/c/src/recordio.c b/zookeeper/c/src/recordio.c
new file mode 100755
index 000000000..e752a025a
--- /dev/null
+++ b/zookeeper/c/src/recordio.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <recordio.h>
+#include <string.h>
+#include <stdio.h>
+
+void deallocate_String(char **s)
+{
+    if (*s)
+        free(*s);
+    *s = 0;
+}
+
+void deallocate_Buffer(struct buffer *b)
+{
+    if (b->buff)
+        free(b->buff);
+    b->buff = 0;
+}
+
+struct buff_struct {
+    int len;
+    int off;
+    char *buffer;
+};
+
+static int resize_buffer(struct buff_struct *s, int newlen)
+{
+    char *buffer= NULL;
+    while (s->len < newlen) {
+        s->len *= 2;
+    }
+    buffer = realloc(s->buffer, s->len);
+    if (!buffer) {
+        s->buffer = 0;
+        return -ENOMEM;
+    }
+    s->buffer = buffer;
+    return 0;
+}
+
+int oa_start_record(struct oarchive *oa, const char *tag)
+{
+    return 0;
+}
+int oa_end_record(struct oarchive *oa, const char *tag)
+{
+    return 0;
+}
+int oa_serialize_int(struct oarchive *oa, const char *tag, const int *d)
+{
+    struct buff_struct *priv = oa->priv;
+    int i = htonl(*d);
+    if ((priv->len - priv->off) < sizeof(i)) {
+        int rc = resize_buffer(priv, priv->len + sizeof(i));
+        if (rc < 0) return rc;
+    }
+    memcpy(priv->buffer+priv->off, &i, sizeof(i));
+    priv->off+=sizeof(i);
+    return 0;
+}
+int64_t htonll(int64_t v)
+{
+    //int64_t orig_v = v;
+    int i = 0;
+    char *s = (char *)&v;
+    if (htonl(1) == 1) {
+        return v;
+    }
+    for (i = 0; i < 4; i++) {
+        int tmp = s[i];
+        s[i] = s[8-i-1];
+        s[8-i-1] = tmp;
+    }
+
+    //fprintf(stderr, "input to htonll: %lld, output to htonll: %lld\n", orig_v, v);
+    return v;
+}
+
+int oa_serialize_long(struct oarchive *oa, const char *tag, const long long *d)
+{
+    const long long i = htonll(*d);
+    struct buff_struct *priv = oa->priv;
+    if ((priv->len - priv->off) < sizeof(i)) {
+        int rc = resize_buffer(priv, priv->len + sizeof(i));
+        if (rc < 0) return rc;
+    }
+    memcpy(priv->buffer+priv->off, &i, sizeof(i));
+    priv->off+=sizeof(i);
+    return 0;
+}
+int oa_start_vector(struct oarchive *oa, const char *tag, const int *count)
+{
+    return oa_serialize_int(oa, tag, count);
+}
+int oa_end_vector(struct oarchive *oa, const char *tag)
+{
+    return 0;
+}
+int oa_serialize_bool(struct oarchive *oa, const char *name, const int *i)
+{
+    //return oa_serialize_int(oa, name, i);
+    struct buff_struct *priv = oa->priv;
+    if ((priv->len - priv->off) < 1) {
+        int rc = resize_buffer(priv, priv->len + 1);
+        if (rc < 0)
+            return rc;
+    }
+    priv->buffer[priv->off] = (*i == 0 ? '\0' : '\1');
+    priv->off++;
+    return 0;
+}
+static const int negone = -1;
+int oa_serialize_buffer(struct oarchive *oa, const char *name,
+        const struct buffer *b)
+{
+    struct buff_struct *priv = oa->priv;
+    int rc;
+    if (!b) {
+        return oa_serialize_int(oa, "len", &negone);
+    }
+    rc = oa_serialize_int(oa, "len", &b->len);
+    if (rc < 0)
+        return rc;
+    if ((priv->len - priv->off) < b->len) {
+        rc = resize_buffer(priv, priv->len + b->len);
+        if (rc < 0)
+            return rc;
+    }
+    memcpy(priv->buffer+priv->off, b->buff, b->len);
+    priv->off += b->len;
+    return 0;
+}
+int oa_serialize_string(struct oarchive *oa, const char *name, char **s)
+{
+    struct buff_struct *priv = oa->priv;
+    int len;
+    int rc;
+    if (!*s) {
+        oa_serialize_int(oa, "len", &negone);
+        return 0;
+    }
+    len = strlen(*s);
+    rc = oa_serialize_int(oa, "len", &len);
+    if (rc < 0)
+        return rc;
+    if ((priv->len - priv->off) < len) {
+        rc = resize_buffer(priv, priv->len + len);
+        if (rc < 0)
+            return rc;
+    }
+    memcpy(priv->buffer+priv->off, *s, len);
+    priv->off += len;
+    return 0;
+}
+int ia_start_record(struct iarchive *ia, const char *tag)
+{
+    return 0;
+}
+int ia_end_record(struct iarchive *ia, const char *tag)
+{
+    return 0;
+}
+int ia_deserialize_int(struct iarchive *ia, const char *tag, int *count)
+{
+    struct buff_struct *priv = ia->priv;
+    if ((priv->len - priv->off) < sizeof(*count)) {
+        return -E2BIG;
+    }
+    memcpy(count, priv->buffer+priv->off, sizeof(*count));
+    priv->off+=sizeof(*count);
+    *count = ntohl(*count);
+    return 0;
+}
+
+int ia_deserialize_long(struct iarchive *ia, const char *tag, long long *count)
+{
+    struct buff_struct *priv = ia->priv;
+    long long v = 0;
+    if ((priv->len - priv->off) < sizeof(*count)) {
+        return -E2BIG;
+    }
+    memcpy(count, priv->buffer+priv->off, sizeof(*count));
+    priv->off+=sizeof(*count);
+    v = htonll(*count); // htonll and  ntohll do the same
+    *count = v;
+    return 0;
+}
+int ia_start_vector(struct iarchive *ia, const char *tag, int *count)
+{
+    return ia_deserialize_int(ia, tag, count);
+}
+int ia_end_vector(struct iarchive *ia, const char *tag)
+{
+    return 0;
+}
+int ia_deserialize_bool(struct iarchive *ia, const char *name, int *v)
+{
+    struct buff_struct *priv = ia->priv;
+    //fprintf(stderr, "Deserializing bool %d\n", priv->off);
+    //return ia_deserialize_int(ia, name, v);
+    if ((priv->len - priv->off) < 1) {
+        return -E2BIG;
+    }
+    *v = priv->buffer[priv->off];
+    priv->off+=1;
+    //fprintf(stderr, "Deserializing bool end %d\n", priv->off);
+    return 0;
+}
+int ia_deserialize_buffer(struct iarchive *ia, const char *name,
+        struct buffer *b)
+{
+    struct buff_struct *priv = ia->priv;
+    int rc = ia_deserialize_int(ia, "len", &b->len);
+    if (rc < 0)
+        return rc;
+    if ((priv->len - priv->off) < b->len) {
+        return -E2BIG;
+    }
+    b->buff = malloc(b->len);
+    if (!b->buff) {
+        return -ENOMEM;
+    }
+    memcpy(b->buff, priv->buffer+priv->off, b->len);
+    priv->off += b->len;
+    return 0;
+}
+int ia_deserialize_string(struct iarchive *ia, const char *name, char **s)
+{
+    struct buff_struct *priv = ia->priv;
+    int len;
+    int rc = ia_deserialize_int(ia, "len", &len);
+    if (rc < 0)
+        return rc;
+    if ((priv->len - priv->off) < len) {
+        return -E2BIG;
+    }
+    *s = malloc(len+1);
+    if (!*s) {
+        return -ENOMEM;
+    }
+    memcpy(*s, priv->buffer+priv->off, len);
+    (*s)[len] = '\0';
+    priv->off += len;
+    return 0;
+}
+
+static struct iarchive ia_default = { .start_record = ia_start_record,
+        .end_record = ia_end_record, .start_vector = ia_start_vector,
+        .end_vector = ia_end_vector, .deserialize_Bool = ia_deserialize_bool,
+        .deserialize_Int = ia_deserialize_int,
+        .deserialize_Buffer = ia_deserialize_buffer,
+        .deserialize_String = ia_deserialize_string,
+        .deserialize_Long = ia_deserialize_long };
+
+static struct oarchive oa_default = { .start_record = oa_start_record,
+        .end_record = oa_end_record, .start_vector = oa_start_vector,
+        .end_vector = oa_end_vector, .serialize_Bool = oa_serialize_bool,
+        .serialize_Int = oa_serialize_int,
+        .serialize_Buffer = oa_serialize_buffer,
+        .serialize_String = oa_serialize_string,
+        .serialize_Long = oa_serialize_long };
+
+struct iarchive *create_buffer_iarchive(char *buffer, int len)
+{
+    struct iarchive *ia = malloc(sizeof(*ia));
+    struct buff_struct *buff = malloc(sizeof(struct buff_struct));
+    if (!ia) return 0;
+    if (!buff) {
+        free(ia);
+        return 0;
+    }
+    *ia = ia_default;
+    buff->off = 0;
+    buff->buffer = buffer;
+    buff->len = len;
+    ia->priv = buff;
+    return ia;
+}
+
+struct oarchive *create_buffer_oarchive()
+{
+    struct oarchive *oa = malloc(sizeof(*oa));
+    struct buff_struct *buff = malloc(sizeof(struct buff_struct));
+    if (!oa) return 0;
+    if (!buff) {
+        free(oa);
+        return 0;
+    }
+    *oa = oa_default;
+    buff->off = 0;
+    buff->buffer = malloc(128);
+    buff->len = 128;
+    oa->priv = buff;
+    return oa;
+}
+
+void close_buffer_iarchive(struct iarchive **ia)
+{
+    free((*ia)->priv);
+    free(*ia);
+    *ia = 0;
+}
+
+void close_buffer_oarchive(struct oarchive **oa, int free_buffer)
+{
+    if (free_buffer) {
+        struct buff_struct *buff = (struct buff_struct *)(*oa)->priv;
+        if (buff->buffer) {
+            free(buff->buffer);
+        }
+    }
+    free((*oa)->priv);
+    free(*oa);
+    *oa = 0;
+}
+
+char *get_buffer(struct oarchive *oa)
+{
+    struct buff_struct *buff = oa->priv;
+    return buff->buffer;
+}
+int get_buffer_len(struct oarchive *oa)
+{
+    struct buff_struct *buff = oa->priv;
+    return buff->off;
+}
diff --git a/zookeeper/c/src/st_adaptor.c b/zookeeper/c/src/st_adaptor.c
new file mode 100755
index 000000000..682735dfb
--- /dev/null
+++ b/zookeeper/c/src/st_adaptor.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define BUILD_LIB
+#include "zk_adaptor.h"
+
+void lock_buffer_list(buffer_head_t *l)
+{
+}
+void unlock_buffer_list(buffer_head_t *l)
+{
+}
+void lock_completion_list(completion_head_t *l)
+{
+}
+void unlock_completion_list(completion_head_t *l)
+{
+}
+struct sync_completion *alloc_sync_completion(void)
+{
+    return (struct sync_completion*)calloc(1, sizeof(struct sync_completion));
+}
+int wait_sync_completion(struct sync_completion *sc)
+{
+    return 0;
+}
+
+void free_sync_completion(struct sync_completion *sc)
+{
+    free(sc);
+}
+
+void notify_sync_completion(struct sync_completion *sc)
+{
+}
+
+int process_async(int outstanding_sync)
+{
+    return outstanding_sync == 0;
+}
+
+int adaptor_init(zhandle_t *zh)
+{
+    return 0;
+}
+
+void adaptor_finish(zhandle_t *zh)
+{}
+
+int flush_send_queue(zhandle_t *, int);
+
+int adaptor_send_queue(zhandle_t *zh, int timeout)
+{
+    return flush_send_queue(zh, timeout);
+}
+
+int inc_nesting_level(nesting_level_t* nl,int i)
+{
+    nl->level+=(i<0?-1:(i>0?1:0));
+    return nl->level;
+}
diff --git a/zookeeper/c/src/zk_adaptor.h b/zookeeper/c/src/zk_adaptor.h
new file mode 100644
index 000000000..fd77cb76f
--- /dev/null
+++ b/zookeeper/c/src/zk_adaptor.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ZK_ADAPTOR_H_
+#define ZK_ADAPTOR_H_
+#include <zookeeper.jute.h>
+#ifdef THREADED
+#include <pthread.h>
+#endif
+#include "zookeeper.h"
+struct _buffer_list;
+struct _completion_list;
+
+typedef struct _buffer_head {
+    struct _buffer_list *head;
+    struct _buffer_list *last;
+#ifdef THREADED
+    pthread_mutex_t lock;
+#endif
+} buffer_head_t;
+
+typedef struct _completion_head {
+    struct _completion_list *head;
+    struct _completion_list *last;
+#ifdef THREADED
+    pthread_cond_t cond;
+    pthread_mutex_t lock;
+#endif
+} completion_head_t;
+
+void lock_buffer_list(buffer_head_t *l);
+void unlock_buffer_list(buffer_head_t *l);
+void lock_completion_list(completion_head_t *l);
+void unlock_completion_list(completion_head_t *l);
+
+struct sync_completion {
+    int rc;
+    union {
+        struct {
+            char *str;
+            int str_len;
+        } str;
+        struct Stat stat;
+        struct {
+            char *buffer;
+            int buff_len;
+            struct Stat stat;
+        } data;
+        struct {
+            struct ACL_vector acl;
+            struct Stat stat;
+        } acl;
+        struct String_vector strs;
+    } u;
+    struct ReplyHeader hdr;
+    int complete;
+#ifdef THREADED
+    pthread_cond_t cond;
+    pthread_mutex_t lock;
+#endif
+};
+
+typedef struct _auth_info {
+    int state; /* 0=>inactive, >0 => active */
+    char* scheme;
+    struct buffer auth;
+    void_completion_t completion;
+    const char* data;
+} auth_info;
+
+/**
+ * This structure represents a packet being read or written.
+ */
+typedef struct _buffer_list {
+    char *buffer;
+    int len; /* This represents the length of sizeof(header) + length of buffer */
+    int curr_offset; /* This is the offset into the header followed by offset into the buffer */
+    struct _buffer_list *next;
+} buffer_list_t;
+
+typedef struct _nesting_level {
+    int level;
+#ifdef THREADED
+    pthread_mutex_t lock;
+#endif
+} nesting_level_t;
+
+int inc_nesting_level(nesting_level_t* nl,int i);
+
+typedef enum {TOP_LEVEL=0, NESTED=1, CLOSE_REQUESTED=2} nested_state;
+
+ struct prime_struct {
+     int32_t len;
+     int32_t protocolVersion;
+     int32_t timeOut;
+     int64_t sessionId;
+     int32_t passwd_len;
+     char passwd[16];
+ }; /* the connect response */
+
+/**
+ * This structure represents the connection to zookeeper.
+ */
+
+struct _zhandle {
+    int fd; /* the descriptor used to talk to zookeeper */
+    char *hostname; /* the hostname of zookeeper */
+    struct sockaddr *addrs; /* the addresses that correspond to the hostname */
+    int addrs_count; /* The number of addresses in the addrs array */
+    watcher_fn watcher; /* the registered watcher */
+    struct timeval last_recv; /* The time (in seconds) that the last message was received */
+    int recv_timeout; /* The maximum amount of time that can go by without 
+     receiving anything from the zookeeper server */
+    buffer_list_t *input_buffer; /* the current buffer being read in */
+    buffer_head_t to_process; /* The buffers that have been read and are ready to be processed. */
+    buffer_head_t to_send; /* The packets queued to send */
+    completion_head_t sent_requests; /* The outstanding requests */
+    completion_head_t completions_to_process; /* completions that are ready to run */
+    int connect_index; /* The index of the address to connect to */
+    clientid_t client_id;
+    long long last_zxid;
+    int outstanding_sync; /* Number of outstanding synchronous requests */
+    struct _buffer_list primer_buffer; /* The buffer used for the handshake at the start of a connection */
+    struct prime_struct primer_storage; /* the connect response */
+    char primer_storage_buffer[40]; /* the true size of primer_storage */
+    int state;
+    void *context;
+    struct _auth_info auth; /* authentication data */
+    /* zookeeper_close is not reentrant because it de-allocates the zhandler. 
+     * This guard variable is used to defer the destruction of zhandle till 
+     * right before top-level API call returns to the caller */
+    nesting_level_t nesting;
+    int close_requested;
+    void *adaptor_priv;
+};
+
+int adaptor_init(zhandle_t *zh);
+void adaptor_finish(zhandle_t *zh);
+struct sync_completion *alloc_sync_completion(void);
+int wait_sync_completion(struct sync_completion *sc);
+void free_sync_completion(struct sync_completion *sc);
+void notify_sync_completion(struct sync_completion *sc);
+int adaptor_send_queue(zhandle_t *zh, int timeout);
+int process_async(int outstanding_sync);
+void process_completions(zhandle_t *zh);
+#ifdef THREADED
+#else
+
+#endif
+#endif /*ZK_ADAPTOR_H_*/
+
diff --git a/zookeeper/c/src/zookeeper.c b/zookeeper/c/src/zookeeper.c
new file mode 100644
index 000000000..5468aeac7
--- /dev/null
+++ b/zookeeper/c/src/zookeeper.c
@@ -0,0 +1,2187 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+#define BUILD_LIB
+#include <zookeeper.h>
+#include <zookeeper.jute.h>
+#include <proto.h>
+#include "zk_adaptor.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <poll.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netdb.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <stdarg.h>
+
+#define LOGSTREAM stderr
+
+const int ZOOKEEPER_WRITE = 1 << 0;
+const int ZOOKEEPER_READ = 1 << 1;
+
+const int EPHEMERAL = 1 << 0;
+const int SEQUENCE = 1 << 1;
+
+const int EXPIRED_SESSION_STATE = -112;
+const int AUTH_FAILED_STATE = -113;
+const int CONNECTING_STATE = 1;
+const int ASSOCIATING_STATE = 2;
+const int CONNECTED_STATE = 3;
+static __attribute__ ((unused)) const char* state2String(int state){
+    switch(state){
+    case 0:
+        return "INITIALIZED_STATE";
+    case 1 /*CONNECTING_STATE*/:
+        return "CONNECTING_STATE";
+    case 2 /*ASSOCIATING_STATE*/:
+        return "ASSOCIATING_STATE";
+    case 3 /*CONNECTED_STATE*/:
+        return "CONNECTED_STATE";
+    case -112 /*EXPIRED_SESSION_STATE*/:
+        return "EXPIRED_SESSION_STATE";
+    case -113 /*AUTH_FAILED_STATE*/:
+        return "AUTH_FAILED_STATE";
+    }
+    return "INVALID_STATE";
+}
+
+const int CREATED_EVENT = 1;
+const int DELETED_EVENT = 2;
+const int CHANGED_EVENT = 3;
+const int CHILD_EVENT = 4;
+const int SESSION_EVENT = -1;
+const int NOTWATCHING_EVENT = -2;
+static __attribute__ ((unused)) const char* watcherEvent2String(int ev){
+    switch(ev){
+    case 0:
+        return "ERROR_EVENT";
+    case 1 /*CREATED_EVENT*/:
+        return "CREATED_EVENT";
+    case 2 /*DELETED_EVENT*/:
+        return "DELETED_EVENT";
+    case 3 /*CHANGED_EVENT*/:
+        return "CHANGED_EVENT";
+    case 4 /*CHILD_EVENT*/:
+        return "CHILD_EVENT";
+    case -1 /*SESSION_EVENT*/:
+        return "SESSION_EVENT";
+    case -2 /*NOTWATCHING_EVENT*/:
+        return "NOTWATCHING_EVENT";
+    }
+    return "INVALID_EVENT";
+}
+
+const int PERM_READ = 1 << 0;
+const int PERM_WRITE = 1 << 1;
+const int PERM_CREATE = 1 << 2;
+const int PERM_DELETE = 1 << 3;
+const int PERM_ADMIN = 1 << 4;
+const int PERM_ALL = 0x3f;
+struct Id ANYONE_ID_UNSAFE = {"world", "anyone"};
+struct Id AUTH_IDS = {"auth", ""};
+struct ACL _OPEN_ACL_UNSAFE_ACL[] = {{0x1f, {"world", "anyone"}}};
+struct ACL _READ_ACL_UNSAFE_ACL[] = {{0x1f, {"world", "anyone"}}};
+struct ACL _CREATOR_ALL_ACL_ACL[] = {{0x1f, {"auth", ""}}};
+struct ACL_vector OPEN_ACL_UNSAFE = { 1, _OPEN_ACL_UNSAFE_ACL};
+struct ACL_vector READ_ACL_UNSAFE = { 1, _READ_ACL_UNSAFE_ACL};
+struct ACL_vector CREATOR_ALL_ACL = { 1, _CREATOR_ALL_ACL_ACL};
+
+#define COMPLETION_VOID 0
+#define COMPLETION_STAT 1
+#define COMPLETION_DATA 2
+#define COMPLETION_STRINGLIST 3
+#define COMPLETION_ACLLIST 4
+#define COMPLETION_STRING 5
+
+/* predefined xid's values recognized as special by the server */
+#define PING_XID -2
+#define AUTH_XID -4
+
+struct blocking_retv {
+    int ready:1;
+    int abandoned:1;
+    int rc;
+};
+struct req {
+    int32_t protocolVersion;
+    int64_t lastZxidSeen;
+    int32_t timeOut;
+    int64_t sessionId;
+    int32_t passwd_len;
+    char passwd[16];
+}; /*the conenct request */
+/* the size of request */
+#define sizeof_req() 44
+
+
+const char*err2string(int err);
+static const char* format_endpoint_info(const struct sockaddr* ep);
+static const char* format_current_endpoint_info(zhandle_t* zh);
+static int add_completion(zhandle_t *zh, int xid, int completion_type, 
+        const void *dc, const void *data, int add_to_front);
+static void dispatch_events_till_ready(zhandle_t *zh, 
+	    struct blocking_retv *ready) __attribute__ ((unused));
+static void api_prolog(zhandle_t* zh);
+static int api_epilog(zhandle_t *zh, int rc);
+int flush_send_queue(zhandle_t*zh, int timeout);
+static int handle_socket_error_msg(zhandle_t *zh, int line, int rc,
+	const char* format,...);
+static void log_message(ZooLogLevel curLevel, int line,const char* funcName,
+	const char* message);
+static const char* format_log_message(const char* format,...);
+static void cleanup_bufs(zhandle_t *zh,int callCompletion,int rc);
+
+static int disable_conn_permute=0; // permute enabled by default
+
+static ZooLogLevel logLevel=LOG_LEVEL_INFO;
+
+#define LOG_ERROR(x) \
+    log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
+#define LOG_WARN(x) if(logLevel>=LOG_LEVEL_WARN) \
+    log_message(LOG_LEVEL_WARN,__LINE__,__func__,format_log_message x)
+#define LOG_INFO(x) if(logLevel>=LOG_LEVEL_INFO) \
+    log_message(LOG_LEVEL_INFO,__LINE__,__func__,format_log_message x)
+#define LOG_DEBUG(x) if(logLevel==LOG_LEVEL_DEBUG) \
+    log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
+
+static void *SYNCHRONOUS_MARKER = (void*)&SYNCHRONOUS_MARKER;
+
+    
+typedef struct _completion_list {
+    int xid;
+    int completion_type; /* one of the COMPLETION_* values */
+    union {
+       void_completion_t void_result;
+       stat_completion_t stat_result;
+       data_completion_t data_result;
+       strings_completion_t strings_result;
+       acl_completion_t acl_result;
+       string_completion_t string_result;
+    } c;
+    const void *data;
+    buffer_list_t *buffer;
+    struct _completion_list *next;
+} completion_list_t;
+
+const void *zoo_get_context(zhandle_t *zh) 
+{
+    return zh->context;
+}
+
+void zoo_set_context(zhandle_t *zh, void *context)
+{
+    if (zh != NULL) {
+        zh->context = context;
+    }
+}
+
+int zoo_recv_timeout(zhandle_t *zh)
+{
+    return zh->recv_timeout;
+}
+
+static void init_auth_info(auth_info *auth)
+{
+	auth->scheme=NULL;
+	auth->auth.buff=NULL;
+	auth->auth.len=0;
+	auth->state=0;
+	auth->completion=0;
+	auth->data=0;
+}
+
+static void free_auth_info(auth_info *auth)
+{
+	if(auth->scheme!=NULL)
+		free(auth->scheme);
+	deallocate_Buffer(&auth->auth);
+	init_auth_info(auth);
+}
+
+int is_unrecoverable(zhandle_t *zh)
+{
+    return (zh->state<0)? ZINVALIDSTATE: ZOK;
+}
+/**
+ * Frees and closes everything associated with a handle,
+ * including the handle itself.
+ */
+static void destroy(zhandle_t *zh)
+{
+    if (zh == NULL) {
+        return;
+    }
+    /* call any outstanding completions with a special error code */
+    cleanup_bufs(zh,1,ZCLOSING);
+	if (zh->hostname != 0) {
+		free(zh->hostname);
+		zh->hostname = NULL;
+	}
+	if (zh->fd != -1) {
+		close(zh->fd);
+		zh->fd = -1;
+		zh->state = 0;
+	}
+	if (zh->addrs != 0) {
+		free(zh->addrs);
+		zh->addrs = NULL;
+	}
+	free_auth_info(&zh->auth);
+	free(zh);
+	zh = NULL;
+}
+
+static void setup_random()
+{
+	int seed;
+	int fd = open("/dev/urandom", O_RDONLY);
+	if (fd == -1) {
+		seed = getpid();
+	} else {
+		read(fd, &seed, sizeof(seed));
+		close(fd);
+	}
+	srandom(seed);
+}
+
+/**
+ * fill in the addrs array of the zookeeper servers in the zhandle. after filling
+ * them in, we will permute them for load balancing.
+ */
+int getaddrs(zhandle_t *zh)
+{
+	struct hostent *he;
+	struct sockaddr *addr;
+	struct sockaddr_in *addr4;
+	struct sockaddr_in6 *addr6;
+	char **ptr;
+	char *hosts = strdup(zh->hostname);
+	char *host;
+	int i;
+	int rc;
+	int alen = 0; /* the allocated length of the addrs array */
+	
+	zh->addrs_count = 0;
+	if (zh->addrs) {
+		free(zh->addrs);
+        zh->addrs = 0;
+	}
+	if (!hosts) {
+		LOG_ERROR(("out of memory"));
+		errno=ENOMEM;
+		return ZSYSTEMERROR;
+	}
+	zh->addrs = 0;
+	host=strtok(hosts, ",");
+	while(host) {
+        char *port_spec = strchr(host, ':');
+        char *end_port_spec;
+        int port;
+        if (!port_spec) {
+            LOG_ERROR(("no port in %s", host));
+            errno=EINVAL;
+            rc=ZBADARGUMENTS;
+            goto fail;
+        }
+        *port_spec = '\0';
+        port_spec++;
+        port = strtol(port_spec, &end_port_spec, 0);
+        if (!*port_spec || *end_port_spec) {
+            LOG_ERROR(("invalid port in %s", host));
+            errno=EINVAL;
+            rc=ZBADARGUMENTS;
+            goto fail;
+        }
+		he = gethostbyname(host);
+		if (!he) {
+			LOG_ERROR(("could not resolve %s", host));
+            errno=EINVAL;
+            rc=ZBADARGUMENTS;
+			goto fail;
+		}
+        
+		/* Setup the address array */
+		for(ptr = he->h_addr_list;*ptr != 0; ptr++) {
+			if (zh->addrs_count == alen) {
+				alen += 16;
+				zh->addrs = realloc(zh->addrs, sizeof(*zh->addrs)*alen);
+				if (zh->addrs == 0) {
+					LOG_ERROR(("out of memory"));
+			        errno=ENOMEM;
+			        rc=ZSYSTEMERROR;
+					goto fail;
+				}
+			}
+			addr = &zh->addrs[zh->addrs_count];
+			addr4 = (struct sockaddr_in*)addr;
+			addr6 = (struct sockaddr_in6*)addr;
+			addr->sa_family = he->h_addrtype;
+			if (addr->sa_family == AF_INET) {
+				addr4->sin_port = htons(port);
+				memset(&addr4->sin_zero, 0, sizeof(addr4->sin_zero));
+				memcpy(&addr4->sin_addr, *ptr, he->h_length);
+				zh->addrs_count++;
+			} else if (addr->sa_family == AF_INET6) {
+				addr6->sin6_port = htons(port);
+				addr6->sin6_scope_id = 0;
+				addr6->sin6_flowinfo = 0;
+				memcpy(&addr6->sin6_addr, *ptr, he->h_length);
+				zh->addrs_count++;
+			} else {
+				LOG_WARN(("skipping unknown address family %x for %s", 
+				        addr->sa_family, zh->hostname)); 
+			}
+		}
+		host = strtok(0, ",");
+	}
+	free(hosts);
+	if(!disable_conn_permute){
+        setup_random();
+    	/* Permute */
+    	for(i = 0; i < zh->addrs_count; i++) {
+    		struct sockaddr *s1 = zh->addrs + random()%zh->addrs_count;
+    		struct sockaddr *s2 = zh->addrs + random()%zh->addrs_count;
+    		if (s1 != s2) {
+    			struct sockaddr t = *s1;
+    			*s1 = *s2;
+    			*s2 = t;
+    		}
+    	}
+	}
+	return ZOK;
+fail:
+	if (zh->addrs) {
+		free(zh->addrs);
+		zh->addrs=0;
+	}
+	if (hosts) {
+		free(hosts);
+	}
+	return rc;	
+}
+
+const clientid_t *zoo_client_id(zhandle_t *zh)
+{
+	return &zh->client_id;
+}
+
+static void null_watcher_fn(void *context, int type, int state,
+        const char *path)
+{
+}
+
+watcher_fn zoo_set_watcher(zhandle_t *zh,watcher_fn newFn)
+{
+    watcher_fn oldWatcher=zh->watcher;
+    if (newFn) {
+       zh->watcher = newFn;
+    } else {
+       zh->watcher = null_watcher_fn;
+    }
+    return oldWatcher;
+}
+
+/**
+ * Create a zookeeper handle associated with the given host and port.
+ */
+zhandle_t *zookeeper_init(const char *host, watcher_fn watcher,
+  int recv_timeout, const clientid_t *clientid)
+{
+    int errnosave;
+	zhandle_t *zh = calloc(1, sizeof(*zh));
+	if (!zh) {
+		return 0;
+	}
+	zh->fd = -1;
+    zh->state = 0;
+    zh->context = NULL;
+    zh->recv_timeout = recv_timeout;
+    if (watcher) {
+	   zh->watcher = watcher;
+    } else {
+       zh->watcher = null_watcher_fn;
+    }
+	zh->hostname = strdup(host);
+	if (zh->hostname == 0) {
+		goto abort;
+	}
+	if(getaddrs(zh)!=0) {
+		goto abort;
+	}
+    zh->connect_index = 0;
+    if (clientid) {
+    	memcpy(&zh->client_id, clientid, sizeof(zh->client_id));
+    } else {
+    	memset(&zh->client_id, 0, sizeof(zh->client_id));
+    }
+    zh->primer_buffer.buffer = zh->primer_storage_buffer;
+    zh->primer_buffer.curr_offset = 0;
+    zh->primer_buffer.len = sizeof(zh->primer_storage_buffer);
+    zh->primer_buffer.next = 0;
+    zh->last_zxid = 0;
+    if (adaptor_init(zh) == -1) {
+        goto abort;
+    }
+	return zh;
+abort:
+    errnosave=errno;
+    destroy(zh);
+    errno=errnosave;
+	return 0;
+}
+
+static buffer_list_t *allocate_buffer(char *buff, int len)
+{
+	buffer_list_t *buffer = calloc(1, sizeof(*buffer));
+	if (buffer == 0) 
+		return 0;
+
+	buffer->len = len==0?sizeof(*buffer):len;
+	buffer->curr_offset = 0;
+	buffer->buffer = buff;
+	buffer->next = 0;
+	return buffer;
+}
+
+static void free_buffer(buffer_list_t *b)
+{
+    if (!b) {
+        return;
+    }
+    if (b->buffer) {
+        free(b->buffer);
+    }
+    free(b);
+}
+
+static buffer_list_t *dequeue_buffer(buffer_head_t *list)
+{
+    buffer_list_t *b;
+    lock_buffer_list(list);
+    b = list->head;
+    if (b) {
+        list->head = b->next;
+        if (!list->head) {
+            assert(b == list->last);
+            list->last = 0;
+        }
+    }
+    unlock_buffer_list(list);
+    return b;
+}
+
+static int remove_buffer(buffer_head_t *list)
+{
+    buffer_list_t *b = dequeue_buffer(list);
+    if (!b) {
+        return 0;
+    }
+    free_buffer(b);
+    return 1;
+}
+
+static void queue_buffer(buffer_head_t *list, buffer_list_t *b, int add_to_front)
+{
+    b->next = 0;
+    lock_buffer_list(list);
+    if (list->head) {
+        assert(list->last);
+        // The list is not empty
+        if (add_to_front) {
+            b->next = list->head;
+            list->head = b;
+        } else {
+            list->last->next = b;
+            list->last = b;
+        }
+	}else{
+        // The list is empty
+        assert(!list->head);
+        list->head = b;
+        list->last = b;
+	}
+    unlock_buffer_list(list);
+}
+
+static int queue_buffer_bytes(buffer_head_t *list, char *buff, int len)
+{
+    buffer_list_t *b  = allocate_buffer(buff,len);
+    if (!b)
+        return ZSYSTEMERROR;
+    queue_buffer(list, b, 0);
+    return ZOK;
+}
+
+static int queue_front_buffer_bytes(buffer_head_t *list, char *buff, int len)
+{
+    buffer_list_t *b  = allocate_buffer(buff,len);
+    if (!b)
+        return ZSYSTEMERROR;
+    queue_buffer(list, b, 1);
+    return ZOK;
+}
+
+static __attribute__ ((unused)) int get_queue_len(buffer_head_t *list)
+{
+    int i;
+    buffer_list_t *ptr;
+    lock_buffer_list(list);
+    ptr = list->head;
+    for (i=0; ptr!=0; ptr=ptr->next, i++)
+        ;
+    unlock_buffer_list(list);
+    return i;
+}
+/* returns:
+ * -1 if send failed, 
+ * 0 if send would block while sending the buffer (or a send was incomplete),
+ * 1 if success
+ */
+static int send_buffer(int fd, buffer_list_t *buff)
+{
+	int len = buff->len;
+	int off = buff->curr_offset;
+	int rc = -1;
+	if (off < 4) {
+		/* we need to send the length at the beginning */
+		int nlen = htonl(len);
+		char *b = (char*)&nlen;
+		rc = send(fd, b + off, sizeof(nlen) - off, 0);
+		if (rc == -1) {
+			if (errno != EAGAIN) {
+				return -1;
+			} else {
+                return 0;
+            }
+		} else {
+			buff->curr_offset  += rc;
+		}
+		off = buff->curr_offset;
+	}
+	if (off >= 4) {
+		/* want off to now represent the offset into the buffer */
+		off -= sizeof(buff->len);
+		rc = send(fd, buff->buffer + off, len - off, 0);
+		if (rc == -1) {
+			if (errno != EAGAIN) {
+				return -1;
+			}
+		} else {
+			buff->curr_offset += rc;
+		}
+	}
+	return buff->curr_offset == len + sizeof(buff->len);
+}
+
+/* returns:
+ * -1 if recv call failed, 
+ * 0 if recv would block,
+ * 1 if success
+ */
+static int recv_buffer(int fd, buffer_list_t *buff)
+{
+	int off = buff->curr_offset;
+    int rc = 0;
+    //fprintf(LOGSTREAM, "rc = %d, off = %d, line %d\n", rc, off, __LINE__);
+                
+	/* if buffer is less than 4, we are reading in the length */
+	if (off < 4) {
+		char *buffer = (char*)&(buff->len);
+		rc = recv(fd, buffer+off, sizeof(int)-off, 0);
+        //fprintf(LOGSTREAM, "rc = %d, off = %d, line %d\n", rc, off, __LINE__);
+        switch(rc) {
+        case 0:
+            errno = EHOSTDOWN;
+        case -1:
+            if (errno == EAGAIN) {
+                return 0;
+            }
+            return -1;
+        default:
+            buff->curr_offset += rc;
+        }
+		off = buff->curr_offset;
+		if (buff->curr_offset == sizeof(buff->len)) {
+			buff->len = ntohl(buff->len);
+			buff->buffer = calloc(1, buff->len);
+		}
+	}
+	if (buff->buffer) {
+		/* want off to now represent the offset into the buffer */
+		off -= sizeof(buff->len);
+		
+		rc = recv(fd, buff->buffer+off, buff->len-off, 0);
+        switch(rc) {
+        case 0:
+            errno = EHOSTDOWN;
+        case -1:
+            if (errno == EAGAIN) {
+                break;
+            }
+            return -1;
+        default:
+            buff->curr_offset += rc;
+        }
+	}
+	return buff->curr_offset == buff->len + sizeof(buff->len);
+}
+
+void free_buffers(buffer_head_t *list)
+{
+    while (remove_buffer(list))
+        ;
+}
+
+void free_completions(zhandle_t *zh,int callCompletion,int rc) 
+{
+    completion_head_t tmp_list;
+    lock_completion_list(&zh->sent_requests);
+    tmp_list = zh->sent_requests;
+    zh->sent_requests.head = 0;
+    zh->sent_requests.last = 0;
+    unlock_completion_list(&zh->sent_requests);
+    while (tmp_list.head) {
+        completion_list_t *cptr = tmp_list.head;
+        
+        tmp_list.head = cptr->next;
+        if (callCompletion) {
+			switch (cptr->completion_type) {
+			case COMPLETION_DATA:
+                LOG_DEBUG(("Calling COMPLETION_DATA rc=%d",rc));
+				cptr->c.data_result(rc, 0, 0, 0, cptr->data);
+				break;
+			case COMPLETION_STAT:
+                LOG_DEBUG(("Calling COMPLETION_STAT rc=%d",rc));
+				cptr->c.stat_result(rc, 0, cptr->data);
+				break;
+			case COMPLETION_STRINGLIST:
+                LOG_DEBUG(("Calling COMPLETION_STRINGLIST rc=%d",rc));
+				cptr->c.strings_result(rc, 0, cptr->data);
+				break;
+			case COMPLETION_STRING:
+                LOG_DEBUG(("Calling COMPLETION_STRING rc=%d",rc));
+				cptr->c.string_result(rc, 0, cptr->data);
+				break;
+			case COMPLETION_ACLLIST:
+                LOG_DEBUG(("Calling COMPLETION_ACLLIST rc=%d",rc));
+				cptr->c.acl_result(rc, 0, 0, cptr->data);
+				break;
+			case COMPLETION_VOID:
+                LOG_DEBUG(("Calling COMPLETION_VOID rc=%d",rc));
+				// We want to skip the ping
+				if (cptr->xid != PING_XID)
+					cptr->c.void_result(rc, cptr->data);
+				break;
+			}
+		}
+        free(cptr);
+    }
+}
+
+static void cleanup_bufs(zhandle_t *zh,int callCompletion,int rc)
+{
+    free_buffers(&zh->to_send);
+    free_buffers(&zh->to_process);
+    free_completions(zh,callCompletion,rc);
+    if (zh->input_buffer && zh->input_buffer != &zh->primer_buffer) {
+        free_buffer(zh->input_buffer);
+        zh->input_buffer = 0;
+    }
+}
+
+static void handle_error(zhandle_t *zh,int rc)
+{
+	close(zh->fd);
+    if (is_unrecoverable(zh)) {
+        LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=%s",
+                state2String(zh->state)));
+        zh->watcher(zh->context, SESSION_EVENT, zh->state, 0);
+    } else if (zh->state == CONNECTED_STATE) {
+        LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=CONNECTING_STATE"));
+        zh->watcher(zh->context, SESSION_EVENT, CONNECTING_STATE, 0);
+    }
+    cleanup_bufs(zh,1,rc);
+	zh->fd = -1;
+    zh->connect_index++;
+    if (!is_unrecoverable(zh)) {
+    	zh->state = 0;
+	}
+}
+
+static int handle_socket_error_msg(zhandle_t *zh, int line, int rc,
+        const char* format, ...)
+{
+    static char buf[1024];
+    va_list va;
+    va_start(va,format);
+    vsnprintf(buf, sizeof(buf)-1,format,va);
+    log_message(LOG_LEVEL_ERROR,line,__func__,
+            format_log_message("Socket [%s] zk retcode=%d, errno=%d(%s): %s",
+            format_current_endpoint_info(zh),rc,errno,strerror(errno),buf));
+	va_end(va);
+	handle_error(zh,rc);
+	return rc;
+}
+
+const char* time_now(){
+    static char now_str[128];
+    struct timeval tv;
+    
+    gettimeofday(&tv,0);
+    //sprintf(now_str,"%ld.%03d",tv.tv_sec,(int)(tv.tv_usec/1000));
+    sprintf(now_str,"%ld.%03d.%03d",tv.tv_sec,(int)(tv.tv_usec/1000),(int)(tv.tv_usec%1000));
+    return now_str;
+}
+
+static void log_message(ZooLogLevel curLevel,int line,const char* funcName,
+	const char* message)
+{
+    static const char* dbgLevelStr[]={"ZOO_INVALID","ZOO_ERROR","ZOO_WARN",
+            "ZOO_INFO","ZOO_DEBUG"};
+    static pid_t pid=0;
+    if(pid==0)pid=getpid();
+    fprintf(LOGSTREAM, "%s:%d:%s@%s@%d: %s\n", time_now(),pid,
+            dbgLevelStr[curLevel],funcName,line,message);
+    fflush(LOGSTREAM);
+}
+
+static const char* format_log_message(const char* format,...)
+{
+    static char buf[2048];
+    va_list va;
+    va_start(va,format);
+    vsnprintf(buf, sizeof(buf)-1,format,va);
+    va_end(va); 
+    return buf;
+}
+
+static void auth_completion_func(int rc, zhandle_t* zh)
+{
+	if(zh==NULL)
+		return;
+	
+	if(rc!=0){
+		LOG_ERROR(("Authentication scheme %s failed. Connection closed.",
+				zh->auth.scheme));
+		zh->state=AUTH_FAILED_STATE;
+	}else{
+		zh->auth.state=1;  // active
+        LOG_INFO(("Authentication scheme %s succeeded", zh->auth.scheme));
+	}
+	// chain call user's completion function
+	if(zh->auth.completion!=0){
+		zh->auth.completion(rc,zh->auth.data);
+		zh->auth.completion=0;
+	}
+}
+
+static int send_auth_info(zhandle_t *zh)
+{	
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = AUTH_XID, .type = SETAUTH_OP};
+    struct AuthPacket req;
+	int rc;
+
+    if(zh->auth.scheme==NULL)
+      return ZOK; // there is nothing to send
+
+    oa = create_buffer_oarchive();
+    req.type=0;   // ignored by the server
+    req.scheme = zh->auth.scheme;
+    req.auth = zh->auth.auth;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_AuthPacket(oa, "req", &req);
+    /* add this buffer to the head of the send queue */
+    rc = rc < 0 ? rc : queue_front_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */   
+    close_buffer_oarchive(&oa, 0);
+    
+    LOG_DEBUG(("Sending auth info request to %s",format_current_endpoint_info(zh)));
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+static int serialize_prime_connect(struct req *req, char* buffer){
+    //this should be the order of serialization
+    int offset = 0;
+    req->protocolVersion = htonl(req->protocolVersion);
+    memcpy(buffer + offset, &req->protocolVersion, sizeof(req->protocolVersion));
+    offset = offset +  sizeof(req->protocolVersion);
+    
+    req->lastZxidSeen = htonll(req->lastZxidSeen);
+    memcpy(buffer + offset, &req->lastZxidSeen, sizeof(req->lastZxidSeen));
+    offset = offset +  sizeof(req->lastZxidSeen);
+    
+    req->timeOut = htonl(req->timeOut);
+    memcpy(buffer + offset, &req->timeOut, sizeof(req->timeOut));
+    offset = offset +  sizeof(req->timeOut);
+    
+    req->sessionId = htonll(req->sessionId);
+    memcpy(buffer + offset, &req->sessionId, sizeof(req->sessionId));
+    offset = offset +  sizeof(req->sessionId);
+    
+    req->passwd_len = htonl(req->passwd_len);
+    memcpy(buffer + offset, &req->passwd_len, sizeof(req->passwd_len));
+    offset = offset +  sizeof(req->passwd_len);
+    
+    memcpy(buffer + offset, req->passwd, sizeof(req->passwd));
+    
+    return 0;
+}
+
+ static int deserialize_prime_response(struct prime_struct *req, char* buffer){
+     //this should be the order of deserialization 
+     int offset = 0;
+     memcpy(&req->len, buffer + offset, sizeof(req->len));
+     offset = offset +  sizeof(req->len);
+     
+     req->len = ntohl(req->len);
+     memcpy(&req->protocolVersion, buffer + offset, sizeof(req->protocolVersion));
+     offset = offset +  sizeof(req->protocolVersion);
+     
+     req->protocolVersion = ntohl(req->protocolVersion);
+     memcpy(&req->timeOut, buffer + offset, sizeof(req->timeOut));
+     offset = offset +  sizeof(req->timeOut);
+     
+     req->timeOut = ntohl(req->timeOut);
+     memcpy(&req->sessionId, buffer + offset, sizeof(req->sessionId));
+     offset = offset +  sizeof(req->sessionId);
+     
+     req->sessionId = htonll(req->sessionId);
+     memcpy(&req->passwd_len, buffer + offset, sizeof(req->passwd_len));
+     offset = offset +  sizeof(req->passwd_len);
+     
+     req->passwd_len = ntohl(req->passwd_len);
+     memcpy(req->passwd, buffer + offset, sizeof(req->passwd));
+     return 0;
+ }
+
+static int prime_connection(zhandle_t *zh)
+{
+    int rc;
+     char buffer_req[sizeof_req()]; /*this is the size of buffer to serialize req into*/
+     int len = sizeof(buffer_req);
+     int hlen = 0;
+     struct req req;
+    req.protocolVersion = 0;
+     req.sessionId = zh->client_id.client_id;
+     req.passwd_len = sizeof(req.passwd);
+    memcpy(req.passwd, zh->client_id.passwd, sizeof(zh->client_id.passwd));
+     req.timeOut = zh->recv_timeout;
+     req.lastZxidSeen = zh->last_zxid;
+     hlen = htonl(len);
+   /* We are running fast and loose here, but this string should fit in the initial buffer! */
+     rc=send(zh->fd, &hlen, sizeof(len), 0);
+     serialize_prime_connect(&req, buffer_req);
+     rc=rc<0?rc:send(zh->fd, buffer_req, len, 0);
+    if(rc<0){
+        return handle_socket_error_msg(zh,__LINE__,ZCONNECTIONLOSS,
+                "failed to send a handshake packet: %s",strerror(errno));
+    }
+    zh->state = ASSOCIATING_STATE;
+    
+    zh->input_buffer = &zh->primer_buffer;
+    /* This seems a bit weird to to set the offset to 4, but we already have a
+     * length, so we skip reading the length (and allocating the buffer) by
+     * saying that we are already at offset 4 */
+    zh->input_buffer->curr_offset = 4;
+    
+    return ZOK;
+}
+
+static int xid = -1;
+
+static int get_xid()
+{
+    if (xid == -1) {
+        xid = time(0);
+    }
+    return xid++;
+}
+static inline int calculate_interval(const struct timeval *start, 
+        const struct timeval *end)
+{
+    int interval;
+    struct timeval i = *end;
+    i.tv_sec -= start->tv_sec;
+    i.tv_usec -= start->tv_usec;
+    interval = i.tv_sec * 1000 + (i.tv_usec/1000);
+    return interval;
+}
+
+static struct timeval get_timeval(int interval)
+{
+    struct timeval tv;
+    if (interval < 0) {
+        interval = 0;
+    }
+    tv.tv_sec = interval/1000;
+    tv.tv_usec = (interval%1000)*1000;
+    return tv;
+}
+
+ static int add_void_completion(zhandle_t *zh, int xid, void_completion_t dc,
+	 const void *data);
+ static int add_string_completion(zhandle_t *zh, int xid,
+	 string_completion_t dc, const void *data);
+
+ int zookeeper_interest(zhandle_t *zh, int *fd, int *interest,
+	 struct timeval *tv)
+{
+	if(zh==0 || fd==0 ||interest==0 || tv==0)
+		return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    api_prolog(zh);
+    *fd = zh->fd;
+    *interest = 0;
+    tv->tv_sec = 0;
+    tv->tv_usec = 0;
+    if (*fd == -1) {
+        if (zh->connect_index == zh->addrs_count) {
+            /* Wait a bit before trying again so that we don't spin */
+            zh->connect_index = 0;
+        }else {
+            int rc;
+        	int on = 1;
+            
+            zh->fd = socket(PF_INET, SOCK_STREAM, 0);
+            setsockopt(zh->fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(int));
+            fcntl(zh->fd, F_SETFL, O_NONBLOCK|fcntl(zh->fd, F_GETFL, 0));
+            rc = connect(zh->fd, &zh->addrs[zh->connect_index],
+                    sizeof(struct sockaddr));
+            if (rc == -1) {
+                if (errno == EWOULDBLOCK || errno == EINPROGRESS)
+                    zh->state = CONNECTING_STATE;
+                else
+                    return api_epilog(zh,handle_socket_error_msg(zh,__LINE__,
+                            ZCONNECTIONLOSS,"connect() call failed"));
+            } else {
+                if((rc=prime_connection(zh))!=0)
+                    return api_epilog(zh,rc);
+
+                LOG_INFO(("Initiated connection to server [%s]", 
+                		format_endpoint_info(&zh->addrs[zh->connect_index])));
+            }
+        }
+        *fd = zh->fd;
+        *tv = get_timeval(zh->recv_timeout/3);
+        gettimeofday(&zh->last_recv,0);
+    }
+	if (zh->fd != -1) {
+        struct timeval now;
+		int idle_interval;
+        int to;
+        gettimeofday(&now, 0);
+        idle_interval = calculate_interval(&zh->last_recv, &now);
+		// We only allow 1/3 of our timeout time to expire before sending
+		// a PING
+        if (!zh->sent_requests.head) {
+            to = zh->recv_timeout/3 - idle_interval;
+            if (to <= 0) {
+                int rc;
+                struct oarchive *oa = create_buffer_oarchive();
+                struct RequestHeader h = { .xid = PING_XID, .type = PING_OP};
+
+                rc = serialize_RequestHeader(oa, "header", &h);
+                rc = rc < 0 ? rc : add_void_completion(zh, h.xid, 0, 0);
+                rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send,
+                        get_buffer(oa), get_buffer_len(oa));
+                close_buffer_oarchive(&oa, 0);
+                if (rc < 0){
+                    LOG_ERROR(("failed to marchall request (zk retcode=%d)",rc));
+                    return api_epilog(zh,ZMARSHALLINGERROR);
+                }
+                LOG_DEBUG(("Sending PING to %s (exceeded idle by %dms)",
+                	format_current_endpoint_info(zh),-to));
+                to = zh->recv_timeout/3;
+            }
+		} else {
+            to = (zh->recv_timeout*2)/3 - idle_interval;
+            if (to <= 0) {
+                // We gotta cut our losses and connect to someone else
+                errno = ETIMEDOUT;               
+                *fd=-1;
+                *interest=0;
+                *tv = get_timeval(to);
+                return api_epilog(zh,handle_socket_error_msg(zh,
+                		__LINE__,ZOPERATIONTIMEOUT,
+                		"connection timed out (exceeded timeout by %dms)",-to));
+            }
+		}
+        *tv = get_timeval(to);
+        *interest = ZOOKEEPER_READ;
+        if (zh->to_send.head || zh->state == CONNECTING_STATE) {
+            *interest |= ZOOKEEPER_WRITE;
+		}
+	}
+    return api_epilog(zh,ZOK);
+}
+
+static int check_events(zhandle_t *zh, int events)
+{
+    if (zh->fd == -1)
+        return ZINVALIDSTATE;
+    if ((events&ZOOKEEPER_WRITE)&&(zh->state == CONNECTING_STATE)) {
+        int rc, error;
+        socklen_t len = sizeof(error);
+        rc = getsockopt(zh->fd, SOL_SOCKET, SO_ERROR, &error, &len);
+        if (rc < 0 || error) {
+            if (rc == 0)
+                errno = error;
+            return handle_socket_error_msg(zh, __LINE__,ZCONNECTIONLOSS,
+            	"server refused to accept the client");
+        }
+        if((rc=prime_connection(zh))!=0)
+            return rc;
+        LOG_INFO(("initiated connection to server [%s]", 
+                format_endpoint_info(&zh->addrs[zh->connect_index])));
+        return ZOK;
+    }
+    if (zh->to_send.head && (events&ZOOKEEPER_WRITE)) {
+        /* make the flush call non-blocking by specifying a 0 timeout */
+        int rc=flush_send_queue(zh,0);
+        if (rc < 0)
+            return handle_socket_error_msg(zh,__LINE__,ZCONNECTIONLOSS,
+            	"failed while flushing send queue");
+	}
+	if (events&ZOOKEEPER_READ) {
+	    int rc;
+		if (zh->input_buffer == 0) {
+			zh->input_buffer = allocate_buffer(0,0);
+		}
+
+		rc = recv_buffer(zh->fd, zh->input_buffer);
+		if (rc < 0) { 
+			return handle_socket_error_msg(zh, __LINE__,ZCONNECTIONLOSS,
+				"failed while receiving a server response");
+		}
+        if (rc > 0) {
+			gettimeofday(&zh->last_recv, 0);
+            if (zh->input_buffer != &zh->primer_buffer) {
+                queue_buffer(&zh->to_process, zh->input_buffer, 0);
+            } else  {
+				//deserialize
+				deserialize_prime_response(&zh->primer_storage, zh->primer_buffer.buffer);
+				/* We are processing the primer_buffer, so we need to finish
+                 * the connection handshake */
+                int64_t oldid = zh->client_id.client_id;
+                int64_t newid = zh->primer_storage.sessionId;
+                if (oldid != 0 && oldid != newid) {
+                    zh->state = EXPIRED_SESSION_STATE;
+					errno = ESTALE;
+                    return handle_socket_error_msg(zh,__LINE__,ZSESSIONEXPIRED,
+                            "session %llx has expired.",oldid);
+                } else {
+                    zh->recv_timeout = zh->primer_storage.timeOut;
+                    zh->client_id.client_id = newid;
+                 
+                    memcpy(zh->client_id.passwd, &zh->primer_storage.passwd, sizeof(zh->client_id.passwd));
+                    zh->state = CONNECTED_STATE;
+                    LOG_INFO(("connected to server [%s] with session id=%llx",
+                            format_endpoint_info(&zh->addrs[zh->connect_index]),newid));
+                    /* send the authentication packet now */
+                    send_auth_info(zh);
+                    LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=CONNECTED_STATE"));
+                    zh->input_buffer = 0; // just in case the watcher calls zookeeper_process() again
+                    zh->watcher(zh->context, SESSION_EVENT, CONNECTED_STATE, 0);
+                }
+			}
+			zh->input_buffer = 0;
+		} 			
+	}
+	return ZOK;
+}
+
+static void api_prolog(zhandle_t* zh)
+{
+    inc_nesting_level(&zh->nesting,1); 
+}
+
+static int api_epilog(zhandle_t *zh,int rc)
+{
+	if(inc_nesting_level(&zh->nesting,-1)==0 && zh->close_requested!=0)
+		zookeeper_close(zh);
+	return rc;
+}
+
+static __attribute__((unused)) void print_completion_queue(zhandle_t *zh)
+{
+    completion_list_t* cptr;
+    
+    if(logLevel<LOG_LEVEL_DEBUG) return;
+        
+    fprintf(LOGSTREAM,"Completion queue: ");
+    if (zh->sent_requests.head==0) {
+        fprintf(LOGSTREAM,"empty\n");
+        return;
+    }
+    
+    cptr=zh->sent_requests.head;
+    while(cptr){
+        fprintf(LOGSTREAM,"%d,",cptr->xid);
+        cptr=cptr->next;
+    }
+    fprintf(LOGSTREAM,"end\n");    
+}
+
+static completion_list_t* create_completion_entry(int xid, int completion_type,
+        const void *dc, const void *data);
+static void queue_completion(completion_head_t *list, completion_list_t *c,
+        int add_to_front);
+
+completion_list_t *dequeue_completion(completion_head_t *list)
+{
+    completion_list_t *cptr;
+    lock_completion_list(list);
+    cptr = list->head;
+    if (cptr) {
+        list->head = cptr->next;
+        if (!list->head) {
+            assert(list->last == cptr);
+            list->last = 0;
+        }
+    }
+    unlock_completion_list(list);
+    return cptr;
+}
+
+void process_completions(zhandle_t *zh)
+{
+    completion_list_t *cptr;
+    while ((cptr = dequeue_completion(&zh->completions_to_process)) != 0) {
+        struct ReplyHeader hdr;
+        buffer_list_t *bptr = cptr->buffer;
+        struct iarchive *ia = create_buffer_iarchive(bptr->buffer,
+                bptr->curr_offset);
+        deserialize_ReplyHeader(ia, "hdr", &hdr);
+        zh->last_zxid = hdr.zxid;
+
+        if (hdr.xid == -1) {
+            int type, state;
+            struct WatcherEvent evt;
+            deserialize_WatcherEvent(ia, "event", &evt);
+            /* We are doing a notification, so there is no pending request */
+            type = evt.type;
+            state = evt.state;
+            /* This is a notification so there aren't any pending requests */
+            LOG_DEBUG(("Calling a watcher for node [%s], event=%s",
+	             (evt.path==NULL?"NULL":evt.path),watcherEvent2String(type)));
+            zh->watcher(zh->context, type, state, evt.path);
+            deallocate_WatcherEvent(&evt);
+        } else {
+            int rc = hdr.err;
+            switch (cptr->completion_type) {
+            case COMPLETION_DATA:
+                LOG_DEBUG(("Calling COMPLETION_DATA rc=%d",rc));
+                if (rc) {
+                    cptr->c.data_result(rc, 0, 0, 0, cptr->data);
+                } else {
+                    struct GetDataResponse res;
+                    deserialize_GetDataResponse(ia, "reply", &res);
+                    cptr->c.data_result(rc, res.data.buff, res.data.len,
+                            &res.stat, cptr->data);
+                    deallocate_GetDataResponse(&res);
+                }
+                break;
+            case COMPLETION_STAT:
+                LOG_DEBUG(("Calling COMPLETION_STAT rc=%d",rc));
+                if (rc) {
+                    cptr->c.stat_result(rc, 0, cptr->data);
+                } else {
+                    struct SetDataResponse res;
+                    deserialize_SetDataResponse(ia, "reply", &res);
+                    cptr->c.stat_result(rc, &res.stat, cptr->data);
+                    deallocate_SetDataResponse(&res);
+                }
+                break;
+            case COMPLETION_STRINGLIST:
+                LOG_DEBUG(("Calling COMPLETION_STRINGLIST rc=%d",rc));
+                if (rc) {
+                    cptr->c.strings_result(rc, 0, cptr->data);
+                } else {
+                    struct GetChildrenResponse res;
+                    deserialize_GetChildrenResponse(ia, "reply", &res);
+                    cptr->c.strings_result(rc, &res.children, cptr->data);
+                    deallocate_GetChildrenResponse(&res);
+                }
+                break;
+            case COMPLETION_STRING:
+                LOG_DEBUG(("Calling COMPLETION_STRING rc=%d",rc));
+                if (rc) {
+                    cptr->c.string_result(rc, 0, cptr->data);
+                } else {
+                    struct CreateResponse res;
+                    deserialize_CreateResponse(ia, "reply", &res);
+                    cptr->c.string_result(rc, res.path, cptr->data);
+                    deallocate_CreateResponse(&res);
+                }
+                break;
+            case COMPLETION_ACLLIST:
+                LOG_DEBUG(("Calling COMPLETION_ACLLIST rc=%d",rc));
+                if (rc) {
+                    cptr->c.acl_result(rc, 0, 0, cptr->data);
+                } else {
+                    struct GetACLResponse res;
+                    deserialize_GetACLResponse(ia, "reply", &res);
+                    cptr->c.acl_result(rc, &res.acl, &res.stat, cptr->data);
+                    deallocate_GetACLResponse(&res);
+                }
+                break;
+            case COMPLETION_VOID:
+                LOG_DEBUG(("Calling COMPLETION_VOID rc=%d",rc));
+                if (hdr.xid == PING_XID) {
+                    // We want to skip the ping
+                } else {
+                    cptr->c.void_result(rc, cptr->data);
+                }
+                break;
+            }
+            free_buffer(cptr->buffer);
+            free(cptr);
+        }
+        close_buffer_iarchive(&ia);
+    }
+}
+
+int zookeeper_process(zhandle_t *zh, int events) 
+{
+    buffer_list_t *bptr;
+    int rc;
+    if (zh==NULL)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    api_prolog(zh);
+    rc = check_events(zh, events);
+    if (rc!=ZOK)
+        return api_epilog(zh, rc);
+
+    while (rc >= 0&& (bptr=dequeue_buffer(&zh->to_process))) {
+		struct ReplyHeader hdr;
+		struct iarchive *ia = create_buffer_iarchive(
+									bptr->buffer, bptr->curr_offset);
+		deserialize_ReplyHeader(ia, "hdr", &hdr);
+		zh->last_zxid = hdr.zxid;
+		
+		if (hdr.xid == -1) {
+            completion_list_t *c = create_completion_entry(-1, -1, 0, 0);
+            c->buffer = bptr;
+            queue_completion(&zh->completions_to_process, c, 0);
+        } else if(hdr.xid == AUTH_XID){
+            /* special handling for the AUTH response as it may come back 
+             * out-of-band */
+            auth_completion_func(hdr.err,zh);
+            free_buffer(bptr);
+            /* authentication completion may change the connection state to 
+             * unrecoverable */
+            if(is_unrecoverable(zh)){
+                handle_error(zh, ZAUTHFAILED);
+                close_buffer_iarchive(&ia);
+                return api_epilog(zh, ZAUTHFAILED);
+            }
+        } else { 
+            int rc = hdr.err;
+            /* Find the request corresponding to the response */
+            completion_list_t *cptr = dequeue_completion(&zh->sent_requests);
+            assert(cptr);
+            /* The requests are going to come back in order */
+            if (cptr->xid != hdr.xid) {
+                close_buffer_iarchive(&ia);
+                free_buffer(bptr);
+                print_completion_queue(zh);
+				LOG_ERROR(("xid %x disappeared!", hdr.xid));
+		    	return api_epilog(zh,ZRUNTIMEINCONSISTENCY);
+			}
+            if (cptr->c.void_result != SYNCHRONOUS_MARKER) {
+                cptr->buffer = bptr;
+                queue_completion(&zh->completions_to_process, cptr, 0);
+            } else if (hdr.xid == PING_XID) {
+                // Nothing to do with a ping response
+            } else {
+                struct sync_completion
+                        *sc = (struct sync_completion*)cptr->data;
+                sc->rc = rc;
+            switch(cptr->completion_type) {
+            case COMPLETION_DATA:
+                if (rc==0) {
+                        struct GetDataResponse res;
+                        int len;
+                	LOG_DEBUG(("Calling COMPLETION_DATA rc=%d",rc));
+                        deserialize_GetDataResponse(ia, "reply", &res);
+                        if (res.data.len <= sc->u.data.buff_len) {
+                            len = res.data.len;
+                        } else {
+                            len = sc->u.data.buff_len;
+                        }
+                        sc->u.data.buff_len = len;
+                        memcpy(sc->u.data.buffer, res.data.buff, len);
+                        sc->u.data.stat = res.stat;
+                        deallocate_GetDataResponse(&res);
+                }
+                break;
+            case COMPLETION_STAT:
+                    if (rc == 0) {
+                        struct SetDataResponse res;
+                LOG_DEBUG(("Calling COMPLETION_STAT rc=%d",rc));
+                        deserialize_SetDataResponse(ia, "reply", &res);
+                        sc->u.stat = res.stat;
+                        deallocate_SetDataResponse(&res);
+                    }
+                break;
+            case COMPLETION_STRINGLIST:
+                    if (rc == 0) {
+                        struct GetChildrenResponse res;
+                LOG_DEBUG(("Calling COMPLETION_STRINGLIST rc=%d",rc));
+                        deserialize_GetChildrenResponse(ia, "reply", &res);
+                        sc->u.strs = res.children;
+                        /* We don't deallocate since we are passing it back */
+                        // deallocate_GetChildrenResponse(&res);
+                    }
+                break;
+            case COMPLETION_STRING:
+                    if (rc == 0) {
+                        struct CreateResponse res;
+                        int len;
+                LOG_DEBUG(("Calling COMPLETION_STRING rc=%d",rc));
+                        deserialize_CreateResponse(ia, "reply", &res);
+                        if (sc->u.str.str_len > strlen(res.path)) {
+                            len = strlen(res.path);
+                        } else {
+                            len = sc->u.str.str_len;
+                        }
+                        memcpy(sc->u.str.str, res.path, len);
+                        sc->u.str.str[len] = '\0';
+                        deallocate_CreateResponse(&res);
+                    }
+                break;
+            case COMPLETION_ACLLIST:
+                    if (rc == 0) {
+                        struct GetACLResponse res;
+                LOG_DEBUG(("Calling COMPLETION_ACLLIST rc=%d",rc));
+                        deserialize_GetACLResponse(ia, "reply", &res);
+                        cptr->c.acl_result(rc, &res.acl, &res.stat, cptr->data);
+                        sc->u.acl.acl = res.acl;
+                        sc->u.acl.stat = res.stat;
+                        /* We don't deallocate since we are passing it back */
+                        //deallocate_GetACLResponse(&res);
+                    }
+                break;
+            case COMPLETION_VOID:
+                LOG_DEBUG(("Calling COMPLETION_VOID rc=%d",rc));
+            	if (hdr.xid == PING_XID) {
+            		// We want to skip the ping
+                } else {
+                	cptr->c.void_result(rc, cptr->data);
+            	}
+                break;
+            }
+                sc->complete = 1;
+                notify_sync_completion(sc);
+                free_buffer(bptr);
+                zh->outstanding_sync--;
+                free(cptr);
+            }
+		}
+
+		close_buffer_iarchive(&ia);
+
+	}
+    if (process_async(zh->outstanding_sync)) {
+        process_completions(zh);
+    }
+	return api_epilog(zh,ZOK);
+}
+
+int zoo_state(zhandle_t *zh)
+{
+    if(zh!=0)
+        return zh->state;
+    return 0;
+}
+
+static completion_list_t* create_completion_entry(int xid, int completion_type, 
+        const void *dc, const void *data)
+{
+    completion_list_t *c = malloc(sizeof(completion_list_t));
+    if (!c) {
+        LOG_ERROR(("out of memory"));
+        return 0;
+    }
+    c->completion_type = completion_type;
+    c->data = data;
+    switch(c->completion_type) {
+    case COMPLETION_VOID:
+        c->c.void_result = (void_completion_t)dc;
+        break;
+    case COMPLETION_STRING:
+        c->c.string_result = (string_completion_t)dc;
+        break;
+    case COMPLETION_DATA:
+        c->c.data_result = (data_completion_t)dc;
+        break;
+    case COMPLETION_STAT:
+        c->c.stat_result = (stat_completion_t)dc;
+        break;
+    case COMPLETION_STRINGLIST:
+        c->c.strings_result = (strings_completion_t)dc;
+        break;
+    case COMPLETION_ACLLIST:
+        c->c.acl_result = (acl_completion_t)dc;
+        break;
+    }
+    c->xid = xid;
+    c->next = 0;
+
+    return c;
+}
+
+static void queue_completion(completion_head_t *list, completion_list_t *c,
+        int add_to_front)
+{
+     c->next = 0;
+    /* appending a new entry to the back of the list */
+    lock_completion_list(list);
+    if (list->last) {
+        assert(list->head);
+        // List is not empty
+        if (!add_to_front) {
+            list->last->next = c;
+            list->last = c;
+        } else {
+            c->next = list->head;
+            list->head = c;
+        }
+    } else {
+        // List is empty
+        assert(!list->head);
+        list->head = c;
+        list->last = c;
+    }
+    unlock_completion_list(list);
+}
+
+static int add_completion(zhandle_t *zh, int xid, int completion_type,
+        const void *dc, const void *data, int add_to_front)
+{
+    completion_list_t *c =create_completion_entry(xid, completion_type, dc,
+            data);
+    if (!c) 
+        return ZSYSTEMERROR;
+    queue_completion(&zh->sent_requests, c, add_to_front);
+    if (dc == SYNCHRONOUS_MARKER) {
+        zh->outstanding_sync++;
+    }
+    return ZOK;
+}
+
+static int add_data_completion(zhandle_t *zh, int xid, data_completion_t dc,
+        const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_DATA, dc, data, 0);
+}
+
+static int add_stat_completion(zhandle_t *zh, int xid, stat_completion_t dc,
+        const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_STAT, dc, data, 0);
+}
+
+static int add_strings_completion(zhandle_t *zh, int xid,
+        strings_completion_t dc, const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_STRINGLIST, dc, data, 0);
+}
+
+static int add_acl_completion(zhandle_t *zh, int xid, acl_completion_t dc,
+        const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_ACLLIST, dc, data, 0);
+}
+
+static int add_void_completion(zhandle_t *zh, int xid, void_completion_t dc,
+        const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_VOID, dc, data, 0);
+}
+
+static int add_string_completion(zhandle_t *zh, int xid,
+        string_completion_t dc, const void *data)
+{
+    return add_completion(zh, xid, COMPLETION_STRING, dc, data, 0);
+}
+
+static void close_completion(int rc, const void *data)
+{
+}
+
+int zookeeper_close(zhandle_t *zh) 
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = CLOSE_OP};
+	int rc;
+
+    if (zh==0)
+        return ZBADARGUMENTS;
+    
+    if (inc_nesting_level(&zh->nesting,0)!=0) {
+		zh->close_requested=1;
+        return ZOK;
+    }
+    if (is_unrecoverable(zh)||zh->fd==-1){
+        LOG_INFO(("Freeing zookeeper resources for session %llx\n",
+                zh->client_id.client_id));
+        rc = ZOK;
+        goto finish;
+    } 
+
+    LOG_INFO(("Closing zookeeper session %llx to [%s]\n",
+            zh->client_id.client_id,format_current_endpoint_info(zh)));
+    oa = create_buffer_oarchive();
+	rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : add_void_completion(zh, h.xid, close_completion, zh);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+    if (rc < 0) {
+        rc = ZMARSHALLINGERROR;
+        goto finish;
+    }
+
+    /* make sure the close request is sent; we set timeout to an arbitrary 
+     * (but reasonable) number of milliseconds since we want the call to block*/
+    rc=adaptor_send_queue(zh, 3000);
+finish:
+    adaptor_finish(zh);
+    destroy(zh);
+    return rc;
+}
+
+int zoo_aget(zhandle_t *zh, const char *path, int watch, data_completion_t dc,
+        const void *data)
+{
+    struct oarchive *oa; 
+    struct RequestHeader h = { .xid = get_xid(), .type = GETDATA_OP};
+    struct GetDataRequest req = { (char*)path, watch };
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa=create_buffer_oarchive();
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_GetDataRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_data_completion(zh, h.xid, dc, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+    
+    LOG_DEBUG(("Sending zoo_aget() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_aset(zhandle_t *zh, const char *path, const char *buffer, int buflen,
+        int version, stat_completion_t dc, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = SETDATA_OP};
+    struct SetDataRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.data.buff = (char*)buffer;
+    req.data.len = buflen;
+    req.version = version;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_SetDataRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_stat_completion(zh, h.xid, dc, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_aset() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_acreate(zhandle_t *zh, const char *path, const char *value,
+        int valuelen, const struct ACL_vector *acl_entries, int ephemeral,
+        string_completion_t completion, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = CREATE_OP };
+    struct CreateRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.flags = ephemeral;
+    req.data.buff = (char*)value;
+    req.data.len = valuelen;
+    if (acl_entries == 0) {
+    	req.acl.count = 0;
+    	req.acl.data = 0;
+    } else {
+    	req.acl = *acl_entries;
+    }
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_CreateRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_string_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+    
+    LOG_DEBUG(("Sending zoo_acreate() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_adelete(zhandle_t *zh, const char *path, int version,
+        void_completion_t completion, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = DELETE_OP};
+    struct DeleteRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.version = version;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_DeleteRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_void_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_adelete() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_aexists(zhandle_t *zh, const char *path, int watch,
+        stat_completion_t completion, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = EXISTS_OP };
+    struct ExistsRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.watch = watch;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_ExistsRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_stat_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_aexists() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_aget_children(zhandle_t *zh, const char *path, int watch,
+        strings_completion_t completion, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = GETCHILDREN_OP};
+    struct GetChildrenRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.watch = watch;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_GetChildrenRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_strings_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_aget_children() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_aget_acl(zhandle_t *zh, const char *path, acl_completion_t completion,
+        const void *data)
+{
+    struct oarchive *oa = create_buffer_oarchive();
+    struct RequestHeader h = { .xid = get_xid(), .type = GETACL_OP};
+    struct GetACLRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_GetACLRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_acl_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_aget_acl() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+int zoo_aset_acl(zhandle_t *zh, const char *path, int version,
+        struct ACL_vector *acl, void_completion_t completion, const void *data)
+{
+    struct oarchive *oa;
+    struct RequestHeader h = { .xid = get_xid(), .type = SETACL_OP};
+    struct SetACLRequest req;
+    int rc;
+    
+    if (zh==0)
+        return ZBADARGUMENTS;
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    oa = create_buffer_oarchive();
+    req.path = (char*)path;
+    req.acl = *acl;
+    req.version = version;
+    rc = serialize_RequestHeader(oa, "header", &h);
+    rc = rc < 0 ? rc : serialize_SetACLRequest(oa, "req", &req);
+    rc = rc < 0 ? rc : add_void_completion(zh, h.xid, completion, data);
+    rc = rc < 0 ? rc : queue_buffer_bytes(&zh->to_send, get_buffer(oa),
+            get_buffer_len(oa));
+    /* We queued the buffer, so don't free it */
+    close_buffer_oarchive(&oa, 0);
+
+    LOG_DEBUG(("Sending zoo_aset_acl() request to %s",format_current_endpoint_info(zh)));
+    /* make a best (non-blocking) effort to send the requests asap */
+    adaptor_send_queue(zh, 0);
+    return (rc < 0)?ZMARSHALLINGERROR:ZOK;
+}
+
+static int dispatch_events(zhandle_t *zh) 
+{
+	int fd;
+	int interest;
+	struct timeval tv;
+    struct pollfd fds;
+	
+	int rc=zookeeper_interest(zh, &fd, &interest, &tv);
+	if(rc<0)
+		return rc;
+	
+    fds.fd = zh->fd;
+    fds.events = POLLIN |((interest&ZOOKEEPER_WRITE)?POLLOUT:0);
+    fds.revents = 0;
+    rc = poll(&fds, 1, tv.tv_sec*1000+tv.tv_usec/1000);
+	if(rc<0)
+	    return ZSYSTEMERROR;
+	
+	interest=0;
+    if (rc >= 0 && fd != -1) {
+        interest = ((fds.revents&POLLIN)?ZOOKEEPER_READ:0) | 
+        	((fds.revents&POLLOUT)?ZOOKEEPER_WRITE:0);
+        // POLLERR is set if there's been an output error
+        interest |= (fds.revents&POLLERR)?ZOOKEEPER_WRITE:0;
+    }
+		
+	return zookeeper_process(zh, interest);
+}
+
+static void dispatch_events_till_ready(zhandle_t *zh,
+        struct blocking_retv *ready)
+{
+    int rc = 0;
+    while(1) {
+        rc=dispatch_events(zh);
+        if (ready->ready) {
+            break;
+        }
+        if (rc < 0) {
+            ready->ready = 1;
+            ready->rc = rc;
+            break;
+        }
+    }   
+}
+
+/* specify timeout of 0 to make the function non-blocking */
+/* timeout is in milliseconds */
+int flush_send_queue(zhandle_t*zh, int timeout)
+{
+    int rc= ZOK;
+    struct timeval started;
+    gettimeofday(&started,0);
+//    fprintf(LOGSTREAM,"send queue length: %d\n",get_queue_len(zh->to_send));
+	// any buffers to send?
+    lock_buffer_list(&zh->to_send);
+    while (zh->to_send.head != 0&& zh->state == CONNECTED_STATE) {
+	    if(timeout!=0){
+	        int elapsed;
+	        struct pollfd fds;
+	        struct timeval now;
+	        gettimeofday(&now,0);
+	        elapsed=calculate_interval(&started,&now);
+            if (elapsed>timeout) {
+                rc = ZOPERATIONTIMEOUT;
+                break;
+            }
+	        fds.fd = zh->fd;
+	        fds.events = POLLOUT;
+	        fds.revents = 0;
+	        rc = poll(&fds, 1, timeout-elapsed);
+            if (rc<=0) {
+                rc = rc==0 ? ZOPERATIONTIMEOUT : ZSYSTEMERROR; /* timed out or an error or POLLERR */
+                break;
+            }
+	    }
+
+        rc = send_buffer(zh->fd, zh->to_send.head);
+		if(rc==0 && timeout==0){
+		    /* send_buffer would block while sending this buffer */
+            rc = ZOK;
+            break;
+        }
+        if (rc < 0) {
+            rc = ZCONNECTIONLOSS;
+            break;
+		}
+
+        if (rc > 0) {
+            unlock_buffer_list(&zh->to_send);
+            remove_buffer(&zh->to_send);
+            lock_buffer_list(&zh->to_send);
+        }
+        rc = ZOK;
+	}
+    unlock_buffer_list(&zh->to_send);
+    return rc;
+}
+
+const char* zerror(int c)
+{
+    switch (c){
+    case ZOK:
+      return "ok";
+    case ZSYSTEMERROR:
+      return "system error";
+    case ZRUNTIMEINCONSISTENCY:
+      return "run time inconsistency";
+    case ZDATAINCONSISTENCY:
+      return "data inconsistency";
+    case ZCONNECTIONLOSS:
+      return "connection loss";
+    case ZMARSHALLINGERROR:
+      return "marshalling error";
+    case ZUNIMPLEMENTED:
+      return "unimplemented";
+    case ZOPERATIONTIMEOUT:
+      return "operation timeout";
+    case ZBADARGUMENTS:
+      return "bad arguments";
+    case ZINVALIDSTATE:
+      return "invalid zhandle state";
+    case ZAPIERROR:
+      return "api error";
+    case ZNONODE:
+      return "no node";
+    case ZNOAUTH:
+      return "not authenticated";
+    case ZBADVERSION:
+      return "bad version";
+    case  ZNOCHILDRENFOREPHEMERALS:
+      return "no children for ephemerals";
+    case ZNODEEXISTS:
+      return "node exists";
+    case ZNOTEMPTY:
+      return "not empty";
+    case ZSESSIONEXPIRED:
+      return "session expired";
+    case ZINVALIDCALLBACK:
+      return "invalid callback";
+    case ZINVALIDACL:
+      return "invalid acl";
+    case ZAUTHFAILED:
+      return "authentication failed";
+    }
+    if (c > 0) {
+      return strerror(c);
+    }
+    return "unknown error";
+}
+
+int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert, 
+		int certLen,void_completion_t completion, const void *data)
+{
+    if (is_unrecoverable(zh))
+        return ZINVALIDSTATE;
+    
+	if(scheme==NULL || zh==NULL)
+		return ZBADARGUMENTS;
+	
+	free_auth_info(&zh->auth);
+	zh->auth.scheme=strdup(scheme);
+	if(cert!=NULL && certLen!=0){
+		zh->auth.auth.buff=malloc(certLen);
+		if(zh->auth.auth.buff==0)
+			return ZSYSTEMERROR;
+		memcpy(zh->auth.auth.buff,cert,certLen);
+		zh->auth.auth.len=certLen;
+	}
+	
+    zh->auth.completion=completion;
+    zh->auth.data=data;
+	if(zh->state == CONNECTED_STATE || zh->state == ASSOCIATING_STATE)
+		return send_auth_info(zh);
+	
+	return ZOK;
+}
+
+static const char* format_endpoint_info(const struct sockaddr* ep)
+{
+    static char buf[128];
+    char addrstr[128];
+    void *inaddr;
+    int port;
+    if(ep==0)
+        return "null";
+
+    inaddr=&((struct sockaddr_in*)ep)->sin_addr;
+    port=((struct sockaddr_in*)ep)->sin_port;
+    if(ep->sa_family==AF_INET6){
+    	inaddr=&((struct sockaddr_in6*)ep)->sin6_addr;
+    	port=((struct sockaddr_in6*)ep)->sin6_port;
+    }
+
+    inet_ntop(ep->sa_family,inaddr,addrstr,sizeof(addrstr)-1);
+    sprintf(buf,"%s:%d",addrstr,ntohs(port));
+    return buf;
+}
+
+static const char* format_current_endpoint_info(zhandle_t* zh){
+    return format_endpoint_info(&zh->addrs[zh->connect_index]);
+}
+
+void zoo_set_debug_level(ZooLogLevel level)
+{
+    if(level<LOG_LEVEL_ERROR)level=LOG_LEVEL_ERROR;
+    if(level>LOG_LEVEL_DEBUG)level=LOG_LEVEL_DEBUG;
+    logLevel=level;
+}
+
+void zoo_deterministic_conn_order(int yesOrNo)
+{
+    disable_conn_permute=yesOrNo;
+}
+
+/* ****************************************************************************
+ * sync API
+ */
+int zoo_create(zhandle_t *zh, const char *path, const char *value,
+        int valuelen, const struct ACL_vector *acl, int flags, char *realpath,
+        int max_realpath_len)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    sc->u.str.str = realpath;
+    sc->u.str.str_len = max_realpath_len;
+    zoo_acreate(zh, path, value, valuelen, acl, flags, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_delete(zhandle_t *zh, const char *path, int version)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_adelete(zh, path, version, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_exists(zhandle_t *zh, const char *path, int watch, struct Stat *stat)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_aexists(zh, path, watch, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    if (rc == 0&& stat) {
+        *stat = sc->u.stat;
+    }
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_get(zhandle_t *zh, const char *path, int watch, char *buffer,
+        int buffer_len, struct Stat *stat)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    sc->u.data.buffer = buffer;
+    sc->u.data.buff_len = buffer_len;
+    zoo_aget(zh, path, watch, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    if (rc == 0&& stat) {
+        *stat = sc->u.data.stat;
+        rc = sc->u.data.buff_len;
+    }
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_set(zhandle_t *zh, const char *path, const char *buffer, int buflen,
+        int version)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_aset(zh, path, buffer, buflen, version, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_get_children(zhandle_t *zh, const char *path, int watch,
+        struct String_vector *strings)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_aget_children(zh, path, watch, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    if (rc == 0) {
+        if (strings) {
+            *strings = sc->u.strs;
+        } else {
+            deallocate_String_vector(&sc->u.strs);
+        }
+    }
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_get_acl(zhandle_t *zh, const char *path, struct ACL_vector *acl,
+        struct Stat *stat)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_aget_acl(zh, path, SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    if (rc == 0&& stat) {
+        *stat = sc->u.acl.stat;
+    }
+    if (rc == 0) {
+        if (acl) {
+            *acl = sc->u.acl.acl;
+        } else {
+            deallocate_ACL_vector(&sc->u.acl.acl);
+        }
+    }
+    free_sync_completion(sc);
+    return rc;
+}
+
+int zoo_set_acl(zhandle_t *zh, const char *path, int version,
+        const struct ACL_vector *acl)
+{
+    struct sync_completion *sc = alloc_sync_completion();
+    int rc;
+    if (!sc) {
+        return ZSYSTEMERROR;
+    }
+    zoo_aset_acl(zh, path, version, (struct ACL_vector*)acl,
+            SYNCHRONOUS_MARKER, &sc);
+    wait_sync_completion(sc);
+    rc = sc->hdr.err;
+    free_sync_completion(sc);
+    return rc;
+}
diff --git a/zookeeper/java/src/com/yahoo/jute/compiler/JRecord.java b/zookeeper/java/src/com/yahoo/jute/compiler/JRecord.java
index c1ff1d5b7..cea95f3d2 100755
--- a/zookeeper/java/src/com/yahoo/jute/compiler/JRecord.java
+++ b/zookeeper/java/src/com/yahoo/jute/compiler/JRecord.java
@@ -135,6 +135,8 @@ public void genCCode(FileWriter h, FileWriter c) throws IOException {
 					c.write("        for(i=0;i<v->count; i++) {\n");
 					c.write("            deallocate_"+JRecord.extractMethodSuffix(jvType)+"(&v->data[i]);\n");
 					c.write("        }\n");
+					c.write("        free(v->data);\n");
+					c.write("        v->data = 0;\n");
 					c.write("    }\n");
 					c.write("    return 0;\n");
 					c.write("}\n");
