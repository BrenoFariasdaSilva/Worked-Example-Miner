diff --git a/zookeeper/c/tests/LibCMocks.cc b/zookeeper/c/tests/LibCMocks.cc
index dde691128..38cbed84f 100644
--- a/zookeeper/c/tests/LibCMocks.cc
+++ b/zookeeper/c/tests/LibCMocks.cc
@@ -19,9 +19,10 @@
 #include <iostream>
 #include <stdarg.h>
 
-#include "LibCMocks.h"
-#include "LibCSymTable.h"
 #include "Util.h"
+#include "LibCMocks.h"
+
+#undef USING_DUMA
 
 using namespace std;
 
@@ -117,32 +118,39 @@ Mock_gethostbyname::HostEntry& Mock_gethostbyname::HostEntry::addAddress(
 
 // *****************************************************************************
 // calloc
-
+#ifndef USING_DUMA
 DECLARE_WRAPPER(void*,calloc,(size_t p1, size_t p2)){
     if(!Mock_calloc::mock_)
         return CALL_REAL(calloc,(p1,p2));
     return Mock_calloc::mock_->call(p1,p2);
 }
-
-Mock_calloc* Mock_calloc::mock_=0;
+#endif
 
 void* Mock_calloc::call(size_t p1, size_t p2){
+#ifndef USING_DUMA
     if(counter++ ==callsBeforeFailure){
         counter=0;
         errno=errnoOnFailure;
         return 0;
     }
     return CALL_REAL(calloc,(p1,p2));
+#else
+    return 0;
+#endif
 }
 
+Mock_calloc* Mock_calloc::mock_=0;
+
 // *****************************************************************************
 // realloc
 
+#ifndef USING_DUMA
 void* realloc(void* p, size_t s){
     if(!Mock_realloc::mock_)
         return LIBC_SYMBOLS.realloc(p,s);
     return Mock_realloc::mock_->call(p,s);
 }
+#endif
 
 Mock_realloc* Mock_realloc::mock_=0;
 
@@ -179,12 +187,15 @@ int Mock_random::call(){
 
 // *****************************************************************************
 // free
+#ifndef USING_DUMA
 DECLARE_WRAPPER(void,free,(void* p)){
     if(Mock_free_noop::mock_ && !Mock_free_noop::mock_->nested)
         Mock_free_noop::mock_->call(p);
     else
         CALL_REAL(free,(p));
 }
+#endif
+
 void Mock_free_noop::call(void* p){
     // on cygwin libc++ is linked statically
     // push_back() may call free(), hence the nesting guards
@@ -195,9 +206,11 @@ void Mock_free_noop::call(void* p){
     nested--;
 }
 void Mock_free_noop::freeRequested(){
+#ifndef USING_DUMA
     synchronized(mx);
     for(unsigned i=0; i<requested.size();i++)
         CALL_REAL(free,(requested[i]));
+#endif
 }
 
 int Mock_free_noop::getFreeCount(void* p){
diff --git a/zookeeper/c/tests/LibCMocks.h b/zookeeper/c/tests/LibCMocks.h
index 77301ff53..87e2c37f3 100644
--- a/zookeeper/c/tests/LibCMocks.h
+++ b/zookeeper/c/tests/LibCMocks.h
@@ -25,7 +25,7 @@
 
 #include "MocksBase.h"
 #include "LibCSymTable.h"
-#include "Util.h"
+#include "ThreadingUtil.h"
 
 // *****************************************************************************
 // gethostbyname
diff --git a/zookeeper/c/tests/PthreadMocks.cc b/zookeeper/c/tests/PthreadMocks.cc
index 4d256234d..8c52e5e46 100644
--- a/zookeeper/c/tests/PthreadMocks.cc
+++ b/zookeeper/c/tests/PthreadMocks.cc
@@ -15,11 +15,12 @@
  */
 
 #include "PthreadMocks.h"
-#include "LibCSymTable.h"
-#include "Util.h"
 
 MockPthreadsBase* MockPthreadsBase::mock_=0;
 
+#undef USING_DUMA
+
+#ifndef USING_DUMA
 int pthread_cond_broadcast (pthread_cond_t *c){
     if(!MockPthreadsBase::mock_)
         return LIBC_SYMBOLS.pthread_cond_broadcast(c);
@@ -95,6 +96,7 @@ DECLARE_WRAPPER(int,pthread_mutex_unlock,(pthread_mutex_t *m)){
         return CALL_REAL(pthread_mutex_unlock,(m));
     return MockPthreadsBase::mock_->pthread_mutex_unlock(m);
 }
+#endif
 
 CheckedPthread::ThreadMap CheckedPthread::tmap_;
 CheckedPthread::MutexMap CheckedPthread::mmap_;
diff --git a/zookeeper/c/tests/PthreadMocks.h b/zookeeper/c/tests/PthreadMocks.h
index a7363a93d..3fbdb4403 100644
--- a/zookeeper/c/tests/PthreadMocks.h
+++ b/zookeeper/c/tests/PthreadMocks.h
@@ -21,12 +21,10 @@
 #include <string.h>
 #include <errno.h>
 
-#include "src/zk_adaptor.h"
-#include "src/zk_log.h"
-
 #include "Util.h"
 #include "MocksBase.h"
 #include "LibCSymTable.h"
+#include "ThreadingUtil.h"
 
 // an ABC for pthreads
 class MockPthreadsBase: public Mock
diff --git a/zookeeper/c/tests/TestDriver.cc b/zookeeper/c/tests/TestDriver.cc
index 0361cefc2..1b42f9080 100644
--- a/zookeeper/c/tests/TestDriver.cc
+++ b/zookeeper/c/tests/TestDriver.cc
@@ -93,11 +93,13 @@ int main( int argc, char* argv[] ) {
      outputter.write(); 
 
  // Uncomment this for XML output
+#ifdef ENABLE_XML_OUTPUT
      std::ofstream file( "tests.xml" );
      CPPUNIT_NS::XmlOutputter xml( &result, file );
      xml.setStyleSheet( "report.xsl" );
      xml.write();
      file.close();
+#endif
    }
    catch ( std::invalid_argument &e )  // Test path not resolved
    {
diff --git a/zookeeper/c/tests/TestOperations.cc b/zookeeper/c/tests/TestOperations.cc
index 815ae6a0e..33848866b 100644
--- a/zookeeper/c/tests/TestOperations.cc
+++ b/zookeeper/c/tests/TestOperations.cc
@@ -16,15 +16,8 @@
 
 #include <cppunit/extensions/HelperMacros.h>
 
-#include <zookeeper.h>
-#include "src/zk_adaptor.h"
-
-#include "LibCMocks.h"
 #include "ZKMocks.h"
 #include "CppAssertHelper.h"
-#ifdef THREADED
-#include "PthreadMocks.h"
-#endif
 
 using namespace std;
 
@@ -32,6 +25,7 @@ class Zookeeper_operations : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE(Zookeeper_operations);
     CPPUNIT_TEST(testOperationsAndDisconnectConcurrently1);
+    //CPPUNIT_TEST(testOperationsAndDisconnectConcurrently2);
     CPPUNIT_TEST(testConcurrentOperations1);
     CPPUNIT_TEST_SUITE_END();
     zhandle_t *zh;
@@ -59,111 +53,18 @@ public:
     {
         
     }
-#else
-    class Latch{
-    public:
-        virtual ~Latch(){}
-        virtual void await() =0;
-        virtual void signalAndWait() =0;
-        virtual void signal() =0;
-    };
-    
-    class CountDownLatch: public Latch{
-    public:
-        CountDownLatch(int count):count_(count){
-            pthread_cond_init(&cond_,0);
-            pthread_mutex_init(&mut_,0);            
-        }
-        virtual ~CountDownLatch(){
-            pthread_mutex_lock(&mut_);
-            if(count_!=0){
-                count_=0;
-                pthread_cond_broadcast(&cond_);                
-            }
-            pthread_mutex_unlock(&mut_);            
-            
-            pthread_cond_destroy(&cond_);
-            pthread_mutex_destroy(&mut_);            
-        }
-
-        virtual void await(){
-            pthread_mutex_lock(&mut_);
-            awaitImpl();
-            pthread_mutex_unlock(&mut_);                
-        }
-        virtual void signalAndWait(){
-            pthread_mutex_lock(&mut_);
-            signalImpl();
-            awaitImpl();
-            pthread_mutex_unlock(&mut_);                            
-        }
-        virtual void signal(){
-            pthread_mutex_lock(&mut_);
-            signalImpl();
-            pthread_mutex_unlock(&mut_);            
-        }
-    private:
-        void awaitImpl(){
-            while(count_!=0) 
-                pthread_cond_wait(&cond_,&mut_);            
-        }
-        void signalImpl(){
-            if(count_>0){
-                count_--;
-                pthread_cond_broadcast(&cond_);                
-            }
-        }
-        int count_;
-        pthread_mutex_t mut_;
-        pthread_cond_t cond_;
-    };
-    class TestJob{
-    public:
-        typedef long JobId;
-        TestJob():startLatch_(0),endLatch_(0){}
-        virtual ~TestJob(){}
-        
-        virtual void run() =0;
-        virtual void validate(const char* file, int line) const =0;
+    void testOperationsAndDisconnectConcurrently2()
+    {
         
-        virtual void start(Latch* startLatch=0,Latch* endLatch=0) {
-            startLatch_=startLatch;endLatch_=endLatch;
-            pthread_create(&thread_, 0, thread, this);
-        }
-        virtual JobId getJobId() const {
-            return (JobId)thread_;
-        }
-    private:
-        void awaitStart(){
-            if(startLatch_==0) return;
-            startLatch_->signalAndWait();
-        }
-        void signalFinished(){
-            if(endLatch_==0) return;
-            endLatch_->signal();
-        }
-        static void* thread(void* p){
-            TestJob* j=(TestJob*)p;
-            j->awaitStart();  // wait for the start command
-            j->run();
-            j->signalFinished();
-            pthread_detach(j->thread_);
-            return 0;
-        }
-        Latch* startLatch_;
-        Latch* endLatch_;
-        pthread_t thread_;
-    };
-#define VALIDATE_JOB(j) j.validate(__FILE__,__LINE__)
-    
-    class TestGetJob: public TestJob{
+    }
+#else   
+    class TestGetDataJob: public TestJob{
     public:
-        static const int REPS=3000;
-        TestGetJob(ZookeeperServer* svr,zhandle_t* zh)
-            :svr_(svr),zh_(zh),rc_(ZAPIERROR){}
+        TestGetDataJob(ZookeeperServer* svr,zhandle_t* zh, int reps=500)
+            :svr_(svr),zh_(zh),rc_(ZAPIERROR),reps_(reps){}
         virtual void run(){
             int i;
-            for(i=0;i<REPS;i++){
+            for(i=0;i<reps_;i++){
                 char buf;
                 int size=sizeof(buf);
                 svr_->addOperationResponse(new ZooGetResponse("1",1));
@@ -172,81 +73,88 @@ public:
                     break;
                 }
             }
-            //TEST_TRACE(("Finished %d iterations",i));
-        }
-        virtual void validate(const char* file, int line) const{
-            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
         }
         ZookeeperServer* svr_;
         zhandle_t* zh_;
         int rc_;
+        int reps_;
+    };
+    class TestConcurrentOpJob: public TestGetDataJob{
+    public:
+        static const int REPS=500;
+        TestConcurrentOpJob(ZookeeperServer* svr,zhandle_t* zh):
+            TestGetDataJob(svr,zh,REPS){}
+        virtual void validate(const char* file, int line) const{
+            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
+        }
     };
     void testConcurrentOperations1()
     {
-        // frozen time -- no timeouts and no pings
-        Mock_gettimeofday timeMock;
-        
-        ZookeeperServer zkServer;
-        Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
-        // must call zookeeper_close() while all the mocks are in the scope!
-        CloseFinally guard(&zh);
-        
-        zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
-        CPPUNIT_ASSERT(zh!=0);
-        // make sure the client has connected
-        while(zh->state!=CONNECTED_STATE)
-            millisleep(2);
-                
-        TestGetJob j1(&zkServer,zh);
-        TestGetJob j2(&zkServer,zh);
-        TestGetJob j3(&zkServer,zh);
-        TestGetJob j4(&zkServer,zh);
-        TestGetJob j5(&zkServer,zh);
-        TestGetJob j6(&zkServer,zh);
-        TestGetJob j7(&zkServer,zh);
-        TestGetJob j8(&zkServer,zh);
-        TestGetJob j9(&zkServer,zh);
-        TestGetJob j10(&zkServer,zh);
-
-        const int THREAD_COUNT=10;
-        CountDownLatch startLatch(THREAD_COUNT);
-        CountDownLatch endLatch(THREAD_COUNT);
-
-        j1.start(&startLatch,&endLatch);
-        j2.start(&startLatch,&endLatch);
-        j3.start(&startLatch,&endLatch);
-        j4.start(&startLatch,&endLatch);
-        j5.start(&startLatch,&endLatch);
-        j6.start(&startLatch,&endLatch);
-        j7.start(&startLatch,&endLatch);
-        j8.start(&startLatch,&endLatch);
-        j9.start(&startLatch,&endLatch);
-        j10.start(&startLatch,&endLatch);
-        endLatch.await();
-        // validate test results
-        VALIDATE_JOB(j1);
-        VALIDATE_JOB(j2);
-        VALIDATE_JOB(j3);
-        VALIDATE_JOB(j4);
-        VALIDATE_JOB(j5);
-        VALIDATE_JOB(j6);
-        VALIDATE_JOB(j7);
-        VALIDATE_JOB(j8);
-        VALIDATE_JOB(j9);
-        VALIDATE_JOB(j10);
+        for(int counter=0; counter<50; counter++){
+            // frozen time -- no timeouts and no pings
+            Mock_gettimeofday timeMock;
+            
+            ZookeeperServer zkServer;
+            Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+            // must call zookeeper_close() while all the mocks are in the scope!
+            CloseFinally guard(&zh);
+            
+            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
+            CPPUNIT_ASSERT(zh!=0);
+            // make sure the client has connected
+            while(zh->state!=CONNECTED_STATE)
+                millisleep(2);
+                    
+            TestConcurrentOpJob j1(&zkServer,zh);
+            TestConcurrentOpJob j2(&zkServer,zh);
+            TestConcurrentOpJob j3(&zkServer,zh);
+            TestConcurrentOpJob j4(&zkServer,zh);
+            TestConcurrentOpJob j5(&zkServer,zh);
+            TestConcurrentOpJob j6(&zkServer,zh);
+            TestConcurrentOpJob j7(&zkServer,zh);
+            TestConcurrentOpJob j8(&zkServer,zh);
+            TestConcurrentOpJob j9(&zkServer,zh);
+            TestConcurrentOpJob j10(&zkServer,zh);
+    
+            const int THREAD_COUNT=10;
+            CountDownLatch startLatch(THREAD_COUNT);
+            CountDownLatch endLatch(THREAD_COUNT);
+    
+            j1.start(&startLatch,&endLatch);
+            j2.start(&startLatch,&endLatch);
+            j3.start(&startLatch,&endLatch);
+            j4.start(&startLatch,&endLatch);
+            j5.start(&startLatch,&endLatch);
+            j6.start(&startLatch,&endLatch);
+            j7.start(&startLatch,&endLatch);
+            j8.start(&startLatch,&endLatch);
+            j9.start(&startLatch,&endLatch);
+            j10.start(&startLatch,&endLatch);
+            endLatch.await();
+            // validate test results
+            VALIDATE_JOB(j1);
+            VALIDATE_JOB(j2);
+            VALIDATE_JOB(j3);
+            VALIDATE_JOB(j4);
+            VALIDATE_JOB(j5);
+            VALIDATE_JOB(j6);
+            VALIDATE_JOB(j7);
+            VALIDATE_JOB(j8);
+            VALIDATE_JOB(j9);
+            VALIDATE_JOB(j10);
+        }
     }
-    class TestGetWithDisconnectJob: public TestJob{
+    class ZKGetJob: public TestJob{
     public:
-        static const int REPS=3000;
-        TestGetWithDisconnectJob(ZookeeperServer* svr,zhandle_t* zh)
-            :svr_(svr),zh_(zh),rc_(ZAPIERROR){}
+        static const int REPS=1000;
+        ZKGetJob(zhandle_t* zh)
+            :zh_(zh),rc_(ZAPIERROR){}
         virtual void run(){
             int i;
             for(i=0;i<REPS;i++){
                 char buf;
                 int size=sizeof(buf);                
-                svr_->addOperationResponse(new ZooGetResponse("1",1));
-                rc_=zoo_get(zh_,"/x/y/z",0,&buf,&size,0);
+                rc_=zoo_get(zh_,"/xyz",0,&buf,&size,0);
                 if(rc_!=ZOK){
                     break;
                 }
@@ -254,16 +162,91 @@ public:
             //TEST_TRACE(("Finished %d iterations",i));
         }
         virtual void validate(const char* file, int line) const{
-            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZCONNECTIONLOSS,rc_,file,line);
+            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
         }
-        ZookeeperServer* svr_;
         zhandle_t* zh_;
         int rc_;
     };
 
+    void testOperationsAndDisconnectConcurrently2()
+    {
+        zhandle_t* lzh=zookeeper_init("localhost:3181",watcher,10000,0,0,0);
+        CPPUNIT_ASSERT(lzh!=0);
+        // make sure the client has connected
+        while(lzh->state!=CONNECTED_STATE)
+            millisleep(2);
+        char realpath[1024];
+        int rc=zoo_create(lzh,"/xyz","1",1,&OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
+        CPPUNIT_ASSERT(rc==ZOK || rc==ZNODEEXISTS);
+        zookeeper_close(lzh); 
+  
+        for(int counter=0; counter<200; counter++){
+            TEST_TRACE(("Loop count %d",counter));
+            
+            CloseFinally guard(&zh);
+
+            zh=zookeeper_init("localhost:3181",watcher,10000,0,0,0);
+            CPPUNIT_ASSERT(zh!=0);
+            // make sure the client has connected
+            while(zh->state!=CONNECTED_STATE)
+                millisleep(2);
+            
+            const int THREAD_COUNT=10;
+            CountDownLatch startLatch(THREAD_COUNT);
+            CountDownLatch endLatch(THREAD_COUNT);
+
+            ZKGetJob j1(zh);
+            j1.start(0,&endLatch);
+            ZKGetJob j2(zh);
+            j2.start(0,&endLatch);
+            ZKGetJob j3(zh);
+            j3.start(0,&endLatch);
+            ZKGetJob j4(zh);
+            j4.start(0,&endLatch);
+            ZKGetJob j5(zh);
+            j5.start(0,&endLatch);
+            ZKGetJob j6(zh);
+            j6.start(0,&endLatch);
+            ZKGetJob j7(zh);
+            j7.start(0,&endLatch);
+            ZKGetJob j8(zh);
+            j8.start(0,&endLatch);
+            ZKGetJob j9(zh);
+            j9.start(0,&endLatch);
+            ZKGetJob j10(zh);
+            j10.start(0,&endLatch);
+            millisleep(5);
+
+            endLatch.await();
+            VALIDATE_JOB(j1);
+            VALIDATE_JOB(j2);
+            VALIDATE_JOB(j3);
+            VALIDATE_JOB(j4);
+            VALIDATE_JOB(j5);
+            VALIDATE_JOB(j6);
+            VALIDATE_JOB(j7);
+            VALIDATE_JOB(j8);
+            VALIDATE_JOB(j9);
+            VALIDATE_JOB(j10);
+            TEST_TRACE(("run %d finished",counter));
+        }
+
+    }
+
+    class TestConcurrentOpWithDisconnectJob: public TestGetDataJob{
+    public:
+        static const int REPS=500;
+        TestConcurrentOpWithDisconnectJob(ZookeeperServer* svr,zhandle_t* zh):
+            TestGetDataJob(svr,zh,REPS){}
+        virtual void validate(const char* file, int line) const{
+            CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZCONNECTIONLOSS != rc",ZCONNECTIONLOSS,rc_,file,line);
+        }
+    };
+
     void testOperationsAndDisconnectConcurrently1()
     {
-        for(int counter=0; counter<500; counter++){
+        for(int counter=0; counter<50; counter++){
+            //TEST_TRACE(("Loop count %d",counter));
             // frozen time -- no timeouts and no pings
             Mock_gettimeofday timeMock;
             
@@ -276,34 +259,34 @@ public:
             CPPUNIT_ASSERT(zh!=0);
             // make sure the client has connected
             while(zh->state!=CONNECTED_STATE)
-                millisleep(2);
+                millisleep(1);
             
             const int THREAD_COUNT=10;
             CountDownLatch startLatch(THREAD_COUNT);
             CountDownLatch endLatch(THREAD_COUNT);
 
-            TestGetWithDisconnectJob j1(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j1(&zkServer,zh);
             j1.start(0,&endLatch);
-            TestGetWithDisconnectJob j2(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j2(&zkServer,zh);
             j2.start(0,&endLatch);
-            TestGetWithDisconnectJob j3(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j3(&zkServer,zh);
             j3.start(0,&endLatch);
-            TestGetWithDisconnectJob j4(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j4(&zkServer,zh);
             j4.start(0,&endLatch);
-            TestGetWithDisconnectJob j5(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j5(&zkServer,zh);
             j5.start(0,&endLatch);
-            TestGetWithDisconnectJob j6(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j6(&zkServer,zh);
             j6.start(0,&endLatch);
-            TestGetWithDisconnectJob j7(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j7(&zkServer,zh);
             j7.start(0,&endLatch);
-            TestGetWithDisconnectJob j8(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j8(&zkServer,zh);
             j8.start(0,&endLatch);
-            TestGetWithDisconnectJob j9(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j9(&zkServer,zh);
             j9.start(0,&endLatch);
-            TestGetWithDisconnectJob j10(&zkServer,zh);
+            TestConcurrentOpWithDisconnectJob j10(&zkServer,zh);
             j10.start(0,&endLatch);
             millisleep(5);
-            // reconnect attempts will start failing immediately
+            // reconnect attempts will start failing immediately 
             zkServer.setServerDown(0);
             // next recv call will return 0
             zkServer.setConnectionLost();
diff --git a/zookeeper/c/tests/TestZookeeperClose.cc b/zookeeper/c/tests/TestZookeeperClose.cc
index 1ff981081..e2894263f 100644
--- a/zookeeper/c/tests/TestZookeeperClose.cc
+++ b/zookeeper/c/tests/TestZookeeperClose.cc
@@ -16,12 +16,7 @@
 
 #include <cppunit/extensions/HelperMacros.h>
 
-#include <zookeeper.h>
-#include "src/zk_adaptor.h"
-
-#include "LibCMocks.h"
 #include "ZKMocks.h"
-#include "Util.h"
 
 #ifdef THREADED
 #include "PthreadMocks.h"
@@ -190,7 +185,6 @@ public:
     }
     void testCloseUnconnected1()
     {
-        //zoo_set_debug_level(LOG_LEVEL_DEBUG);
         for(int i=0; i<100;i++){
             zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0); 
             CPPUNIT_ASSERT(zh!=0);
diff --git a/zookeeper/c/tests/TestZookeeperInit.cc b/zookeeper/c/tests/TestZookeeperInit.cc
index 2e04d450b..f4142f4b9 100644
--- a/zookeeper/c/tests/TestZookeeperInit.cc
+++ b/zookeeper/c/tests/TestZookeeperInit.cc
@@ -15,15 +15,12 @@
  */
 
 #include <cppunit/extensions/HelperMacros.h>
-
-#include <zookeeper.h>
-#include "src/zk_adaptor.h"
-
 #include <netinet/in.h>
 #include <errno.h>
 
-#include "LibCMocks.h"
 #include "Util.h"
+#include "LibCMocks.h"
+
 #ifdef THREADED
 #include "PthreadMocks.h"
 #else
diff --git a/zookeeper/c/tests/ThreadingUtil.cc b/zookeeper/c/tests/ThreadingUtil.cc
new file mode 100644
index 000000000..4e1373ad9
--- /dev/null
+++ b/zookeeper/c/tests/ThreadingUtil.cc
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include "ThreadingUtil.h"
+#include "LibCSymTable.h"
+
+#ifdef THREADED
+
+// ****************************************************************************
+// Mutex wrapper
+struct Mutex::Impl{
+    Impl(){
+        LIBC_SYMBOLS.pthread_mutex_init(&mut_, 0);        
+    }
+    ~Impl(){
+        LIBC_SYMBOLS.pthread_mutex_destroy(&mut_);        
+    }
+    pthread_mutex_t mut_;
+};
+
+Mutex::Mutex():impl_(new Impl) {}
+Mutex::~Mutex() { delete impl_;}
+void Mutex::acquire() {
+    LIBC_SYMBOLS.pthread_mutex_lock(&impl_->mut_);
+}
+void Mutex::release() {
+    LIBC_SYMBOLS.pthread_mutex_unlock(&impl_->mut_);
+}
+
+// ****************************************************************************
+// Atomics
+int32_t atomic_post_incr(volatile int32_t* operand, int32_t incr)
+{
+    int32_t result;
+    __asm__ __volatile__(
+         "lock xaddl %0,%1\n"
+         : "=r"(result), "=m"(*(int32_t *)operand)
+         : "0"(incr)
+         : "memory");
+   return result;
+}
+int32_t atomic_fetch_store(volatile int32_t *ptr, int32_t value)
+{
+    int32_t result;
+    __asm__ __volatile__("lock xchgl %0,%1\n"
+                          : "=r"(result), "=m"(*(int32_t *)ptr)
+                          : "0"(value)
+                          : "memory");
+   return result; 
+}
+#else
+int32_t atomic_post_incr(volatile int32_t* operand, int32_t incr){
+    int32_t v=*operand;
+    *operand+=incr;
+    return v;
+}
+int32_t atomic_fetch_store(volatile int32_t *ptr, int32_t value)
+{
+    int32_t result=*ptr;
+    *ptr=value;
+    return result;
+}
+#endif // THREADED
diff --git a/zookeeper/c/tests/ThreadingUtil.h b/zookeeper/c/tests/ThreadingUtil.h
new file mode 100644
index 000000000..1cbfa7e1d
--- /dev/null
+++ b/zookeeper/c/tests/ThreadingUtil.h
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2008, Yahoo! Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef THREADINGUTIL_H_
+#define THREADINGUTIL_H_
+
+#ifdef THREADED
+#include "pthread.h"
+#endif
+
+// *****************************************************************************
+// Threading primitives
+
+// atomic post-increment; returns the previous value of the operand
+int32_t atomic_post_incr(volatile int32_t* operand, int32_t incr);
+// atomic fetch&store; returns the previous value of the operand
+int32_t atomic_fetch_store(volatile int32_t *operand, int32_t value);
+
+// a partial implementation of an atomic integer type
+class AtomicInt{
+public:
+    explicit AtomicInt(int32_t init=0):v_(init){}
+    AtomicInt(const AtomicInt& other):v_(other){}
+    // assigment
+    AtomicInt& operator=(const AtomicInt& lhs){
+        atomic_fetch_store(&v_,lhs);
+        return *this;
+    }
+    // pre-increment
+    AtomicInt& operator++() {
+        atomic_post_incr(&v_,1);
+        return *this;
+    }
+    // pre-decrement
+    AtomicInt& operator--() {
+        atomic_post_incr(&v_,-1);
+        return *this;
+    }
+    // post-increment
+    AtomicInt operator++(int){
+        return AtomicInt(atomic_post_incr(&v_,1));
+    }
+    // post-decrement
+    AtomicInt operator--(int){
+        return AtomicInt(atomic_post_incr(&v_,-1));
+    }
+    
+    operator int() const{
+        return atomic_post_incr(&v_,0);
+    }
+    int get() const{
+        return atomic_post_incr(&v_,0);
+    }
+private:
+    mutable int32_t v_;
+};
+
+#ifdef THREADED
+// ****************************************************************************
+class Mutex{
+public:
+    Mutex();
+    ~Mutex();
+    void acquire();
+    void release();
+private:
+    Mutex(const Mutex&);
+    Mutex& operator=(const Mutex&);
+    struct Impl;
+    Impl* impl_;
+};
+
+class MTLock{
+public:
+    MTLock(Mutex& m):m_(m){m.acquire();}
+    ~MTLock(){m_.release();}
+    Mutex& m_;
+};
+
+#define synchronized(m) MTLock __lock(m)
+
+// ****************************************************************************
+class Latch {
+public:
+    virtual ~Latch() {}
+    virtual void await() =0;
+    virtual void signalAndWait() =0;
+    virtual void signal() =0;
+};
+
+class CountDownLatch: public Latch {
+public:
+    CountDownLatch(int count):count_(count) {
+        pthread_cond_init(&cond_,0);
+        pthread_mutex_init(&mut_,0);
+    }
+    virtual ~CountDownLatch() {
+        pthread_mutex_lock(&mut_);
+        if(count_!=0) {
+            count_=0;
+            pthread_cond_broadcast(&cond_);
+        }
+        pthread_mutex_unlock(&mut_);
+
+        pthread_cond_destroy(&cond_);
+        pthread_mutex_destroy(&mut_);
+    }
+
+    virtual void await() {
+        pthread_mutex_lock(&mut_);
+        awaitImpl();
+        pthread_mutex_unlock(&mut_);
+    }
+    virtual void signalAndWait() {
+        pthread_mutex_lock(&mut_);
+        signalImpl();
+        awaitImpl();
+        pthread_mutex_unlock(&mut_);
+    }
+    virtual void signal() {
+        pthread_mutex_lock(&mut_);
+        signalImpl();
+        pthread_mutex_unlock(&mut_);
+    }
+private:
+    void awaitImpl() {
+        while(count_!=0)
+        pthread_cond_wait(&cond_,&mut_);
+    }
+    void signalImpl() {
+        if(count_>0) {
+            count_--;
+            pthread_cond_broadcast(&cond_);
+        }
+    }
+    int count_;
+    pthread_mutex_t mut_;
+    pthread_cond_t cond_;
+};
+
+#define VALIDATE_JOB(j) j.validate(__FILE__,__LINE__)
+
+class TestJob {
+public:
+    typedef long JobId;
+    TestJob():hasRun_(false),startLatch_(0),endLatch_(0) {}
+    virtual ~TestJob() {
+        join();
+    }
+
+    virtual void run() =0;
+    virtual void validate(const char* file, int line) const =0;
+
+    virtual void start(Latch* startLatch=0,Latch* endLatch=0) {
+        startLatch_=startLatch;endLatch_=endLatch;
+        hasRun_=true;
+        pthread_create(&thread_, 0, thread, this);
+    }
+    virtual JobId getJobId() const {
+        return (JobId)thread_;
+    }
+    virtual void join() {
+        if(!hasRun_)
+        return;
+        if(!pthread_equal(thread_,pthread_self()))
+        pthread_join(thread_,0);
+        else
+        pthread_detach(thread_);
+    }
+private:
+    void awaitStart() {
+        if(startLatch_==0) return;
+        startLatch_->signalAndWait();
+    }
+    void signalFinished() {
+        if(endLatch_==0) return;
+        endLatch_->signal();
+    }
+    static void* thread(void* p) {
+        TestJob* j=(TestJob*)p;
+        j->awaitStart(); // wait for the start command
+        j->run();
+        j->signalFinished();
+        return 0;
+    }
+    bool hasRun_;
+    Latch* startLatch_;
+    Latch* endLatch_;
+    pthread_t thread_;
+};
+#else // THREADED
+// single THREADED
+class Mutex{
+public:
+    void acquire(){}
+    void release(){}
+};
+#define synchronized(m)
+
+#endif // THREADED
+
+#endif /*THREADINGUTIL_H_*/
diff --git a/zookeeper/c/tests/Util.cc b/zookeeper/c/tests/Util.cc
index 862afa236..2f4881010 100644
--- a/zookeeper/c/tests/Util.cc
+++ b/zookeeper/c/tests/Util.cc
@@ -14,32 +14,7 @@
  * limitations under the License.
  */
 
-#include <zookeeper.h>
 #include "Util.h"
-#include "LibCSymTable.h"
-
-#ifdef THREADED
-#include <pthread.h>
-
-struct Mutex::Impl{
-    Impl(){
-        LIBC_SYMBOLS.pthread_mutex_init(&mut_, 0);        
-    }
-    ~Impl(){
-        LIBC_SYMBOLS.pthread_mutex_destroy(&mut_);        
-    }
-    pthread_mutex_t mut_;
-};
-
-Mutex::Mutex():impl_(new Impl) {}
-Mutex::~Mutex() { delete impl_;}
-void Mutex::acquire() {
-    LIBC_SYMBOLS.pthread_mutex_lock(&impl_->mut_);
-}
-void Mutex::release() {
-    LIBC_SYMBOLS.pthread_mutex_unlock(&impl_->mut_);
-}
-#endif
 
 void millisleep(int ms){
     timespec ts;
diff --git a/zookeeper/c/tests/Util.h b/zookeeper/c/tests/Util.h
index f61a53bf9..0f8a54f01 100644
--- a/zookeeper/c/tests/Util.h
+++ b/zookeeper/c/tests/Util.h
@@ -20,6 +20,8 @@
 #include <map>
 
 #include <zookeeper.h>
+#include "src/zk_log.h"
+#include "src/zk_adaptor.h"
 
 // number of elements in array
 #define COUNTOF(array) sizeof(array)/sizeof(array[0])
@@ -58,40 +60,6 @@ struct TypeOp<T*>{
     typedef typename TypeOp<T>::BareT BareT;
 };
 
-// *****************************************************************************
-// Threading primitives
-
-#ifdef THREADED
-class Mutex{
-public:
-    Mutex();
-    ~Mutex();
-    void acquire();
-    void release();
-private:
-    Mutex(const Mutex&);
-    Mutex& operator=(const Mutex&);
-    struct Impl;
-    Impl* impl_;
-};
-
-class MTLock{
-public:
-    MTLock(Mutex& m):m_(m){m.acquire();}
-    ~MTLock(){m_.release();}
-    Mutex& m_;
-};
-#define synchronized(m) MTLock __lock(m)
-#else 
-// single THREADED
-class Mutex{
-public:
-    void acquire(){}
-    void release(){}
-};
-#define synchronized(m)
-#endif
-
 // *****************************************************************************
 // Container utilities
 
diff --git a/zookeeper/c/tests/ZKMocks.cc b/zookeeper/c/tests/ZKMocks.cc
index 46fcf3690..93dd5eec5 100644
--- a/zookeeper/c/tests/ZKMocks.cc
+++ b/zookeeper/c/tests/ZKMocks.cc
@@ -17,12 +17,11 @@
 #include <arpa/inet.h>  // for htonl
 #include <memory>
 
-#include "ZKMocks.h"
-#include "Util.h"
-
 #include <zookeeper.jute.h>
 #include <proto.h>
 
+#include "ZKMocks.h"
+
 using namespace std;
 
 TestClientId testClientId;
@@ -71,6 +70,18 @@ DECLARE_WRAPPER(int,flush_send_queue,(zhandle_t*zh, int timeout))
 
 Mock_flush_send_queue* Mock_flush_send_queue::mock_=0;
 
+//******************************************************************************
+//
+DECLARE_WRAPPER(int32_t,get_xid,())
+{
+    if(!Mock_get_xid::mock_)
+        return CALL_REAL(get_xid,());
+    return Mock_get_xid::mock_->call();
+}
+
+Mock_get_xid* Mock_get_xid::mock_=0;
+
+
 //******************************************************************************
 //
 DECLARE_WRAPPER(int,adaptor_init,(zhandle_t* zh))
@@ -113,22 +124,28 @@ string ZooGetResponse::toString() const{
     serialize_ReplyHeader(oa, "hdr", &h);
     
     GetDataResponse resp;
+	char buf[1024];
+    assert("GetDataResponse is too long"&&data_.size()<=sizeof(buf));
     resp.data.len=data_.size();
-    resp.data.buff=(char*)malloc(data_.size());
+    resp.data.buff=buf;
     data_.copy(resp.data.buff, data_.size());
     resp.stat=stat_;
     serialize_GetDataResponse(oa, "reply", &resp);
     int32_t len=htonl(get_buffer_len(oa));
-    string buf((char*)&len,sizeof(len));
-    buf.append(get_buffer(oa),get_buffer_len(oa));
+    string res((char*)&len,sizeof(len));
+    res.append(get_buffer(oa),get_buffer_len(oa));
     
     close_buffer_oarchive(&oa,1);
-    return buf;
+    return res;
 }
 
 //******************************************************************************
 // Zookeeper server simulator
 // 
+bool ZookeeperServer::hasMoreRecv() const{
+  return recvHasMore.get()!=0;
+}
+
 ssize_t ZookeeperServer::callRecv(int s,void *buf,size_t len,int flags){
     if(connectionLost){
         recvReturnBuffer.erase();
@@ -136,6 +153,12 @@ ssize_t ZookeeperServer::callRecv(int s,void *buf,size_t len,int flags){
     }
     // done transmitting the current buffer?
     if(recvReturnBuffer.size()==0){
+        --recvHasMore;
+        if(recvQueue.empty()){ 
+		    static const string cannedResp(ZooGetResponse("1",1,Mock_get_xid::XID).toString());
+            recvReturnBuffer=cannedResp;
+            return Mock_socket::callRecv(s,buf,len,flags);
+        }
         synchronized(recvQMx);
         if(recvQueue.empty()) assert("Invalid recv call (empty recv queue)"&&false);
         Element& el=recvQueue.front();
@@ -157,6 +180,7 @@ void ZookeeperServer::notifyBufferSent(const std::string& buffer){
             // handle the handshake
             int64_t sessId=sessionExpired?req->sessionId+1:req->sessionId;
             sessionExpired=false;
+			++recvHasMore;
             addRecvResponse(new HandshakeResponse(sessId));            
             return;
         }
@@ -167,9 +191,11 @@ void ZookeeperServer::notifyBufferSent(const std::string& buffer){
     RequestHeader rh;
     deserialize_RequestHeader(ia,"hdr",&rh);
     close_buffer_iarchive(&ia);
-    if(rh.type==CLOSE_OP)
+    if(rh.type==CLOSE_OP){
         return; // no reply for close requests
+    }
     // get the next response from the response queue and append it to the receive list
+    ++recvHasMore;
     Element e;
     {
         synchronized(respQMx);
diff --git a/zookeeper/c/tests/ZKMocks.h b/zookeeper/c/tests/ZKMocks.h
index 0531f13c1..d6fb57ff0 100644
--- a/zookeeper/c/tests/ZKMocks.h
+++ b/zookeeper/c/tests/ZKMocks.h
@@ -17,19 +17,21 @@
 #ifndef ZKMOCKS_H_
 #define ZKMOCKS_H_
 
-#include <zookeeper.h>
-#include "src/zk_adaptor.h"
-
-#include "MocksBase.h"
 #include "Util.h"
 #include "LibCMocks.h"
+#include "MocksBase.h"
 
 struct CloseFinally{
     CloseFinally(zhandle_t** zh):zh_(zh){}
     ~CloseFinally(){
-        if(zh_==0)return;
-        zookeeper_close(*zh_);
+        execute();
+    }
+    int execute(){
+        if(zh_==0)return ZOK;
+        zhandle_t* lzh=*zh_;
         *zh_=0;
+        disarm();
+        return zookeeper_close(lzh);
     }
     void disarm(){zh_=0;}
     zhandle_t ** zh_;
@@ -74,6 +76,24 @@ public:
     static Mock_flush_send_queue* mock_;
 };
 
+// *****************************************************************************
+// get_xid
+
+class Mock_get_xid: public Mock
+{
+public:
+    static const int32_t XID=123456;
+    Mock_get_xid(int retValue=XID):callReturns(retValue){mock_=this;}
+    ~Mock_get_xid(){mock_=0;}
+    
+    int callReturns;
+    virtual int call(){
+        return callReturns;
+    }
+
+    static Mock_get_xid* mock_;
+};
+
 // *****************************************************************************
 // There is a problem with the existing Sync API: a watcher can be called before
 // the init function returned. It makes it impossible to set the watcher context
@@ -143,8 +163,8 @@ public:
 class ZooGetResponse: public Response
 {
 public:
-    ZooGetResponse(char* data, int len,int rc=ZOK,const Stat& stat=NodeStat())
-        :xid_(0),data_(data,len),rc_(rc),stat_(stat)
+    ZooGetResponse(char* data, int len,int32_t xid=0,int rc=ZOK,const Stat& stat=NodeStat())
+        :xid_(xid),data_(data,len),rc_(rc),stat_(stat)
     {
     }
     virtual std::string toString() const;
@@ -238,11 +258,10 @@ public:
             delete recvQueue[i].first;
         recvQueue.clear();
     }
+
     virtual ssize_t callRecv(int s,void *buf,size_t len,int flags);
-    virtual bool hasMoreRecv() const{
-        synchronized(recvQMx);
-        return recvQueue.size()!=0;
-    }
+    AtomicInt recvHasMore;
+    virtual bool hasMoreRecv() const;
     
     // send operation doesn't try to match request to the response
     ResponseList respQueue;
@@ -259,6 +278,7 @@ public:
         respQueue.clear();
     }
     virtual void notifyBufferSent(const std::string& buffer);
+    //Mock_get_xid mockXid;
 };
 
 #endif /*ZKMOCKS_H_*/
diff --git a/zookeeper/c/tests/wrappers-mt.opt b/zookeeper/c/tests/wrappers-mt.opt
index 1d94e0147..01046fbd8 100644
--- a/zookeeper/c/tests/wrappers-mt.opt
+++ b/zookeeper/c/tests/wrappers-mt.opt
@@ -1,2 +1,3 @@
 -Wl,--wrap -Wl,pthread_mutex_lock
--Wl,--wrap -Wl,pthread_mutex_unlock
\ No newline at end of file
+-Wl,--wrap -Wl,pthread_mutex_trylock
+-Wl,--wrap -Wl,pthread_mutex_unlock
diff --git a/zookeeper/c/tests/wrappers.opt b/zookeeper/c/tests/wrappers.opt
index b5b11a7c7..d47c3f677 100644
--- a/zookeeper/c/tests/wrappers.opt
+++ b/zookeeper/c/tests/wrappers.opt
@@ -1,4 +1,5 @@
 -Wl,--wrap -Wl,calloc
 -Wl,--wrap -Wl,free
 -Wl,--wrap -Wl,flush_send_queue
--Wl,--wrap -Wl,adaptor_init
\ No newline at end of file
+-Wl,--wrap -Wl,adaptor_init
+-Wl,--wrap -Wl,get_xid
