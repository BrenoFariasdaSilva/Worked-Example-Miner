diff --git a/zookeeper/c/tests/PthreadMocks.h b/zookeeper/c/tests/PthreadMocks.h
index 3fbdb4403..bcda81b51 100644
--- a/zookeeper/c/tests/PthreadMocks.h
+++ b/zookeeper/c/tests/PthreadMocks.h
@@ -21,6 +21,8 @@
 #include <string.h>
 #include <errno.h>
 
+#include "src/zk_adaptor.h"
+
 #include "Util.h"
 #include "MocksBase.h"
 #include "LibCSymTable.h"
@@ -237,11 +239,37 @@ public:
     }
 };
 
+struct ThreadInfo{
+    typedef enum {RUNNING,TERMINATED} ThreadState;
+    
+    ThreadInfo():
+        destructionCounter_(0),invalidAccessCounter_(0),state_(RUNNING)
+    {
+    }
+    
+    ThreadInfo& incDestroyed() {
+        destructionCounter_++;
+        return *this;
+    }
+    ThreadInfo& incInvalidAccess(){
+        invalidAccessCounter_++;
+        return *this;
+    }
+    ThreadInfo& setTerminated(){
+        state_=TERMINATED;
+        return *this;
+    }
+    int destructionCounter_;
+    int invalidAccessCounter_;
+    ThreadState state_;
+};
+
 class CheckedPthread: public MockPthreadsBase
 {
     // first => destruction counter
     // second => invalid access counter
-    typedef std::pair<int,int> Entry;
+    //typedef std::pair<int,int> Entry;
+    typedef ThreadInfo Entry;
     typedef std::map<pthread_t,Entry> ThreadMap;
     static ThreadMap tmap_;
     static ThreadMap& getMap(const TypeOp<pthread_t>::BareT&){return tmap_;}
@@ -260,9 +288,9 @@ class CheckedPthread: public MockPthreadsBase
         Entry e;
         synchronized(mx);
         if(getValue(getMap(Type()),t,e)){
-            putValue(getMap(Type()),t,Entry(e.first+1,e.second));
+            putValue(getMap(Type()),t,Entry(e).incDestroyed());
         }else{
-            putValue(getMap(Type()),t,Entry(1,0));
+            putValue(getMap(Type()),t,Entry().incDestroyed());
         }
     }
     template<class T>
@@ -271,17 +299,22 @@ class CheckedPthread: public MockPthreadsBase
         Entry e;
         synchronized(mx);
         if(!getValue(getMap(Type()),t,e))
-            putValue(getMap(Type()),t,Entry(0,0));
+            putValue(getMap(Type()),t,Entry());
     }
     template<class T>
     static void checkAccessed(T& t){
         typedef typename TypeOp<T>::BareT Type;
         Entry e;
         synchronized(mx);
-        if(getValue(getMap(Type()),t,e) && e.first>0)
-            putValue(getMap(Type()),t,Entry(e.first,e.second+1));
+        if(getValue(getMap(Type()),t,e) && e.destructionCounter_>0)
+            putValue(getMap(Type()),t,Entry(e).incInvalidAccess());
+    }
+    static void setTerminated(pthread_t t){
+        Entry e;
+        synchronized(mx);
+        if(getValue(tmap_,t,e))
+            putValue(tmap_,t,Entry(e).setTerminated());
     }
-
 public:
     bool verbose;
     CheckedPthread():verbose(false){
@@ -295,39 +328,58 @@ public:
         typedef typename TypeOp<T>::BareT Type;
         Entry e;
         synchronized(mx);
-        return getValue(getMap(Type()),t,e) && e.first==0;
+        return getValue(getMap(Type()),t,e) && e.destructionCounter_==0;
     }
     template <class T>
     static bool isDestroyed(const T& t){
         typedef typename TypeOp<T>::BareT Type;
         Entry e;
         synchronized(mx);
-        return getValue(getMap(Type()),t,e) && e.first>0;
+        return getValue(getMap(Type()),t,e) && e.destructionCounter_>0;
+    }
+    static bool isTerminated(pthread_t t){
+        Entry e;
+        synchronized(mx);
+        return getValue(tmap_,t,e) && e.state_==ThreadInfo::TERMINATED;        
     }
     template <class T>
     static int getDestroyCounter(const T& t){
         typedef typename TypeOp<T>::BareT Type;
         Entry e;
         synchronized(mx);
-        return getValue(getMap(Type()),t,e)?e.first:-1;
+        return getValue(getMap(Type()),t,e)?e.destructionCounter_:-1;
     }
     template<class T>
     static int getInvalidAccessCounter(const T& t){
         typedef typename TypeOp<T>::BareT Type;
         Entry e;
         synchronized(mx);
-        return getValue(getMap(Type()),t,e)?e.second:-1;
+        return getValue(getMap(Type()),t,e)?e.invalidAccessCounter_:-1;
     }
 
+    struct ThreadContext{
+        typedef void *(*ThreadFunc)(void *);
+        
+        ThreadContext(ThreadFunc func,void* param):func_(func),param_(param){}
+        ThreadFunc func_;
+        void* param_;        
+    };
+    static void* threadFuncWrapper(void* v){
+        ThreadContext* ctx=(ThreadContext*)v;
+        pthread_t t=pthread_self();
+        markCreated(t);
+        void* res=ctx->func_(ctx->param_);
+        setTerminated(pthread_self());
+        delete ctx;
+        return res;
+    }
     virtual int pthread_create(pthread_t * t, const pthread_attr_t *a,
-            void *(*f)(void *), void *d){
-        int ret=LIBC_SYMBOLS.pthread_create(t,a,f,d);
-        if(ret==0)
-            markCreated(*t);
-        if(verbose){
-            log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,
-                    format_log_message("thread created %p",*t));
-        }
+            void *(*f)(void *), void *d)
+    {
+        int ret=LIBC_SYMBOLS.pthread_create(t,a,threadFuncWrapper,
+                new ThreadContext(f,d));
+        if(verbose)
+            TEST_TRACE(("thread created %p",*t));
         return ret;
     }
     virtual int pthread_join(pthread_t t, void ** r){
diff --git a/zookeeper/c/tests/TestDriver.cc b/zookeeper/c/tests/TestDriver.cc
index 1b42f9080..88234aaf1 100644
--- a/zookeeper/c/tests/TestDriver.cc
+++ b/zookeeper/c/tests/TestDriver.cc
@@ -28,6 +28,8 @@
 #include <cppunit/XmlOutputter.h>
 #include <fstream>
 
+#include "Util.h"
+
 using namespace std;
 
 CPPUNIT_NS_BEGIN
@@ -65,7 +67,7 @@ int main( int argc, char* argv[] ) {
    // if command line contains "-ide" then this is the post build check
    // => the output must be in the compiler error format.
    //bool selfTest = (argc > 1) && (std::string("-ide") == argv[1]);
-   std::string testPath = (argc > 1) ? std::string(argv[1]) : std::string("");
+   globalTestConfig.addConfigFromCmdLine(argc,argv);
 
    // Create the event manager and test controller
    CPPUNIT_NS::TestResult controller;
@@ -73,7 +75,7 @@ int main( int argc, char* argv[] ) {
    CPPUNIT_NS::TestResultCollector result;
    controller.addListener( &result );
    
-   // Add a listener that print dots as test run.
+   // Add a listener that print dots as tests run.
 //   CPPUNIT_NS::TextTestProgressListener progress;
    CPPUNIT_NS::BriefTestProgressListener progress;
    controller.addListener( &progress );
@@ -83,9 +85,8 @@ int main( int argc, char* argv[] ) {
  
    try
    {
-     cout << "Running "  <<  testPath;
-     runner.run( controller, testPath );
-
+     cout << "Running "  <<  globalTestConfig.getTestName();
+     runner.run( controller, globalTestConfig.getTestName());
      cout<<endl;
 
      // Print test in a compiler compatible format.
diff --git a/zookeeper/c/tests/TestOperations.cc b/zookeeper/c/tests/TestOperations.cc
index c3e652387..cde158351 100644
--- a/zookeeper/c/tests/TestOperations.cc
+++ b/zookeeper/c/tests/TestOperations.cc
@@ -24,8 +24,10 @@ using namespace std;
 class Zookeeper_operations : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE(Zookeeper_operations);
+    CPPUNIT_TEST(testAsyncWatcher1);
+    CPPUNIT_TEST(testAsyncGetOperation);
     CPPUNIT_TEST(testOperationsAndDisconnectConcurrently1);
-    //CPPUNIT_TEST(testOperationsAndDisconnectConcurrently2);
+    CPPUNIT_TEST(testOperationsAndDisconnectConcurrently2);
     CPPUNIT_TEST(testConcurrentOperations1);
     CPPUNIT_TEST_SUITE_END();
     zhandle_t *zh;
@@ -44,17 +46,161 @@ public:
         zookeeper_close(zh);
     }
 
+    class AsyncGetOperationCompletion: public AsyncCompletion{
+    public:
+        AsyncGetOperationCompletion():called_(false),rc_(ZAPIERROR){}
+        virtual void dataCompl(int rc, const char *value, int len, const Stat *stat){
+            synchronized(mx_);
+            called_=true;
+            rc_=rc;
+            value_.erase();
+            if(rc!=ZOK) return;
+            value_.assign(value,len);
+            if(stat)
+                stat_=*stat;
+        }
+        bool operator()()const{
+            synchronized(mx_);
+            return called_;
+        }
+        mutable Mutex mx_;
+        bool called_;
+        int rc_;
+        string value_;
+        NodeStat stat_;
+    };
 #ifndef THREADED
+    // send two get data requests; verify that the corresponding completions called
     void testConcurrentOperations1()
     {
+        Mock_gettimeofday timeMock;
+        ZookeeperServer zkServer;
+        // must call zookeeper_close() while all the mocks are in scope
+        CloseFinally guard(&zh);
+        
+        zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // simulate connected state
+        zh->state=CONNECTED_STATE;
+        zh->fd=ZookeeperServer::FD;
+        zh->input_buffer=0;
+        gettimeofday(&zh->last_recv,0);
         
+        int fd=0;
+        int interest=0;
+        timeval tv;
+        // first operation
+        AsyncGetOperationCompletion res1;
+        zkServer.addOperationResponse(new ZooGetResponse("1",1));
+        int rc=zoo_aget(zh,"/x/y/1",0,asyncCompletion,&res1);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // second operation
+        AsyncGetOperationCompletion res2;
+        zkServer.addOperationResponse(new ZooGetResponse("2",1));
+        rc=zoo_aget(zh,"/x/y/2",0,asyncCompletion,&res2);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // process the send queue
+        rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+
+        CPPUNIT_ASSERT_EQUAL(ZOK,res1.rc_);
+        CPPUNIT_ASSERT_EQUAL(string("1"),res1.value_);
+        CPPUNIT_ASSERT_EQUAL(ZOK,res2.rc_);
+        CPPUNIT_ASSERT_EQUAL(string("2"),res2.value_);
     }
+    // send two getData requests and disconnect while the second request is
+    // outstanding;
+    // verify the completions are called
     void testOperationsAndDisconnectConcurrently1()
     {
+        Mock_gettimeofday timeMock;
+        ZookeeperServer zkServer;
+        // must call zookeeper_close() while all the mocks are in scope
+        CloseFinally guard(&zh);
+        
+        zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // simulate connected state
+        zh->state=CONNECTED_STATE;
+        zh->fd=ZookeeperServer::FD;
+        zh->input_buffer=0;
+        gettimeofday(&zh->last_recv,0);
         
+        int fd=0;
+        int interest=0;
+        timeval tv;
+        // first operation
+        AsyncGetOperationCompletion res1;
+        zkServer.addOperationResponse(new ZooGetResponse("1",1));
+        int rc=zoo_aget(zh,"/x/y/1",0,asyncCompletion,&res1);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // second operation
+        AsyncGetOperationCompletion res2;
+        zkServer.addOperationResponse(new ZooGetResponse("2",1));
+        rc=zoo_aget(zh,"/x/y/2",0,asyncCompletion,&res2);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // process the send queue
+        rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // simulate a disconnect
+        zkServer.setConnectionLost();
+        rc=zookeeper_process(zh,interest);
+        CPPUNIT_ASSERT_EQUAL(ZCONNECTIONLOSS,rc);
+        CPPUNIT_ASSERT_EQUAL(ZOK,res1.rc_);
+        CPPUNIT_ASSERT_EQUAL(string("1"),res1.value_);
+        CPPUNIT_ASSERT_EQUAL(ZCONNECTIONLOSS,res2.rc_);
+        CPPUNIT_ASSERT_EQUAL(string(""),res2.value_);
     }
+    // send two getData requests and simulate timeout while the both request
+    // are pending;
+    // verify the completions are called
     void testOperationsAndDisconnectConcurrently2()
     {
+        Mock_gettimeofday timeMock;
+        ZookeeperServer zkServer;
+        // must call zookeeper_close() while all the mocks are in scope
+        CloseFinally guard(&zh);
+        
+        zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // simulate connected state
+        zh->state=CONNECTED_STATE;
+        zh->fd=ZookeeperServer::FD;
+        zh->input_buffer=0;
+        gettimeofday(&zh->last_recv,0);
+        
+        int fd=0;
+        int interest=0;
+        timeval tv;
+        // first operation
+        AsyncGetOperationCompletion res1;
+        zkServer.addOperationResponse(new ZooGetResponse("1",1));
+        int rc=zoo_aget(zh,"/x/y/1",0,asyncCompletion,&res1);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // second operation
+        AsyncGetOperationCompletion res2;
+        zkServer.addOperationResponse(new ZooGetResponse("2",1));
+        rc=zoo_aget(zh,"/x/y/2",0,asyncCompletion,&res2);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        // simulate timeout
+        timeMock.tick(10); // advance system time by 10 secs
+        // the next call to zookeeper_interest should return ZOPERATIONTIMEOUT
+        rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        CPPUNIT_ASSERT_EQUAL(ZOPERATIONTIMEOUT,rc);
+        // make sure the completions have been called
+        CPPUNIT_ASSERT_EQUAL(ZOPERATIONTIMEOUT,res1.rc_);
+        CPPUNIT_ASSERT_EQUAL(ZOPERATIONTIMEOUT,res2.rc_);
+    }
+    void testAsyncGetOperation(){
+        
+    }
+    void testAsyncWatcher1(){
         
     }
 #else   
@@ -84,6 +230,9 @@ public:
         static const int REPS=500;
         TestConcurrentOpJob(ZookeeperServer* svr,zhandle_t* zh):
             TestGetDataJob(svr,zh,REPS){}
+        virtual TestJob* clone() const {
+            return new TestConcurrentOpJob(svr_,zh_);
+        }
         virtual void validate(const char* file, int line) const{
             CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZOK != rc",ZOK,rc_,file,line);
         }
@@ -99,49 +248,16 @@ public:
             // must call zookeeper_close() while all the mocks are in the scope!
             CloseFinally guard(&zh);
             
-            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
+            zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
             CPPUNIT_ASSERT(zh!=0);
             // make sure the client has connected
-            while(zh->state!=CONNECTED_STATE)
-                millisleep(2);
-                    
-            TestConcurrentOpJob j1(&zkServer,zh);
-            TestConcurrentOpJob j2(&zkServer,zh);
-            TestConcurrentOpJob j3(&zkServer,zh);
-            TestConcurrentOpJob j4(&zkServer,zh);
-            TestConcurrentOpJob j5(&zkServer,zh);
-            TestConcurrentOpJob j6(&zkServer,zh);
-            TestConcurrentOpJob j7(&zkServer,zh);
-            TestConcurrentOpJob j8(&zkServer,zh);
-            TestConcurrentOpJob j9(&zkServer,zh);
-            TestConcurrentOpJob j10(&zkServer,zh);
-    
-            const int THREAD_COUNT=10;
-            CountDownLatch startLatch(THREAD_COUNT);
-            CountDownLatch endLatch(THREAD_COUNT);
-    
-            j1.start(&startLatch,&endLatch);
-            j2.start(&startLatch,&endLatch);
-            j3.start(&startLatch,&endLatch);
-            j4.start(&startLatch,&endLatch);
-            j5.start(&startLatch,&endLatch);
-            j6.start(&startLatch,&endLatch);
-            j7.start(&startLatch,&endLatch);
-            j8.start(&startLatch,&endLatch);
-            j9.start(&startLatch,&endLatch);
-            j10.start(&startLatch,&endLatch);
-            endLatch.await();
+            CPPUNIT_ASSERT(ensureCondition(ClientConnected(zh),1000)<1000);
+            
+            TestJobManager jmgr(TestConcurrentOpJob(&zkServer,zh),10);
+            jmgr.startAllJobs();
+            jmgr.wait();
             // validate test results
-            VALIDATE_JOB(j1);
-            VALIDATE_JOB(j2);
-            VALIDATE_JOB(j3);
-            VALIDATE_JOB(j4);
-            VALIDATE_JOB(j5);
-            VALIDATE_JOB(j6);
-            VALIDATE_JOB(j7);
-            VALIDATE_JOB(j8);
-            VALIDATE_JOB(j9);
-            VALIDATE_JOB(j10);
+            VALIDATE_JOBS(jmgr);
         }
     }
     class ZKGetJob: public TestJob{
@@ -149,6 +265,9 @@ public:
         static const int REPS=1000;
         ZKGetJob(zhandle_t* zh)
             :zh_(zh),rc_(ZAPIERROR){}
+        virtual TestJob* clone() const {
+            return new ZKGetJob(zh_);
+        }
         virtual void run(){
             int i;
             for(i=0;i<REPS;i++){
@@ -168,13 +287,26 @@ public:
         int rc_;
     };
 
+    // this test connects to a real ZK server and creates the /xyz node and sends
+    // lots of zoo_get requests.
+    // to run this test use the following command:
+    // zktest-mt Zookeeper_operations::testOperationsAndDisconnectConcurrently2 localhost:3181
+    // where the second parameter is the server host and port
     void testOperationsAndDisconnectConcurrently2()
     {
-        zhandle_t* lzh=zookeeper_init("localhost:3181",watcher,10000,0,0,0);
+        if(globalTestConfig.getTestName().find(__func__)==string::npos || 
+                globalTestConfig.getExtraOptCount()==0)
+        {
+            // only run this test when specifically asked so
+            return;
+        }
+        string host(*(globalTestConfig.getExtraOptBegin()));
+        zhandle_t* lzh=zookeeper_init(host.c_str(),watcher,10000,0,0,0);
         CPPUNIT_ASSERT(lzh!=0);
         // make sure the client has connected
-        while(lzh->state!=CONNECTED_STATE)
-            millisleep(2);
+        CPPUNIT_ASSERT_MESSAGE("Unable to connect to the host",
+                ensureCondition(ClientConnected(zh),5000)<5000);
+        
         char realpath[1024];
         int rc=zoo_create(lzh,"/xyz","1",1,&OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
         CPPUNIT_ASSERT(rc==ZOK || rc==ZNODEEXISTS);
@@ -185,49 +317,16 @@ public:
             
             CloseFinally guard(&zh);
 
-            zh=zookeeper_init("localhost:3181",watcher,10000,0,0,0);
+            zh=zookeeper_init(host.c_str(),watcher,10000,0,0,0);
             CPPUNIT_ASSERT(zh!=0);
             // make sure the client has connected
-            while(zh->state!=CONNECTED_STATE)
-                millisleep(2);
+            CPPUNIT_ASSERT_MESSAGE("Unable to connect to the host",
+                    ensureCondition(ClientConnected(zh),5000)<5000);
             
-            const int THREAD_COUNT=10;
-            CountDownLatch startLatch(THREAD_COUNT);
-            CountDownLatch endLatch(THREAD_COUNT);
-
-            ZKGetJob j1(zh);
-            j1.start(0,&endLatch);
-            ZKGetJob j2(zh);
-            j2.start(0,&endLatch);
-            ZKGetJob j3(zh);
-            j3.start(0,&endLatch);
-            ZKGetJob j4(zh);
-            j4.start(0,&endLatch);
-            ZKGetJob j5(zh);
-            j5.start(0,&endLatch);
-            ZKGetJob j6(zh);
-            j6.start(0,&endLatch);
-            ZKGetJob j7(zh);
-            j7.start(0,&endLatch);
-            ZKGetJob j8(zh);
-            j8.start(0,&endLatch);
-            ZKGetJob j9(zh);
-            j9.start(0,&endLatch);
-            ZKGetJob j10(zh);
-            j10.start(0,&endLatch);
-            millisleep(5);
-
-            endLatch.await();
-            VALIDATE_JOB(j1);
-            VALIDATE_JOB(j2);
-            VALIDATE_JOB(j3);
-            VALIDATE_JOB(j4);
-            VALIDATE_JOB(j5);
-            VALIDATE_JOB(j6);
-            VALIDATE_JOB(j7);
-            VALIDATE_JOB(j8);
-            VALIDATE_JOB(j9);
-            VALIDATE_JOB(j10);
+            TestJobManager jmgr(ZKGetJob(zh),10);
+            jmgr.startJobsImmediately();
+            jmgr.wait();
+            VALIDATE_JOBS(jmgr);
             TEST_TRACE(("run %d finished",counter));
         }
 
@@ -238,11 +337,18 @@ public:
         static const int REPS=1000;
         TestConcurrentOpWithDisconnectJob(ZookeeperServer* svr,zhandle_t* zh):
             TestGetDataJob(svr,zh,REPS){}
+        virtual TestJob* clone() const {
+            return new TestConcurrentOpWithDisconnectJob(svr_,zh_);
+        }
         virtual void validate(const char* file, int line) const{
             CPPUNIT_ASSERT_EQUAL_MESSAGE_LOC("ZCONNECTIONLOSS != rc",ZCONNECTIONLOSS,rc_,file,line);
         }
     };
 
+    // this test is not 100% accurate in a sense it may not detect all error cases.
+    // TODO: I can't think of a test that is 100% accurate and doesn't interfere
+    //       with the code being tested (in terms of introducing additional 
+    //       implicit synchronization points)
     void testOperationsAndDisconnectConcurrently1()
     {
         for(int counter=0; counter<50; counter++){
@@ -255,55 +361,81 @@ public:
             // must call zookeeper_close() while all the mocks are in the scope!
             CloseFinally guard(&zh);
             
-            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0);
+            zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
             CPPUNIT_ASSERT(zh!=0);
             // make sure the client has connected
-            while(zh->state!=CONNECTED_STATE)
-                millisleep(1);
+            CPPUNIT_ASSERT(ensureCondition(ClientConnected(zh),1000)<1000);
             
-            const int THREAD_COUNT=10;
-            CountDownLatch startLatch(THREAD_COUNT);
-            CountDownLatch endLatch(THREAD_COUNT);
-
-            TestConcurrentOpWithDisconnectJob j1(&zkServer,zh);
-            j1.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j2(&zkServer,zh);
-            j2.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j3(&zkServer,zh);
-            j3.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j4(&zkServer,zh);
-            j4.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j5(&zkServer,zh);
-            j5.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j6(&zkServer,zh);
-            j6.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j7(&zkServer,zh);
-            j7.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j8(&zkServer,zh);
-            j8.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j9(&zkServer,zh);
-            j9.start(0,&endLatch);
-            TestConcurrentOpWithDisconnectJob j10(&zkServer,zh);
-            j10.start(0,&endLatch);
-            millisleep(5);
+            TestJobManager jmgr(TestConcurrentOpWithDisconnectJob(&zkServer,zh),10);
+            jmgr.startJobsImmediately();
+            millisleep(1);
             // reconnect attempts will start failing immediately 
             zkServer.setServerDown(0);
             // next recv call will return 0
             zkServer.setConnectionLost();
-            endLatch.await();
-            // validate test results
-            VALIDATE_JOB(j1);
-            VALIDATE_JOB(j2);
-            VALIDATE_JOB(j3);
-            VALIDATE_JOB(j4);
-            VALIDATE_JOB(j5);
-            VALIDATE_JOB(j6);
-            VALIDATE_JOB(j7);
-            VALIDATE_JOB(j8);
-            VALIDATE_JOB(j9);
-            VALIDATE_JOB(j10);
+            jmgr.wait();
+            VALIDATE_JOBS(jmgr);
+        }
+        
+    }
+    // call zoo_aget() in the multithreaded mode
+    void testAsyncGetOperation()
+    {
+        Mock_gettimeofday timeMock;
+        
+        ZookeeperServer zkServer;
+        Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+        // must call zookeeper_close() while all the mocks are in the scope!
+        CloseFinally guard(&zh);
+        
+        zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // make sure the client has connected
+        CPPUNIT_ASSERT(ensureCondition(ClientConnected(zh),1000)<1000);
+
+        AsyncGetOperationCompletion res1;
+        zkServer.addOperationResponse(new ZooGetResponse("1",1));
+        int rc=zoo_aget(zh,"/x/y/1",0,asyncCompletion,&res1);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        
+        CPPUNIT_ASSERT(ensureCondition(res1,1000)<1000);
+        CPPUNIT_ASSERT_EQUAL(ZOK,res1.rc_);
+        CPPUNIT_ASSERT_EQUAL(string("1"),res1.value_);        
+    }
+    class ChangeNodeWatcher: public WatcherAction{
+    public:
+        ChangeNodeWatcher():changed_(false){}
+        virtual void onNodeValueChanged(zhandle_t*,const char* path){
+            synchronized(mx_);
+            changed_=true;
+            if(path!=0) path_=path;
         }
+        SyncedBoolCondition isNodeChangedTriggered() const{
+            return SyncedBoolCondition(changed_,mx_);
+        }
+        bool changed_;
+        string path_;
+    };
+    // verify that async watcher is called for znode events (CREATED, DELETED etc.)
+    void testAsyncWatcher1(){
+        Mock_gettimeofday timeMock;
+        
+        ZookeeperServer zkServer;
+        Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+        // must call zookeeper_close() while all the mocks are in the scope!
+        CloseFinally guard(&zh);
         
+        ChangeNodeWatcher action;        
+        zh=zookeeper_init("localhost:2121",activeWatcher,10000,
+                TEST_CLIENT_ID,&action,0);
+        CPPUNIT_ASSERT(zh!=0);
+        // make sure the client has connected
+        CPPUNIT_ASSERT(ensureCondition(ClientConnected(zh),1000)<1000);
+
+        // trigger the watcher
+        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));
+        CPPUNIT_ASSERT(ensureCondition(action.isNodeChangedTriggered(),1000)<1000);
+        CPPUNIT_ASSERT_EQUAL(string("/x/y/z"),action.path_);                
     }
 #endif
 };
diff --git a/zookeeper/c/tests/TestZookeeperClose.cc b/zookeeper/c/tests/TestZookeeperClose.cc
index e2894263f..fc2e7c4d0 100644
--- a/zookeeper/c/tests/TestZookeeperClose.cc
+++ b/zookeeper/c/tests/TestZookeeperClose.cc
@@ -27,6 +27,9 @@ using namespace std;
 class Zookeeper_close : public CPPUNIT_NS::TestFixture
 {
     CPPUNIT_TEST_SUITE(Zookeeper_close);
+#ifdef THREADED
+    CPPUNIT_TEST(testIOThreadStoppedOnExpire);
+#endif
     CPPUNIT_TEST(testCloseUnconnected);
     CPPUNIT_TEST(testCloseUnconnected1);
     CPPUNIT_TEST(testCloseConnected1);
@@ -47,6 +50,20 @@ public:
         zookeeper_close(zh);
     }
 
+    class CloseOnSessionExpired: public WatcherAction{
+    public:
+        CloseOnSessionExpired(bool callClose=true):
+            callClose_(callClose),rc(ZOK){}
+        virtual void onSessionExpired(zhandle_t* zh){
+            memcpy(&lzh,zh,sizeof(lzh));
+            if(callClose_)
+                rc=zookeeper_close(zh);           
+        }
+        zhandle_t lzh;
+        bool callClose_;
+        int rc;
+    };
+    
 #ifndef THREADED
     void testCloseUnconnected()
     {       
@@ -76,7 +93,7 @@ public:
         zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0);       
         CPPUNIT_ASSERT(zh!=0);
         // simulate connected state 
-        zh->fd=100;
+        zh->fd=ZookeeperServer::FD;
         zh->state=CONNECTED_STATE;
         Mock_flush_send_queue zkMock;
         // do not actually free the memory while in zookeeper_close()
@@ -100,14 +117,13 @@ public:
     }
     void testCloseConnected1()
     {
-        zh=zookeeper_init("localhost:2121",watcher,10000,0,0,0);       
+        ZookeeperServer zkServer;
+        // poll() will called from zookeeper_close()
+        Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+
+        zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0);
         CPPUNIT_ASSERT(zh!=0);
 
-        Mock_socket sockMock;
-        sockMock.socketReturns=ZookeeperServer::FD;
-        sockMock.connectReturns=-1;
-        sockMock.connectErrno=EWOULDBLOCK;
-        
         Mock_gettimeofday timeMock;
         
         int fd=0;
@@ -123,17 +139,71 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
         CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
         
-        timeMock.tick();
         rc=zookeeper_interest(zh,&fd,&interest,&tv);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
-        // prepare the handshake response
-        sockMock.recvReturnBuffer=HandshakeResponse().toString();
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
         CPPUNIT_ASSERT_EQUAL(CONNECTED_STATE,zoo_state(zh));
+        // do not actually free the memory while in zookeeper_close()
+        Mock_free_noop freeMock;
+        // make a copy of zhandle before close() overwrites some of 
+        // it members with NULLs
+        zhandle_t lzh;
+        memcpy(&lzh,zh,sizeof(lzh));
+        zookeeper_close(zh);
+        zhandle_t* savezh=zh; zh=0;
+        freeMock.disable(); // disable mock's fake free()- use libc's free() instead
+        // memory
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.hostname));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh.addrs));
+        // the close request sent?
+        CPPUNIT_ASSERT_EQUAL(1,(int)zkServer.closeSent);
     }
     void testCloseFromWatcher1()
     {
+        Mock_gettimeofday timeMock;
+
+        ZookeeperServer zkServer;
+        // make the server return a non-matching session id
+        zkServer.returnSessionExpired();
+        // poll() will called from zookeeper_close()
+        Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+
+        CloseOnSessionExpired closeAction;
+        zh=zookeeper_init("localhost:2121",activeWatcher,10000,
+                TEST_CLIENT_ID,&closeAction,0);
+        CPPUNIT_ASSERT(zh!=0);
+        
+        int fd=0;
+        int interest=0;
+        timeval tv;
+        // initiate connection
+        int rc=zookeeper_interest(zh,&fd,&interest,&tv);        
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        CPPUNIT_ASSERT_EQUAL(CONNECTING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOOKEEPER_READ|ZOOKEEPER_WRITE,interest);
+        rc=zookeeper_process(zh,interest);
+        // make sure the handshake in progress 
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
+        CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
+        rc=zookeeper_interest(zh,&fd,&interest,&tv);
+        CPPUNIT_ASSERT_EQUAL(ZOK,rc);
+        
+        // do not actually free the memory while in zookeeper_close()
+        Mock_free_noop freeMock;
+        // should call the watcher with EXPIRED_SESSION_STATE state
+        rc=zookeeper_process(zh,interest);
+        zhandle_t* savezh=zh; zh=0;
+        freeMock.disable(); // disable mock's fake free()- use libc's free() instead
+        
+        CPPUNIT_ASSERT_EQUAL(EXPIRED_SESSION_STATE,zoo_state(savezh));
+        // memory
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.hostname));
+        CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.addrs));
+        // make sure the close request NOT sent
+        CPPUNIT_ASSERT_EQUAL(0,(int)zkServer.closeSent);
     }
 #else
     void testCloseUnconnected()
@@ -208,11 +278,10 @@ public:
             // do not actually free the memory while in zookeeper_close()
             Mock_free_noop freeMock;
             
-            zh=zookeeper_init("localhost:2121",watcher,10000,&testClientId,0,0); 
+            zh=zookeeper_init("localhost:2121",watcher,10000,TEST_CLIENT_ID,0,0); 
             CPPUNIT_ASSERT(zh!=0);
             // make sure the client has connected
-            while(zh->state!=CONNECTED_STATE)
-                millisleep(2);
+            CPPUNIT_ASSERT(ensureCondition(ClientConnected(zh),1000)<1000);
             // make a copy of zhandle before close() overwrites some of 
             // its members with NULLs
             zhandle_t lzh;
@@ -249,18 +318,15 @@ public:
         }
     }
     
-    class CloseOnSessionExpired: public WatcherAction{
-    public:
-        CloseOnSessionExpired(Zookeeper_close& test):test_(test),rc(ZOK){}
-        virtual void onSessionExpired(zhandle_t* zh){
-            memcpy(&lzh,zh,sizeof(lzh));
-            rc=zookeeper_close(zh);           
-        }
-        Zookeeper_close& test_;
-        zhandle_t lzh;
-        int rc;
+    struct PointerFreed{
+        PointerFreed(Mock_free_noop& freeMock,void* ptr):
+            freeMock_(freeMock),ptr_(ptr){}
+        bool operator()() const{return freeMock_.isFreed(ptr_); }
+        Mock_free_noop& freeMock_;
+        void* ptr_;
     };
-
+    // test if zookeeper_close may be called from a watcher callback on
+    // SESSION_EXPIRED event
     void testCloseFromWatcher1()
     {
         // frozen time -- no timeouts and no pings
@@ -277,15 +343,14 @@ public:
             // do not actually free the memory while in zookeeper_close()
             Mock_free_noop freeMock;
 
-            CloseOnSessionExpired closeAction(*this);
+            CloseOnSessionExpired closeAction;
             zh=zookeeper_init("localhost:2121",activeWatcher,10000,
-                    &testClientId,&closeAction,0);
+                    TEST_CLIENT_ID,&closeAction,0);
             
             CPPUNIT_ASSERT(zh!=0);
             // we rely on the fact that zh is freed the last right before
             // zookeeper_close() returns...
-            while(!freeMock.isFreed(zh))
-                millisleep(2);
+            CPPUNIT_ASSERT(ensureCondition(PointerFreed(freeMock,zh),1000)<1000);
             zhandle_t* lzh=zh;
             zh=0;
             // we're done, disable mock's fake free(), use libc's free() instead
@@ -317,6 +382,71 @@ public:
             CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->completions_to_process.cond));
         }
     }
+
+    void testIOThreadStoppedOnExpire()
+    {
+        // frozen time -- no timeouts and no pings
+        Mock_gettimeofday timeMock;
+        
+        for(int i=0;i<100;i++){
+            ZookeeperServer zkServer;
+            // make the server return a non-matching session id
+            zkServer.returnSessionExpired();
+            
+            Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
+            // use a checked version of pthread calls
+            CheckedPthread threadMock;
+            // do not call zookeeper_close() from the watcher
+            CloseOnSessionExpired closeAction(false);
+            zh=zookeeper_init("localhost:2121",activeWatcher,10000,
+                    &testClientId,&closeAction,0);
+            
+            // this is to ensure that if any assert fires, zookeeper_close() 
+            // will still be called while all the mocks are in the scope!
+            CloseFinally guard(&zh);
+
+            CPPUNIT_ASSERT(zh!=0);
+            CPPUNIT_ASSERT(ensureCondition(SessionExpired(zh),1000)<1000);
+            CPPUNIT_ASSERT(ensureCondition(IOThreadStopped(zh),1000)<1000);
+            // make sure the threads have not been destroyed yet
+            adaptor_threads* adaptor=(adaptor_threads*)zh->adaptor_priv;
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getDestroyCounter(adaptor->io));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getDestroyCounter(adaptor->completion));
+            // about to call zookeeper_close() -- no longer need the guard
+            guard.disarm();
+            
+            // do not actually free the memory while in zookeeper_close()
+            Mock_free_noop freeMock;
+            zookeeper_close(zh);
+            zhandle_t* lzh=zh; zh=0;
+            // we're done, disable mock's fake free(), use libc's free() instead
+            freeMock.disable();
+            
+            // memory
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(lzh));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.hostname));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.addrs));
+            CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(adaptor));
+            // threads
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->io));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(adaptor->completion));
+            // mutexes
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->to_send.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->sent_requests.lock));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->completions_to_process.lock));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->completions_to_process.lock));
+            // conditionals
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->sent_requests.cond));
+            CPPUNIT_ASSERT_EQUAL(1,CheckedPthread::getDestroyCounter(&lzh->completions_to_process.cond));
+            CPPUNIT_ASSERT_EQUAL(0,CheckedPthread::getInvalidAccessCounter(&lzh->completions_to_process.cond));
+        }
+    }
+
 #endif
 };
 
diff --git a/zookeeper/c/tests/TestZookeeperInit.cc b/zookeeper/c/tests/TestZookeeperInit.cc
index aad364910..2101975ed 100644
--- a/zookeeper/c/tests/TestZookeeperInit.cc
+++ b/zookeeper/c/tests/TestZookeeperInit.cc
@@ -21,6 +21,7 @@
 
 #include "Util.h"
 #include "LibCMocks.h"
+#include "ZKMocks.h"
 
 #ifdef THREADED
 #include "PthreadMocks.h"
diff --git a/zookeeper/c/tests/ThreadingUtil.h b/zookeeper/c/tests/ThreadingUtil.h
index 1cbfa7e1d..896a5dc1c 100644
--- a/zookeeper/c/tests/ThreadingUtil.h
+++ b/zookeeper/c/tests/ThreadingUtil.h
@@ -17,6 +17,8 @@
 #ifndef THREADINGUTIL_H_
 #define THREADINGUTIL_H_
 
+#include <vector>
+
 #ifdef THREADED
 #include "pthread.h"
 #endif
@@ -39,6 +41,10 @@ public:
         atomic_fetch_store(&v_,lhs);
         return *this;
     }
+    AtomicInt& operator=(int32_t i){
+        atomic_fetch_store(&v_,i);
+        return *this;
+    }
     // pre-increment
     AtomicInt& operator++() {
         atomic_post_incr(&v_,1);
@@ -70,6 +76,9 @@ private:
 
 #ifdef THREADED
 // ****************************************************************************
+#define VALIDATE_JOBS(jm) jm.validateJobs(__FILE__,__LINE__)
+#define VALIDATE_JOB(j) j.validate(__FILE__,__LINE__)
+
 class Mutex{
 public:
     Mutex();
@@ -96,7 +105,7 @@ public:
 class Latch {
 public:
     virtual ~Latch() {}
-    virtual void await() =0;
+    virtual void await() const =0;
     virtual void signalAndWait() =0;
     virtual void signal() =0;
 };
@@ -119,7 +128,7 @@ public:
         pthread_mutex_destroy(&mut_);
     }
 
-    virtual void await() {
+    virtual void await() const {
         pthread_mutex_lock(&mut_);
         awaitImpl();
         pthread_mutex_unlock(&mut_);
@@ -136,7 +145,7 @@ public:
         pthread_mutex_unlock(&mut_);
     }
 private:
-    void awaitImpl() {
+    void awaitImpl() const{
         while(count_!=0)
         pthread_cond_wait(&cond_,&mut_);
     }
@@ -147,12 +156,10 @@ private:
         }
     }
     int count_;
-    pthread_mutex_t mut_;
-    pthread_cond_t cond_;
+    mutable pthread_mutex_t mut_;
+    mutable pthread_cond_t cond_;
 };
 
-#define VALIDATE_JOB(j) j.validate(__FILE__,__LINE__)
-
 class TestJob {
 public:
     typedef long JobId;
@@ -160,6 +167,7 @@ public:
     virtual ~TestJob() {
         join();
     }
+    virtual TestJob* clone() const =0;
 
     virtual void run() =0;
     virtual void validate(const char* file, int line) const =0;
@@ -201,6 +209,42 @@ private:
     Latch* endLatch_;
     pthread_t thread_;
 };
+
+class TestJobManager {
+    typedef std::vector<TestJob*> JobList;
+public:
+    TestJobManager(const TestJob& tj,int threadCount=1):
+        startLatch_(threadCount),endLatch_(threadCount)
+    {
+        for(int i=0;i<threadCount;++i)
+            jobs_.push_back(tj.clone());
+    }
+    virtual ~TestJobManager(){
+        for(unsigned  i=0;i<jobs_.size();++i)
+            delete jobs_[i];
+    }
+    
+    virtual void startAllJobs() {
+        for(unsigned i=0;i<jobs_.size();++i)
+            jobs_[i]->start(&startLatch_,&endLatch_);
+    }
+    virtual void startJobsImmediately() {
+        for(unsigned i=0;i<jobs_.size();++i)
+            jobs_[i]->start(0,&endLatch_);
+    }
+    virtual void wait() const {
+        endLatch_.await();
+    }
+    virtual void validateJobs(const char* file, int line) const{
+        for(unsigned i=0;i<jobs_.size();++i)
+            jobs_[i]->validate(file,line);        
+    }
+private:
+    JobList jobs_;
+    CountDownLatch startLatch_;
+    CountDownLatch endLatch_;
+};
+
 #else // THREADED
 // single THREADED
 class Mutex{
diff --git a/zookeeper/c/tests/Util.cc b/zookeeper/c/tests/Util.cc
index 2f4881010..de48837a3 100644
--- a/zookeeper/c/tests/Util.cc
+++ b/zookeeper/c/tests/Util.cc
@@ -16,18 +16,13 @@
 
 #include "Util.h"
 
+const std::string EMPTY_STRING;
+
+TestConfig globalTestConfig;
+
 void millisleep(int ms){
     timespec ts;
     ts.tv_sec=ms/1000;
     ts.tv_nsec=(ms%1000)*1000000; // to nanoseconds
     nanosleep(&ts,0);
 }
-
-void activeWatcher(zhandle_t *zh, int type, int state, const char *path){
-    if(zh==0 || zoo_get_context(zh)==0) return;
-    WatcherAction* action=(WatcherAction*)zoo_get_context(zh);
-        
-    if(type==SESSION_EVENT && state==EXPIRED_SESSION_STATE)
-        action->onSessionExpired(zh);
-    // TODO: implement for the rest of the event types
-}
diff --git a/zookeeper/c/tests/Util.h b/zookeeper/c/tests/Util.h
index 0f8a54f01..1789cda6c 100644
--- a/zookeeper/c/tests/Util.h
+++ b/zookeeper/c/tests/Util.h
@@ -18,10 +18,10 @@
 #define UTIL_H_
 
 #include <map>
+#include <vector>
+#include <string>
 
-#include <zookeeper.h>
 #include "src/zk_log.h"
-#include "src/zk_adaptor.h"
 
 // number of elements in array
 #define COUNTOF(array) sizeof(array)/sizeof(array[0])
@@ -37,6 +37,8 @@
 #define TEST_TRACE(x) \
     log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
 
+extern const std::string EMPTY_STRING;
+
 // *****************************************************************************
 // A bit of wizardry to get to the bare type from a reference or a pointer 
 // to the type
@@ -85,21 +87,48 @@ bool getValue(const std::map<K,V>& map,const K& k,V& v){
 
 // *****************************************************************************
 // misc utils
-void millisleep(int ms);
 
+// millisecond sleep
+void millisleep(int ms);
+// evaluate given predicate until it returns true or the timeout 
+// (in millis) has expired
+template<class Predicate>
+int ensureCondition(const Predicate& p,int timeout){
+    int elapsed=0;
+    while(!p() && elapsed<timeout){
+        millisleep(2);
+        elapsed+=2;
+    }
+    return elapsed;
+};
 
 // *****************************************************************************
-// Abstract watcher action
-class WatcherAction{
+// test global configuration data 
+class TestConfig{
+    typedef std::vector<std::string> CmdLineOptList;
 public:
-    virtual ~WatcherAction(){}
-    
-    virtual void onSessionExpired(zhandle_t*) =0;
-    // TODO: add the rest of the events
+    typedef CmdLineOptList::const_iterator const_iterator;
+    TestConfig(){}
+    ~TestConfig(){}
+    void addConfigFromCmdLine(int argc, char* argv[]){
+        if(argc>=2)
+            testName_=argv[1];
+        for(int i=2; i<argc;++i)
+            cmdOpts_.push_back(argv[i]);
+    }
+    const_iterator getExtraOptBegin() const {return cmdOpts_.begin();}
+    const_iterator getExtraOptEnd() const {return cmdOpts_.end();}
+    size_t getExtraOptCount() const {
+        return cmdOpts_.size();
+    }
+    const std::string& getTestName() const {
+        return testName_=="all"?EMPTY_STRING:testName_;
+    }
+private:
+    CmdLineOptList cmdOpts_;
+    std::string testName_;
 };
-// zh->context is a pointer to a WatcherAction instance
-// based on the event type and state, the watcher calls a specific watcher 
-// action method
-void activeWatcher(zhandle_t *zh, int type, int state, const char *path);
+
+extern TestConfig globalTestConfig;
 
 #endif /*UTIL_H_*/
diff --git a/zookeeper/c/tests/ZKMocks.cc b/zookeeper/c/tests/ZKMocks.cc
index 93dd5eec5..db33084c3 100644
--- a/zookeeper/c/tests/ZKMocks.cc
+++ b/zookeeper/c/tests/ZKMocks.cc
@@ -17,9 +17,12 @@
 #include <arpa/inet.h>  // for htonl
 #include <memory>
 
-#include <zookeeper.jute.h>
+#include <zookeeper.h>
 #include <proto.h>
 
+#ifdef THREADED
+#include "PthreadMocks.h"
+#endif
 #include "ZKMocks.h"
 
 using namespace std;
@@ -59,6 +62,64 @@ HandshakeRequest* HandshakeRequest::parse(const std::string& buf){
     return 0;
 }
 
+// *****************************************************************************
+// watcher action implementation
+void activeWatcher(zhandle_t *zh, int type, int state, const char *path){
+    if(zh==0 || zoo_get_context(zh)==0) return;
+    WatcherAction* action=(WatcherAction*)zoo_get_context(zh);
+    action->setWatcherTriggered();    
+    
+    if(type==SESSION_EVENT && state==EXPIRED_SESSION_STATE)
+        action->onSessionExpired(zh);
+    if(type==CHANGED_EVENT)
+        action->onNodeValueChanged(zh,path);
+    // TODO: implement for the rest of the event types
+    // ...
+}
+SyncedBoolCondition WatcherAction::isWatcherTriggered() const{
+    return SyncedBoolCondition(triggered_,mx_);
+}
+
+// *****************************************************************************
+// a set of async completion signatures
+void asyncCompletion(int rc, ACL_vector *acl,Stat *stat, const void *data){
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->aclCompl(rc,acl,stat);
+}
+void asyncCompletion(int rc, const char *value, int len, const Stat *stat, 
+        const void *data){    
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->dataCompl(rc,value,len,stat);    
+}
+void asyncCompletion(int rc, const Stat *stat, const void *data){    
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->statCompl(rc,stat);
+}
+void asyncCompletion(int rc, const char *value, const void *data){
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->stringCompl(rc,value);
+}
+void asyncCompletion(int rc,const String_vector *strings, const void *data){    
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->stringsCompl(rc,strings);
+}
+void asyncCompletion(int rc, const void *data){    
+    assert("Completion data is NULL"&&data);
+    static_cast<AsyncCompletion*>((void*)data)->voidCompl(rc);
+}
+
+// *****************************************************************************
+// a predicate implementation
+bool IOThreadStopped::operator()() const{
+#ifdef THREADED
+    adaptor_threads* adaptor=(adaptor_threads*)zh_->adaptor_priv;
+    return CheckedPthread::isTerminated(adaptor->io);
+#else
+    assert("IOThreadStopped predicate is only for use with THREADED client"&& false);
+    return false;
+#endif
+}
+
 //******************************************************************************
 //
 DECLARE_WRAPPER(int,flush_send_queue,(zhandle_t*zh, int timeout))
@@ -81,23 +142,6 @@ DECLARE_WRAPPER(int32_t,get_xid,())
 
 Mock_get_xid* Mock_get_xid::mock_=0;
 
-
-//******************************************************************************
-//
-DECLARE_WRAPPER(int,adaptor_init,(zhandle_t* zh))
-{
-    if(!GetZHandleBeforInitReturned::mock_)
-        return CALL_REAL(adaptor_init,(zh));
-    return GetZHandleBeforInitReturned::mock_->call(zh);
-}
-
-int GetZHandleBeforInitReturned::call(zhandle_t *zh){
-    ptr=zh;
-    return CALL_REAL(adaptor_init,(zh));
-}
-
-GetZHandleBeforInitReturned* GetZHandleBeforInitReturned::mock_=0;
-
 //******************************************************************************
 //
 string HandshakeResponse::toString() const {
@@ -139,6 +183,22 @@ string ZooGetResponse::toString() const{
     return res;
 }
 
+string ZNodeEvent::toString() const{
+    oarchive* oa=create_buffer_oarchive();
+    struct WatcherEvent evt = {type_,0,(char*)path_.c_str()};
+    struct ReplyHeader h = {WATCHER_EVENT_XID,0,ZOK };
+    
+    serialize_ReplyHeader(oa, "hdr", &h);
+    serialize_WatcherEvent(oa, "event", &evt);
+    
+    int32_t len=htonl(get_buffer_len(oa));
+    string res((char*)&len,sizeof(len));
+    res.append(get_buffer(oa),get_buffer_len(oa));
+    
+    close_buffer_oarchive(&oa,1);
+    return res;
+}
+
 //******************************************************************************
 // Zookeeper server simulator
 // 
@@ -154,13 +214,13 @@ ssize_t ZookeeperServer::callRecv(int s,void *buf,size_t len,int flags){
     // done transmitting the current buffer?
     if(recvReturnBuffer.size()==0){
         --recvHasMore;
-        if(recvQueue.empty()){ 
-		    static const string cannedResp(ZooGetResponse("1",1,Mock_get_xid::XID).toString());
-            recvReturnBuffer=cannedResp;
-            return Mock_socket::callRecv(s,buf,len,flags);
-        }
+//        if(recvQueue.empty()){ 
+//		    static const string cannedResp(ZooGetResponse("1",1,Mock_get_xid::XID).toString());
+//            recvReturnBuffer=cannedResp;
+//            return Mock_socket::callRecv(s,buf,len,flags);
+//        }
         synchronized(recvQMx);
-        if(recvQueue.empty()) assert("Invalid recv call (empty recv queue)"&&false);
+        assert("Invalid recv call (empty recv queue)"&&!recvQueue.empty());
         Element& el=recvQueue.front();
         if(el.first!=0){
             recvReturnBuffer=el.first->toString();
@@ -180,7 +240,6 @@ void ZookeeperServer::notifyBufferSent(const std::string& buffer){
             // handle the handshake
             int64_t sessId=sessionExpired?req->sessionId+1:req->sessionId;
             sessionExpired=false;
-			++recvHasMore;
             addRecvResponse(new HandshakeResponse(sessId));            
             return;
         }
@@ -192,10 +251,10 @@ void ZookeeperServer::notifyBufferSent(const std::string& buffer){
     deserialize_RequestHeader(ia,"hdr",&rh);
     close_buffer_iarchive(&ia);
     if(rh.type==CLOSE_OP){
+        ++closeSent;
         return; // no reply for close requests
     }
     // get the next response from the response queue and append it to the receive list
-    ++recvHasMore;
     Element e;
     {
         synchronized(respQMx);
diff --git a/zookeeper/c/tests/ZKMocks.h b/zookeeper/c/tests/ZKMocks.h
index d6fb57ff0..53d20bc55 100644
--- a/zookeeper/c/tests/ZKMocks.h
+++ b/zookeeper/c/tests/ZKMocks.h
@@ -17,10 +17,96 @@
 #ifndef ZKMOCKS_H_
 #define ZKMOCKS_H_
 
+#include <zookeeper.h>
+#include "src/zk_adaptor.h"
+
 #include "Util.h"
 #include "LibCMocks.h"
 #include "MocksBase.h"
 
+// *****************************************************************************
+// Abstract watcher action
+struct SyncedBoolCondition;
+
+class WatcherAction{
+public:
+    WatcherAction():triggered_(false){}
+    virtual ~WatcherAction(){}
+    
+    virtual void onSessionExpired(zhandle_t*){}
+    virtual void onNodeValueChanged(zhandle_t*,const char* path){}
+    
+    SyncedBoolCondition isWatcherTriggered() const;
+    void setWatcherTriggered(){
+        synchronized(mx_);
+        triggered_=true;
+    }
+
+protected:
+    mutable Mutex mx_;
+    bool triggered_;
+};
+// zh->context is a pointer to a WatcherAction instance
+// based on the event type and state, the watcher calls a specific watcher 
+// action method
+void activeWatcher(zhandle_t *zh, int type, int state, const char *path);
+
+// *****************************************************************************
+// a set of async completion signatures
+class AsyncCompletion{
+public:
+    virtual ~AsyncCompletion(){}
+    virtual void aclCompl(int rc, ACL_vector *acl,Stat *stat){}
+    virtual void dataCompl(int rc, const char *value, int len, const Stat *stat){}
+    virtual void statCompl(int rc, const Stat *stat){}
+    virtual void stringCompl(int rc, const char *value){}
+    virtual void stringsCompl(int rc,const String_vector *strings){}
+    virtual void voidCompl(int rc){}
+};
+void asyncCompletion(int rc, ACL_vector *acl,Stat *stat, const void *data);
+void asyncCompletion(int rc, const char *value, int len, const Stat *stat, 
+        const void *data);
+void asyncCompletion(int rc, const Stat *stat, const void *data);
+void asyncCompletion(int rc, const char *value, const void *data);
+void asyncCompletion(int rc,const String_vector *strings, const void *data);
+void asyncCompletion(int rc, const void *data);
+
+// *****************************************************************************
+// some common predicates to use with ensureCondition():
+// checks if the connection is established
+struct ClientConnected{
+    ClientConnected(zhandle_t* zh):zh_(zh){}
+    bool operator()() const{
+        return zoo_state(zh_)==CONNECTED_STATE;
+    }
+    zhandle_t* zh_;
+};
+// check in the session expired
+struct SessionExpired{
+    SessionExpired(zhandle_t* zh):zh_(zh){}
+    bool operator()() const{
+        return zoo_state(zh_)==EXPIRED_SESSION_STATE;
+    }
+    zhandle_t* zh_;
+};
+// checks if the IO thread has stopped; CheckedPthread must be active
+struct IOThreadStopped{
+    IOThreadStopped(zhandle_t* zh):zh_(zh){}
+    bool operator()() const;
+    zhandle_t* zh_;
+};
+
+struct SyncedBoolCondition{
+    SyncedBoolCondition(const bool& cond,Mutex& mx):cond_(cond),mx_(mx){}
+    bool operator()() const{
+        synchronized(mx_);
+        return cond_;
+    }
+    const bool& cond_;
+    Mutex& mx_;
+};
+// *****************************************************************************
+// make sure to call zookeeper_close() even in presence of exceptions 
 struct CloseFinally{
     CloseFinally(zhandle_t** zh):zh_(zh){}
     ~CloseFinally(){
@@ -46,8 +132,13 @@ struct TestClientId: clientid_t{
     }
 };
 
+// *****************************************************************************
+// special client id recongnized by the ZK server simulator 
 extern TestClientId testClientId;
+#define TEST_CLIENT_ID &testClientId
 
+// *****************************************************************************
+//
 struct HandshakeRequest: public connect_req
 {
     static HandshakeRequest* parse(const std::string& buf);
@@ -94,25 +185,6 @@ public:
     static Mock_get_xid* mock_;
 };
 
-// *****************************************************************************
-// There is a problem with the existing Sync API: a watcher can be called before
-// the init function returned. It makes it impossible to set the watcher context
-// properly, if you want to use the zhandle in the watcher. 
-// This class is a dirty trick to get the newly allocated zhandle_t pointer 
-// before zoookeeper_init returned. 
-
-class GetZHandleBeforInitReturned: public Mock
-{
-public:
-    GetZHandleBeforInitReturned():ptr(0){mock_=this;}
-    ~GetZHandleBeforInitReturned(){mock_=0;}
-    
-    zhandle_t* ptr;
-    virtual int call(zhandle_t *zh);
-
-    static GetZHandleBeforInitReturned* mock_;
-};
-
 // *****************************************************************************
 // a zookeeper Stat wrapper
 struct NodeStat: public Stat
@@ -127,6 +199,9 @@ struct NodeStat: public Stat
         aversion=0;
         ephemeralOwner=0;
     }
+    NodeStat(const Stat& other){
+        memcpy(this,&other,sizeof(*this));
+    }
 };
 
 // *****************************************************************************
@@ -136,7 +211,7 @@ class Response
 public:
     virtual ~Response(){}
     
-    virtual void setXID(int32_t xid) =0;
+    virtual void setXID(int32_t xid){}
     virtual std::string toString() const =0;
 };
 
@@ -156,7 +231,6 @@ public:
     int32_t passwd_len;
     char passwd[16];
     virtual std::string toString() const ;
-    virtual void setXID(int32_t xid) {/* no-op */}
 };
 
 // zoo_get() response
@@ -177,6 +251,19 @@ private:
     Stat stat_;
 };
 
+// watcher znode event
+class ZNodeEvent: public Response
+{
+public:
+    ZNodeEvent(int type,const char* path):type_(type),path_(path){}
+    
+    virtual std::string toString() const;
+    
+private:
+    int type_;
+    std::string path_;
+};
+
 // ****************************************************************************
 // Zookeeper server simulator
 
@@ -237,30 +324,34 @@ public:
     typedef std::deque<Element> ResponseList;
     ResponseList recvQueue;
     mutable Mutex recvQMx;
+    AtomicInt recvHasMore;
     ZookeeperServer& addRecvResponse(Response* resp, int errnum=0){
         synchronized(recvQMx);
         recvQueue.push_back(Element(resp,errnum));
+        ++recvHasMore;
         return *this;
     }
     ZookeeperServer& addRecvResponse(int errnum){
         synchronized(recvQMx);
         recvQueue.push_back(Element(0,errnum));
+        ++recvHasMore;
         return *this;
     }
     ZookeeperServer& addRecvResponse(const Element& e){
         synchronized(recvQMx);
         recvQueue.push_back(e);
+        ++recvHasMore;
         return *this;
     }
     void clearRecvQueue(){
         synchronized(recvQMx);
+        recvHasMore=0;
         for(unsigned i=0; i<recvQueue.size();i++)
             delete recvQueue[i].first;
         recvQueue.clear();
     }
 
     virtual ssize_t callRecv(int s,void *buf,size_t len,int flags);
-    AtomicInt recvHasMore;
     virtual bool hasMoreRecv() const;
     
     // send operation doesn't try to match request to the response
@@ -277,8 +368,8 @@ public:
             delete respQueue[i].first;
         respQueue.clear();
     }
+    AtomicInt closeSent;
     virtual void notifyBufferSent(const std::string& buffer);
-    //Mock_get_xid mockXid;
 };
 
 #endif /*ZKMOCKS_H_*/
diff --git a/zookeeper/c/tests/wrappers.opt b/zookeeper/c/tests/wrappers.opt
index d47c3f677..372d4143c 100644
--- a/zookeeper/c/tests/wrappers.opt
+++ b/zookeeper/c/tests/wrappers.opt
@@ -1,5 +1,4 @@
 -Wl,--wrap -Wl,calloc
 -Wl,--wrap -Wl,free
 -Wl,--wrap -Wl,flush_send_queue
--Wl,--wrap -Wl,adaptor_init
 -Wl,--wrap -Wl,get_xid
